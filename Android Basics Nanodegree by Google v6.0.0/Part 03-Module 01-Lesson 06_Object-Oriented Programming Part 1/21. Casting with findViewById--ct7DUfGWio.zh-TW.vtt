WEBVTT
Kind: captions
Language: zh-TW

00:00:00.610 --> 00:00:02.650
我已經加入剛才我們在應用程式中看到的代碼

00:00:02.650 --> 00:00:07.660
這代碼是 View orderSummaryTextView
= findViewById

00:00:07.660 --> 00:00:13.000
然后 我們傳入 order_summary_text_view 的資源 ID

00:00:13.000 --> 00:00:15.910
但是這會造成下一行在 Android Studio 中發生錯誤

00:00:17.750 --> 00:00:21.830
提示說不能解析 setText 方法

00:00:21.830 --> 00:00:24.430
如果我在這里新增另外一行代碼

00:00:24.430 --> 00:00:27.880
可以顯示對於這個變數有效的方法型式

00:00:28.890 --> 00:00:32.400
因此 我們在這里建立 orderSummaryTextView 變數

00:00:32.400 --> 00:00:34.330
它是一個 TypeView

00:00:34.330 --> 00:00:37.520
因此在下一行 我們應該對它調用方法

00:00:37.520 --> 00:00:40.540
但是如果你看這里的自動填入提示

00:00:40.540 --> 00:00:44.120
這些方法實際上是 View 方法

00:00:44.120 --> 00:00:46.140
并沒有專門用于 TextView 的方法

00:00:47.200 --> 00:00:49.350
例如 這里沒有 setText 方法

00:00:51.320 --> 00:00:54.455
因此 當我們嘗試調用 setText 時

00:00:56.020 --> 00:01:00.890
你也不能設定文字大小 或設定文字顏色或任何其它項

00:01:00.890 --> 00:01:02.350
那么所有這些方法在哪里呢

00:01:03.840 --> 00:01:08.700
具體來說 TextView 是一種更特殊的檢視圖型別

00:01:10.430 --> 00:01:13.240
如果我們想要對這個物件調用 TextView 方法

00:01:13.240 --> 00:01:16.777
我們需要確定它是一個 TextView 物件

00:01:17.820 --> 00:01:21.160
好的 現在這個變數是一個 TextView 物件

00:01:21.160 --> 00:01:25.750
但是我們會看到另外一條錯誤 提示說型別不相容

00:01:25.750 --> 00:01:31.090
因為在右側需要一個 TextViewis 檢視圖 但是我們找到的只是一個常規檢視圖

00:01:31.090 --> 00:01:34.240
這是因為 findViewById 方法返回一個檢視圖

00:01:34.240 --> 00:01:35.558
我們如何解決這個問題呢

00:01:35.558 --> 00:01:41.720
由于 TextView 是一種更獨特的檢視圖型式 或者這樣說

00:01:41.720 --> 00:01:47.260
TextView 是子類別的檢視圖的 因此我們可以使用一種名為轉型的技術

00:01:47.260 --> 00:01:51.970
Java 中的轉型是指我們可以獲取此方法返回的 View

00:01:51.970 --> 00:01:54.280
然后實際上將它作為 TextView 進行處理

00:01:54.280 --> 00:01:58.760
現在 右側實際上是一個 TextView 物件

00:01:58.760 --> 00:02:02.168
然后我們可以將它存放在這個 orderSummaryTextView 變數內

00:02:03.460 --> 00:02:06.110
我知道 這確實有點難度 因為我們剛才

00:02:06.110 --> 00:02:07.970
講了一大堆的新概念

00:02:07.970 --> 00:02:09.210
現在讓我們來嘗試解釋一下

00:02:10.229 --> 00:02:14.280
findViewById 方法返回一個 View 類別的型別

00:02:14.280 --> 00:02:15.820
書寫這樣的標注

00:02:15.820 --> 00:02:19.690
用括弧標注需要的物件資料型別

00:02:19.690 --> 00:02:23.250
我們把這個 View 轉型為 TextView.

00:02:23.250 --> 00:02:27.217
這樣這里整個運算式的結果就是一個 TextView 物件

00:02:28.600 --> 00:02:32.140
然后 我們可把它存放入左側的變數

00:02:32.140 --> 00:02:35.790
也就是 orderSummary TextView 它的型別是 TextView

00:02:35.790 --> 00:02:40.740
現在 在后面的代碼行 我們可以對這個物件調用 TextView 方法

00:02:40.740 --> 00:02:43.720
現在你是否看到所有這有文本方法顯示在這里

00:02:44.840 --> 00:02:48.070
setAllCaps, setTextSize 和其他

00:02:48.070 --> 00:02:51.660
現在我可以刪除這個 因為 setText 將會發揮作用

00:02:51.660 --> 00:02:54.170
而不會有其他的錯誤

00:02:54.170 --> 00:02:57.100
因此 如果我們想要調用 TextView 方法

00:02:57.100 --> 00:02:59.410
我們需要一個 TextView 物件

00:02:59.410 --> 00:03:02.500
為了設定一個 TextView 物件 我們需要調用 findViewById

00:03:02.500 --> 00:03:06.890
然后將這個 View 物件轉型為 TextView

00:03:06.890 --> 00:03:09.700
這里能夠進行轉型是因為

00:03:09.700 --> 00:03:13.440
這個檢視圖階層中的 View 實際上是一個 TextView

00:03:13.440 --> 00:03:17.520
如果我們嘗試將它轉型為單選按鈕這樣的物件 它將不會發揮作用

00:03:17.520 --> 00:03:20.840
因為 orderSummaryTextView 實際上是一個 TextView

00:03:20.840 --> 00:03:23.000
因此我們可以將轉型為適當的型別

00:03:24.275 --> 00:03:28.370
同樣地 在 displayQuantity 方法中 我們調用 findViewById

00:03:28.370 --> 00:03:32.350
我們為數量 TextView 傳入一個資源 ID

00:03:32.350 --> 00:03:36.090
這返回一個 View 我們可以將轉型為 TextView

00:03:36.090 --> 00:03:39.330
我們可以將它存放在這個名為 quantityTextView 的變數內

00:03:40.400 --> 00:03:43.450
這個變數的型別是 TextView

00:03:43.450 --> 00:03:48.170
因此在后面的代碼行 我們可以對它調用 TextView 方法 例如 setText.

00:03:48.170 --> 00:03:51.160
這是使用轉型之后 經過更新的 MainActivity 代碼

00:03:51.160 --> 00:03:56.400
我們可以把這些檢視圖轉型為 TextViews 這樣我們就可以把它們存放到

00:03:56.400 --> 00:04:00.622
TextView 型別的變數 這樣在這個 MainActivity 變數清單中

00:04:00.622 --> 00:04:05.090
現在 quantityTextView 和 orderSummaryTextView 是 TextView 型別的

00:04:05.090 --> 00:04:06.820
我們可以對它們調用 TextView 方法

00:04:06.820 --> 00:04:10.810
我們不僅可以將它們作為 View 進行處理

00:04:10.810 --> 00:04:15.050
現在我們還可以對它們調用 TextView 專用方法

00:04:15.050 --> 00:04:19.041
例如 我們可以對 orderSummaryTextView 調用 setText 方法

00:04:19.041 --> 00:04:21.880
我們可以對 quantityTextView 調用 setText 方法

00:04:21.880 --> 00:04:22.650
因此你可以看到

00:04:22.650 --> 00:04:27.180
對於在什么位置使用什么資訊型別 你應該十分小心

00:04:27.180 --> 00:04:31.290
到目前為止 當我們調用方法時 我們并不需要考慮返回值

00:04:31.290 --> 00:04:34.400
因為 setText 方法實際上沒有返回值

00:04:34.400 --> 00:04:37.180
imageView.setImageResource 方法也是這樣的

00:04:37.180 --> 00:04:39.060
這個方法也沒有返回值

00:04:39.060 --> 00:04:41.540
但是其它方法有返回值

00:04:41.540 --> 00:04:45.590
例如在 TextView 類別中我們有一個 getTextSize 方法

00:04:45.590 --> 00:04:47.680
這個方法返回一個整數

00:04:47.680 --> 00:04:53.410
我們可以把這個方法的結果存放到名為 int 型別大小的變數之中

00:04:53.410 --> 00:04:55.140
這里有另一個方法 也具有一個返回值

00:04:55.140 --> 00:04:58.270
在 Button 類別中 你可以調用 getHeight 方法

00:04:58.270 --> 00:05:03.420
這個方法返回一個整數值 因此你可以把它存放在變數中

00:05:03.420 --> 00:05:06.450
如果你嘗試把這個結果放在字符串中

00:05:10.810 --> 00:05:14.988
為了知道需要把哪種型別的資料傳入方法

00:05:14.988 --> 00:05:19.290
以及從一個方法返回哪種型別的資料 你需要檢視文檔

00:05:19.290 --> 00:05:21.260
例如 在 TextView 類別中

00:05:21.260 --> 00:05:25.760
如果你調用這些方法中的任何一個方法 它會返回一個整數型別的值

00:05:25.760 --> 00:05:28.620
返回值資料型別位于這里的左側欄

00:05:28.620 --> 00:05:33.040
其它方法的返回值可能是 void 或布林值

00:05:33.040 --> 00:05:38.330
我們還沒有學習這兩種型的值 另外返回也可能是浮點數或長整數等

00:05:38.330 --> 00:05:42.790
這個文件頁還顯示每個方法的輸入變數的

00:05:42.790 --> 00:05:45.010
期望資料型別

00:05:45.010 --> 00:05:49.590
例如 setTextColor 方法需要整數作為輸入

00:05:49.590 --> 00:05:53.110
返回值是 void 因此沒有返回值

00:05:53.110 --> 00:05:56.010
讓我們來檢視文件 了解期望什么樣的資料型別

00:05:56.010 --> 00:05:58.750
否則 Android Studio 將會報錯

00:05:58.750 --> 00:06:01.070
提示資料型別不符合

00:06:01.070 --> 00:06:02.630
現在 請你來操練

00:06:02.630 --> 00:06:05.580
下面是四個不同的代碼示例

00:06:05.580 --> 00:06:10.100
一些代碼可能含有資料型別不符合錯誤

00:06:10.100 --> 00:06:11.165
如果你找到錯誤

00:06:11.165 --> 00:06:15.540
請在提供的方塊中描述你如何解決這個錯誤

00:06:15.540 --> 00:06:19.948
如果代碼是完美的 你可以直接寫出無錯誤字樣

00:06:19.948 --> 00:06:22.545
這個測驗有一點難度 因為我們只介紹了幾個概念

00:06:22.545 --> 00:06:26.555
而這個代碼對你來說有一點新鮮

00:06:26.555 --> 00:06:30.105
請不要著急 查看文件來了解這些方法

00:06:30.105 --> 00:06:33.695
保證輸入和返回值是正確的

00:06:33.695 --> 00:06:37.665
而且 如果我們要宣告變數 我們需要在這里設定正確的資料型別

00:06:37.665 --> 00:06:39.265
另外 請查看這些方法調用的相關文件

00:06:39.265 --> 00:06:42.375
確保使用正確的方法

