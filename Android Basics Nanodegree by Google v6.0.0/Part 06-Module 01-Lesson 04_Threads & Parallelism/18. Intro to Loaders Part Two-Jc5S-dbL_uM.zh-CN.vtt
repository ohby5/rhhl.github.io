WEBVTT
Kind: captions
Language: zh-CN

00:00:00.080 --> 00:00:03.107
你之前提到过 当 Activity 在 CreateLoader 上执行

00:00:03.107 --> 00:00:06.050
LoaderCallback 方法时 我们需要创建并返回一个 Loader

00:00:06.050 --> 00:00:07.720
我们应该怎么做呢?

00:00:07.720 --> 00:00:12.132
嗯 先创建一个 Loader 然后把 AsyncTaskLoader 类做为子类

00:00:12.132 --> 00:00:15.590
AsyncTaskLoader 有着 Loader 的所有优势

00:00:15.590 --> 00:00:18.260
就是说 它可以被 LoaderManager 管理

00:00:18.260 --> 00:00:22.680
实际上 在场景的背后 所有的作业 是通过 AsyncTask 来完成的

00:00:22.680 --> 00:00:26.630
现在我们来了解一下 AsyncTaskLoader 其实和其他 Loader 没有什么不同

00:00:26.630 --> 00:00:30.570
请注意 AsyncTaskLoader 从 Loader 类继承行为

00:00:30.570 --> 00:00:33.050
因此它也是一个带有 泛型参数 D 的泛型类

00:00:34.150 --> 00:00:37.780
向下滑动到公用方法部分 我们可以看到 泛型参数 D

00:00:37.780 --> 00:00:41.290
被用作 doInBackground 方法的返回值

00:00:41.290 --> 00:00:45.030
这个方法也是抽象的 就是说 我们需要定义行为

00:00:45.030 --> 00:00:48.350
并用我们所选的 数据类型来返回值

00:00:48.350 --> 00:00:51.400
只要类的声明 已经预指定了

00:00:51.400 --> 00:00:52.220
数据类型

00:00:54.410 --> 00:00:56.861
我这里有一个具体的实例 这能够帮助你理解这个问题

00:00:56.861 --> 00:00:59.145
并将我们刚刚讲的内容 联系起来

00:00:59.145 --> 00:01:02.274
从 UI 上你可以看出 这个例子稍微有些旧了

00:01:02.274 --> 00:01:04.590
但我喜欢这段简洁的代码

00:01:04.590 --> 00:01:08.390
这个代码的目的是要在 ListView 中显示一个雇员列表

00:01:08.390 --> 00:01:11.429
而这将通过从 AsyncTaskLoader 内的 后台线程加载数据来完成

00:01:12.440 --> 00:01:14.650
如果你想要在以后访问 下面的链接

00:01:15.730 --> 00:01:18.030
下面让我们来看一下 EmployeeLoader 类

00:01:18.030 --> 00:01:21.770
如你所见 这个是 AsyncTaskLoader 类的扩展

00:01:21.770 --> 00:01:25.950
对于尖角号中的泛型参数 我们把它指定为一个雇员列表

00:01:25.950 --> 00:01:29.230
这意味着 doInBackground 方法的返回值

00:01:29.230 --> 00:01:30.970
就是雇员列表

00:01:30.970 --> 00:01:34.150
好的 在 loadInBackground 方法内

00:01:34.150 --> 00:01:36.880
我们能够看到一个 新创建的雇员数组列表

00:01:36.880 --> 00:01:40.670
我们在列表中添加三个项 然后我们返回这个列表

00:01:40.670 --> 00:01:41.400
从技术层面来说

00:01:41.400 --> 00:01:44.580
作业在此方法上完成的同时 也在主线程上完成了

00:01:44.580 --> 00:01:48.090
毕竟这不是一个复杂的 计算或者网络调用

00:01:48.090 --> 00:01:50.760
这篇代码的作者 仅仅是想要列举一个简单的例子

00:01:50.760 --> 00:01:52.220
来说明 AsyncTaskLoader 类

00:01:53.430 --> 00:01:57.210
我们也有创建 新 EmployeeLoader 实例的构造函数

00:01:57.210 --> 00:02:00.010
在这里面 我们只是调用 超类构造函数

00:02:00.010 --> 00:02:02.890
并且浏览全文

00:02:02.890 --> 00:02:06.150
可以看出 Loader 的执行 非常直接

00:02:06.150 --> 00:02:07.520
让我们回过头看一下

00:02:07.520 --> 00:02:11.009
Loader 在应用环境中 是如何使用的

00:02:11.009 --> 00:02:13.235
在 Activity 类声明中

00:02:13.235 --> 00:02:17.103
我们能够看见 FragmentActivity 的扩展 MainActivity

00:02:17.103 --> 00:02:20.700
然后执行一下 LoaderManager LoaderCallbacks 界面

00:02:20.700 --> 00:02:24.290
雇员列表是 指定的泛型类型

00:02:24.290 --> 00:02:26.138
向下滑动页面 如你所见

00:02:26.138 --> 00:02:30.494
Activity 必须实行三个 抽取回调方法

00:02:30.494 --> 00:02:34.410
onCreateLoader、onLoaderFinished 和 onLoaderReset

00:02:34.410 --> 00:02:38.309
那么让我们来注意一下 ListEmployee 数据类型被应用于整个回调

00:02:38.309 --> 00:02:39.000
方法

00:02:39.000 --> 00:02:40.620
甚至这里还有很多 尖角号

00:02:40.620 --> 00:02:43.520
仅将 ListEmployee 作为 一个独立的 BLOB 来使用

00:02:43.520 --> 00:02:47.029
相同的 BLOB 被插入到 整个回调方法说明的

00:02:47.029 --> 00:02:47.720
不同的点上

00:02:47.720 --> 00:02:51.440
例如 在 onCreateLoader 方法中返回一个 在雇员列表中用于加载数据的 Loader

00:02:51.440 --> 00:02:54.680
与我们上面所用的 BLOB 使用方法相同

00:02:55.840 --> 00:02:59.190
现在 我们在方法中创建了一个新的 EmployeeLoader

00:02:59.190 --> 00:03:04.010
其作为 loader ListEmployee 的扩展 与所需的返回值相匹配

00:03:04.010 --> 00:03:05.960
然后我们返回 Loader 实例

00:03:05.960 --> 00:03:10.080
在 onLoadFinished 方法中 我们得到两个输入参数

00:03:10.080 --> 00:03:12.100
"Loader" 和“结果”

00:03:12.100 --> 00:03:14.810
“结果”是指 ListEmployee 的数据类型

00:03:14.810 --> 00:03:17.610
而 "Loader" 加载 ListEmployee 数据

00:03:17.610 --> 00:03:20.740
现在我们真正关心的是 这个结果对象

00:03:20.740 --> 00:03:24.150
我们看一下雇员列表 并更新一下适配器中的数据集

00:03:24.150 --> 00:03:26.580
这将同时更新 与之相连的 ListView

00:03:26.580 --> 00:03:31.610
在 onLoadReset 方法中 我们得到一个输入参数 即 Loader 本身

00:03:31.610 --> 00:03:34.090
因为我们在 Activity 上 只有一个 Loader

00:03:34.090 --> 00:03:38.210
我们只能清除上次 Loader 给我们的数据

00:03:38.210 --> 00:03:41.620
所以我们把适配器数据集 设成一个空的雇员列表

00:03:41.620 --> 00:03:43.090
这是一个完整的场景

00:03:43.090 --> 00:03:45.765
在 Activity 内 不把 Loader 放在第一个位置上

00:03:45.765 --> 00:03:48.300
把 LoaderManager 和 itLoader 放在上面

00:03:49.340 --> 00:03:54.150
顺便说一下 getSupportLoaderManager 和 getLoaderManager 是一样的

00:03:54.150 --> 00:03:57.808
但是这个版本使用 LoaderManager 的 SupportLoader 版本

00:03:57.808 --> 00:04:01.300
在 initLoader 调用内 Manager 首先检查 Loader

00:04:01.300 --> 00:04:05.550
是否已经创建 以及现有副本是否回传

00:04:05.550 --> 00:04:07.470
如果 Loader 实例不存在的话

00:04:07.470 --> 00:04:10.850
onCreateLoader 回调将被触发 来创建新的实例

00:04:10.850 --> 00:04:13.410
然后我们就能够创建一个新的 EmployeeLoader 实例并返回

00:04:14.546 --> 00:04:17.870
这是一个完整的场景 在 Activity 内 不把 Loader 放在第一个位置上

00:04:17.870 --> 00:04:22.190
我们获得 LoaderManager 并调用其上的 itLoader

00:04:22.190 --> 00:04:26.360
顺便说一下 getSupportLoaderManager 和 getLoaderManager 是一样的

00:04:26.360 --> 00:04:29.235
但是这个版本使用 LoaderManager 的 SupportLoader 版本

00:04:30.580 --> 00:04:33.950
在 initLoader 调用内 Manager 首先检查

00:04:33.950 --> 00:04:37.960
Loader 是否已经创建 以及现有副本是否回传

00:04:38.990 --> 00:04:40.940
如果 Loader 实例不存在的话

00:04:40.940 --> 00:04:43.650
然后 onCreateLoader 回调将被触发 来创建新的实例

00:04:44.780 --> 00:04:47.640
然后我们就能够创建一个新的 EmployeeLoader 实例并返回

00:04:47.640 --> 00:04:52.070
你也许已经注意到了 在 Loader 初始化之后 代码调用 ForceLoad

00:04:52.070 --> 00:04:54.860
这需要触发 Loader 来进行后台作业

00:04:56.070 --> 00:04:58.570
这是一个非常好的练习 将 ForceLoad 调用放置在

00:04:58.570 --> 00:05:00.680
Loader 子类内

00:05:00.680 --> 00:05:03.607
你可以在 Loader 类内覆盖 onStartLoading 方法

00:05:03.607 --> 00:05:05.050
并从这里调用 ForceLoad

00:05:06.090 --> 00:05:10.170
onStartLoading 方法将在 initLoader 中自动触发

00:05:10.170 --> 00:05:12.900
那么 当我们调用 ForceLoad 时 Loader 将被启动

00:05:13.962 --> 00:05:17.260
loadInBackground 方法 会在后台线程上运行

00:05:17.260 --> 00:05:21.470
雇员列表将被创建并 作为 Loader 的结果返回

00:05:21.470 --> 00:05:25.090
现在只要 Loader 加载数据完毕 就会通知 LoaderManager

00:05:25.090 --> 00:05:27.758
将数据传回 onLoadFinished 方法

00:05:27.758 --> 00:05:31.890
当 onLoadFinished 方法和 雇员列表一起被调用时

00:05:31.890 --> 00:05:35.425
我们用新数据更新了适配器 这将导致列表被更新和

00:05:35.425 --> 00:05:36.400
重绘

00:05:36.400 --> 00:05:38.340
当 Activity 被关闭时

00:05:38.340 --> 00:05:41.140
LoaderManager 将 销毁 Loader

00:05:41.140 --> 00:05:44.150
并在 Loader 提供的数据 失效时

00:05:44.150 --> 00:05:45.780
进行通知

00:05:45.780 --> 00:05:49.660
在这种情况下 我们应将它 从 UI 中移除并停止使用

00:05:49.660 --> 00:05:52.130
如果在加载完成之前 Activity 被销毁

00:05:52.130 --> 00:05:54.220
那么这个方法就不会被调用

00:05:54.220 --> 00:05:56.070
如果我们在设备上运行这个代码

00:05:56.070 --> 00:05:57.920
这个应用就会像 屏幕截图中显示的一样

00:05:58.930 --> 00:06:01.450
我知道 这些 UI 看起来有点过时了

00:06:01.450 --> 00:06:04.220
但这主要是因为 Android Studio 中的 模拟器在这个教程创建之后

00:06:04.220 --> 00:06:06.520
进行了很多更新

00:06:06.520 --> 00:06:08.870
现在我们将 Loader 和 Loader Manager 回调作业

00:06:08.870 --> 00:06:11.010
连成了一个完整的知识链

00:06:11.010 --> 00:06:13.070
那么让我们讨论一下如何 在这个视频内执行 Loader

00:06:13.070 --> 00:06:16.740
我希望你能够试着 填写下列问题的空白处

00:06:16.740 --> 00:06:20.800
使用 AsyncTask 进行 后台作业的 Loader 类型是什么？

00:06:20.800 --> 00:06:24.240
为了创建一个 获取地震对象列表的自定义 Loader

00:06:24.240 --> 00:06:28.010
我们可从什么中定义一个 EarthquakeLoader 类？

00:06:28.010 --> 00:06:31.440
在 EarthquakeLoader 类内 我们需要覆盖何种方法？

00:06:31.440 --> 00:06:34.970
该方法会在后台线程上运行 并随后返回地震列表

00:06:34.970 --> 00:06:36.090
最后 作为提示

00:06:36.090 --> 00:06:39.260
你可以从测验下面的注释中 选择一个合适的答案

