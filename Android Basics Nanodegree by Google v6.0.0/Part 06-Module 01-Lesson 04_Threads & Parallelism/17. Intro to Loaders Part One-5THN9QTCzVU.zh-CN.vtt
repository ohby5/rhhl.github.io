WEBVTT
Kind: captions
Language: zh-CN

00:00:00.050 --> 00:00:03.820
AsyncTasks 适用于处理许多事情 但对于更新用户界面的数据来说

00:00:03.820 --> 00:00:08.230
却不是最佳选择 对此 我们需要使用 Loader

00:00:08.230 --> 00:00:11.000
Loader 解决了之前视频中 介绍的问题

00:00:11.000 --> 00:00:14.460
首先 无论你从 loader 上 请求多少次数据

00:00:14.460 --> 00:00:17.520
默认情况下 Loader 仅获取 一次数据

00:00:17.520 --> 00:00:20.820
因此不会生成大量的 AsyncTasks 和活动

00:00:20.820 --> 00:00:24.570
其次 当一个活动停止时 它会自动告知

00:00:24.570 --> 00:00:28.680
所有 Loader 退出正在进行的任务 因为数据不可用

00:00:28.680 --> 00:00:33.990
最后 Loader 会始终保留整个活动的 配置更改 如旋转

00:00:33.990 --> 00:00:37.790
当我们启用 Loader 获取数据时 电话旋转

00:00:37.790 --> 00:00:41.980
获取数据后 Loader 会自动将数据 返回至新的 Activity

00:00:41.980 --> 00:00:44.390
让我们看一下 Loaders 开发者指南

00:00:44.390 --> 00:00:47.380
Android 框架中的这些组件专门用于 加载显示、Activity 或框架

00:00:47.380 --> 00:00:50.950
的数据

00:00:50.950 --> 00:00:52.490
我在下面给出了一个链接

00:00:52.490 --> 00:00:54.750
你可以浏览该链接 阅读更多的详细信息

00:00:54.750 --> 00:00:56.910
我们从名为“启动 Loader” 的部分开始

00:00:58.550 --> 00:00:59.350
在 Activity 中

00:00:59.350 --> 00:01:02.830
你可以借助 LoaderManager 启动 Loader

00:01:02.830 --> 00:01:06.689
每个 intro activity 都配有一个 LoaderManager 

00:01:06.689 --> 00:01:10.683
可在适当的时间创建、重新使用和销毁 一组 loader 

00:01:10.683 --> 00:01:13.040
引用 LoaderManager  后

00:01:13.040 --> 00:01:15.780
可以调用 initLoader 方法

00:01:15.780 --> 00:01:18.931
第一个输入是特殊的 整数标识符

00:01:18.931 --> 00:01:20.275
在本例子中 我们使用 0

00:01:20.275 --> 00:01:24.115
你可以使用任意值 仅当应用中

00:01:24.115 --> 00:01:28.225
存在多个 Loader 时 需要使用不同的值对其加以区分

00:01:28.225 --> 00:01:32.205
其他两个参数是一体的 Loader 的其他输入包

00:01:32.205 --> 00:01:35.465
在本例子中为 null 且 loader 回调对象

00:01:35.465 --> 00:01:38.228
现在 我们为 LoaderCallbacks 对象 指定此参数

00:01:38.228 --> 00:01:41.755
因为它在当前活动中 最为常用

00:01:41.755 --> 00:01:44.137
我们可以使用它 执行 LoaderCallbacks 接口

00:01:44.137 --> 00:01:47.905
因此活动本身是我们要 传入的 LoaderCallback

00:01:47.905 --> 00:01:48.860
对象

00:01:48.860 --> 00:01:51.300
稍后 我们会详细讨论 LoaderCallbacks

00:01:51.300 --> 00:01:54.160
但是你要知道 调用 initLoader 时

00:01:54.160 --> 00:01:57.670
必须确保 loader 处于初始化和活跃状态

00:01:57.670 --> 00:02:02.110
如果 Loader 已具备给定 ID 而且该 ID 的 0 已经存在

00:02:02.110 --> 00:02:04.350
那么我们将使用上一个 Loader

00:02:04.350 --> 00:02:08.347
如果具备 ID 的 Loader 不存在 则将触发 LoaderCallback 

00:02:08.347 --> 00:02:10.900
onCreateLoader() 方法

00:02:10.900 --> 00:02:12.930
并返回一个新的 Loader

00:02:12.930 --> 00:02:17.283
重新使用现有 Loader 的 行为是完全

00:02:17.283 --> 00:02:18.050
有必要的

00:02:18.050 --> 00:02:21.726
当我们反复旋转设备时 将使用相同的 Loader

00:02:21.726 --> 00:02:26.720
而不是在每次变换方向时 都创建新的 Loader

00:02:26.720 --> 00:02:29.370
那么 如何创建 Loader 呢?

00:02:29.370 --> 00:02:33.160
作为开发人员 我们感到很荣幸 可以通过执行

00:02:33.160 --> 00:02:35.830
LoaderCallback 接口 定义该行为

00:02:35.830 --> 00:02:39.420
要与 LoaderManager 进行交互

00:02:39.420 --> 00:02:41.798
活动需要覆盖 以下三种回调方法

00:02:41.798 --> 00:02:44.950
调用 onCreateLoader() 方法时 需要创建和返回新的 Loader 对象

00:02:44.950 --> 00:02:48.790
该对象将从 Web 服务器 获取地震数据

00:02:48.790 --> 00:02:52.350
当 Loader 在后台线程完成数据加载后 将调用 onLoadFinished()

00:02:52.350 --> 00:02:53.680
方法

00:02:53.680 --> 00:02:56.980
后台线程是一个更新 地震列表 UI 的好地方

00:02:56.980 --> 00:03:00.320
在对之前创建的 loader 进行重置时 将调用 onLoaderReset()

00:03:00.320 --> 00:03:01.970
方法

00:03:01.970 --> 00:03:04.590
本例子中 上次加载的数据 现在已经失效

00:03:04.590 --> 00:03:06.110
不应该再次使用

00:03:06.110 --> 00:03:06.821
例如

00:03:06.821 --> 00:03:10.327
如果从其他的 URL 中获取数据 可能需要重置 loader

00:03:10.327 --> 00:03:14.940
在这种情况下 现有的 地震数据无效

00:03:14.940 --> 00:03:18.610
使用该方法时 我们要特别清除 上次加载的数据

00:03:18.610 --> 00:03:21.190
也就是说需要从列表中 清除地震

00:03:21.190 --> 00:03:24.750
这只是一个很小的提示 当你查看这些类似回调的方法时

00:03:24.750 --> 00:03:27.400
这只是一个迹象  表明出现了异步行为

00:03:27.400 --> 00:03:31.000
请记住 异步表示 数据未完全从 Loader 加载之前

00:03:31.000 --> 00:03:34.310
系统就开始进行 其他工作

00:03:34.310 --> 00:03:38.200
现在 仅当系统通过 onCreateLoader()

00:03:38.200 --> 00:03:42.390
方法回调时 创建 Loader

00:03:42.390 --> 00:03:45.580
仅当系统使用 Loader 结果 调用 onLoadFinished() 时

00:03:45.580 --> 00:03:47.570
创建 UI

00:03:47.570 --> 00:03:49.160
调用所需的时间并不固定

00:03:49.160 --> 00:03:52.230
有的时间很长 有的时间很短

00:03:52.230 --> 00:03:55.840
在下个视频中 我们将从根本上了解 代码的详细信息

00:03:55.840 --> 00:03:57.920
以及如何实际 创建 Loader

00:03:57.920 --> 00:04:00.560
在此之前 我只想确定 你是否已经了解

00:04:00.560 --> 00:04:02.170
Loader 的高级优势

00:04:02.170 --> 00:04:04.930
Google 开发人员倡导者 Ian Lake 在其发表的博客中谈到

00:04:04.930 --> 00:04:08.060
最好的实践就是将加载数据 实施到应用中

00:04:08.060 --> 00:04:11.540
在这一部分中 他强调了 Loader 的特别之处

00:04:11.540 --> 00:04:14.873
旋转设备时 即使活动是重新创建的

00:04:14.873 --> 00:04:18.644
Loader 也会继续运行 且获取的数据不会丢失

00:04:18.644 --> 00:04:21.339
这样一来 你无需拨打昂贵的 网络电话

00:04:21.339 --> 00:04:24.630
更妙的是 Loader 不会一直保留

00:04:24.630 --> 00:04:28.570
如果活动销毁 则 Loader 也将自动清除

00:04:28.570 --> 00:04:30.410
实际上 Loader 的生命与 活动的生命周期紧密相联

00:04:30.410 --> 00:04:34.740
且 Loader 更适合用于 获取需要在屏幕上

00:04:34.740 --> 00:04:39.810
显示的数据 即使活动不存在

00:04:39.810 --> 00:04:43.506
只要活动存在 Loader 就存在

00:04:43.506 --> 00:04:45.274
所以 这样的 Loader 正是我们所需要的

00:04:45.274 --> 00:04:49.010
好吧 这就像一个 信息的消防水带

00:04:49.010 --> 00:04:51.510
我知道 你很难一下子记住 全部的内容

00:04:51.510 --> 00:04:54.900
所以在本次测验中 我总结了几个关键点 但同时留出几处空白

00:04:54.900 --> 00:04:56.040
需要你来填写

00:04:56.040 --> 00:04:57.849
来吧 帮我把空白处填写完整吧

00:04:59.210 --> 00:05:02.790
要管理一个或多个 Loader 实例 哪些内容需要与活动进行交互?

00:05:04.970 --> 00:05:08.780
为了让活动成为与 LoaderManager 交互的客户端

00:05:08.780 --> 00:05:12.080
我们需要 EarthquakeActivity 来执行空白接口

00:05:13.650 --> 00:05:17.678
活动必须覆盖空白方法 以便于创建和返回

00:05:17.678 --> 00:05:19.695
新的 Loader 实例

00:05:19.695 --> 00:05:23.320
在 Loader 完成加载后 使用空白方法来接收数据

00:05:24.590 --> 00:05:28.420
还有 当不再使用之前创建的 Loader 时 可以使用空白方法

00:05:28.420 --> 00:05:31.890
进行处理 除非 现有数据可以丢弃

00:05:33.100 --> 00:05:35.310
最后一题 当使用

00:05:35.310 --> 00:05:38.550
EarthquakeActivity onCreate() 方法 启动应用时

00:05:38.550 --> 00:05:41.810
我们应该调用哪些内容以启动 Loader 并触发 Loader 回调?

00:05:44.310 --> 00:05:47.090
如果需要提示 我已经在测验下方 给出了可能的答案选项

00:05:47.090 --> 00:05:49.690
你可以从中选取正确的选项

00:05:49.690 --> 00:05:52.270
可以随意引用文档链接 和 Loader 的

00:05:52.270 --> 00:05:53.690
开发指南

