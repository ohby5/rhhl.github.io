WEBVTT
Kind: captions
Language: zh-CN

00:00:00.290 --> 00:00:01.280
哇
— 击个掌

00:00:01.280 --> 00:00:03.610
我们的学生正在展示
真正的开发者才能

00:00:03.610 --> 00:00:04.820
— 是的 我很高兴

00:00:04.820 --> 00:00:06.720
虽然不想扫兴 但是 Joe

00:00:06.720 --> 00:00:09.840
你告诉过学生关于
AsyncTask 的理解吗？

00:00:09.840 --> 00:00:11.660
— 没有 为什么我们不庆贺一番？

00:00:11.660 --> 00:00:13.940
— 我们真的需要告诉他们

00:00:13.940 --> 00:00:15.490
— 好吧 你来告诉他们

00:00:15.490 --> 00:00:19.450
— 好 让我们想一想
当打开应用并

00:00:19.450 --> 00:00:21.030
启动地震活动时会发生什么

00:00:21.030 --> 00:00:23.092
这时
内存中有一个活动对象

00:00:23.092 --> 00:00:27.950
然后 我们在 onCreate 方法中
实例化新的 AsyncTask 对象

00:00:27.950 --> 00:00:30.095
该对象之后会在
后台线程中开始运行

00:00:30.095 --> 00:00:32.229
并打开 HTTP 连接

00:00:32.229 --> 00:00:35.440
现在重点来了
在 AsyncTask 完成前

00:00:35.440 --> 00:00:38.100
如果我旋转手机会发生什么？

00:00:38.100 --> 00:00:41.770
为了在新的方向上
正确显示我们的 UI

00:00:41.770 --> 00:00:45.720
系统需要创建新的活动
并重新布局我们的视图

00:00:45.720 --> 00:00:49.200
由于移动设备的内存有限
这意味着系统可能

00:00:49.200 --> 00:00:53.490
需要销毁旧的活动
并回收所占用的内存

00:00:53.490 --> 00:00:57.770
但由于 AsyncTask 是
原始活动的内部类

00:00:57.770 --> 00:01:01.920
所以在 AsyncTask 停止
执行前 无法回收其内存

00:01:01.920 --> 00:01:02.730
让我来解释一下这是什么意思

00:01:03.750 --> 00:01:06.727
请注意 每次旋转手机时

00:01:06.727 --> 00:01:09.887
都会从头创建
一个新的活动

00:01:09.887 --> 00:01:13.020
并通过代码
创建新的 AsyncTask 实例

00:01:13.020 --> 00:01:17.340
AsyncTask 将启动另一个后台
线程并打开另一个 HTTP 连接

00:01:17.340 --> 00:01:21.708
但由于实际上已经存在 AsyncTask
这是非常浪费的

00:01:21.708 --> 00:01:25.600
最后会在内存中同时
保留两个活动

00:01:25.600 --> 00:01:27.340
这是之前的两倍

00:01:27.340 --> 00:01:30.520
所以 当第一个 AsyncTask
最终完成时会发生什么？

00:01:30.520 --> 00:01:33.190
由于屏幕中
不再显示视图

00:01:33.190 --> 00:01:35.590
所以任务结果
将不可用

00:01:35.590 --> 00:01:37.750
这是一种对设备
资源的浪费

00:01:37.750 --> 00:01:41.170
获取并解析不再可见
的服务器响应 对吗？

00:01:41.170 --> 00:01:43.490
但如果多次
旋转手机呢？

00:01:43.490 --> 00:01:45.940
我们将得到大量的
多余 AsyncTask

00:01:45.940 --> 00:01:49.610
内存中的活动立即
尝试运行并连接到网络

00:01:49.610 --> 00:01:53.500
因此 我们使用了所有
不必要的额外内存

00:01:53.500 --> 00:01:55.580
这可能拖慢我们的手机

00:01:55.580 --> 00:01:59.160
我们实际上只需要
屏幕上目前显示的

00:01:59.160 --> 00:02:01.050
一个活动和
一个 AsyncTask

00:02:01.050 --> 00:02:03.020
另外 如果认真想一想

00:02:03.020 --> 00:02:05.490
所有这些新任务很可能
都收到相同的结果

00:02:05.490 --> 00:02:08.000
因为在我们旋转
手机的几秒内

00:02:08.000 --> 00:02:09.858
地震数据可能
不会有太多变化

00:02:09.858 --> 00:02:14.090
所以实际上 我们每次
创建新的任务来支持

00:02:14.090 --> 00:02:17.580
方向改变不如使用
第一个 HTTP 请求中

00:02:17.580 --> 00:02:19.695
的原始结果有效

00:02:19.695 --> 00:02:21.680
当然 前提是
可以成功完成

00:02:21.680 --> 00:02:25.190
然而 我们向同一服务器
发出了多个网络请求

00:02:25.190 --> 00:02:27.240
这些请求都获取
并解析同一响应

00:02:27.240 --> 00:02:29.500
这太浪费了

00:02:29.500 --> 00:02:31.000
— 很好 Chris 你现在
吓到了学生们

00:02:31.000 --> 00:02:32.310
其实还有一种更好的方法

00:02:33.350 --> 00:02:35.380
— 的确

00:02:35.380 --> 00:02:39.560
— 观看下面链接的
Android 运行模式视频

00:02:39.560 --> 00:02:41.000
并回答测验问题

00:02:41.000 --> 00:02:44.190
Android 中的哪部分可以
帮助我们解决这个问题？

