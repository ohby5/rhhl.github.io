WEBVTT
Kind: captions
Language: ar

00:00:01.501 --> 00:00:04.634
‫-طلابنا أظهروا مهارات مطورين حقيقية
‫- أجل، مثير للغاية

00:00:04.801 --> 00:00:07.168
‫مهلاً (جو)، لا أريد أن أكون
‫مفسد الحفلات، ولكن..

00:00:07.234 --> 00:00:09.434
‫ألم تخبر الطلب بمربط الفرس في AsyncTask؟

00:00:09.534 --> 00:00:11.502
‫لا، لم لا نحتفل وحسب؟

00:00:11.634 --> 00:00:13.235
‫نحتاج لإخبارهم يا صاح!

00:00:13.801 --> 00:00:15.968
‫- حسناً، أخبرهم أنت
‫- حسناً

00:00:16.734 --> 00:00:20.602
‫لنفكر فيما يحدث عند فتح التطبيق
‫وإطلاق نشاط earthquake

00:00:21.000 --> 00:00:23.501
‫عند هذه النقطة،
‫لدينا كائن نشاط في الذاكرة

00:00:23.667 --> 00:00:27.800
‫ثم في وظيفة onCreate
‫ننشئ كائن AsyncTask

00:00:27.934 --> 00:00:31.735
‫والذي يبدأ التشغيل في خيط
‫خلفية ويفتح اتصال HTTP

00:00:32.200 --> 00:00:33.267
‫وإليك مربط الفرس

00:00:33.534 --> 00:00:35.135
‫قبل أن تنتهي AsyncTask..

00:00:35.434 --> 00:00:37.501
‫ماذا يحدث لو دورت هاتفي؟

00:00:38.100 --> 00:00:41.567
‫لنعرض الواجهة جيداً في التوجه الجديد..

00:00:41.767 --> 00:00:45.034
‫يحتاج النظام لإنشاء نشاط جديد
‫ويعيد تخطيط واجهاتنا

00:00:45.667 --> 00:00:47.800
‫ولأن الذاكرة محدودة على الجهاز..

00:00:47.934 --> 00:00:52.601
‫فهذا يعني أن النظام قد يلغي النشاط
‫القديم ويستعيد الذاكرة التي احتلها

00:00:53.501 --> 00:00:57.402
‫ولكن لأن AsyncTask فئة داخلية
‫من النشاط الأصلي..

00:00:57.767 --> 00:01:01.568
‫فلا يمكن استعادة تلك الذاكرة
‫حتى ينتهي تنفيذ AsyncTask

00:01:01.901 --> 00:01:03.101
‫دعني أوضح ما أعنيه

00:01:03.701 --> 00:01:06.001
‫لاحظ أنه في كل مرة يتم تدوير الهاتف..

00:01:06.100 --> 00:01:08.167
‫يتم إنشاء نشاط جديد تماماً

00:01:09.334 --> 00:01:12.568
‫ومن خلال الكود الخاص بنا،
‫يتم إنشاء نسخة جديدة من AsyncTask

00:01:13.000 --> 00:01:14.567
‫والتي تبدأ خيط خلفية جديد

00:01:14.601 --> 00:01:17.435
‫وتبدأ اتصال HTTP آخر

00:01:17.601 --> 00:01:21.435
‫هذا تبذير لأنه يوجد الآن
‫اثنان من AsyncTask

00:01:22.200 --> 00:01:25.400
‫ونشاطين حاويين محملان
‫على الذاكرة في الوقت نفسه

00:01:25.601 --> 00:01:27.135
‫وضعف ما كان عليه سابقاً

00:01:27.334 --> 00:01:30.068
‫فماذا يحدث عندما تنتهي
‫AsyncTask الأولى؟

00:01:30.501 --> 00:01:33.002
‫نتيجة المهمة لم تعد قابلة للاستخدام

00:01:33.200 --> 00:01:35.434
‫لأن الواجهات لم تعد معروضة على الشاشة

00:01:35.634 --> 00:01:37.568
‫وهذا نوع من إهدار موارد النظام

00:01:37.734 --> 00:01:40.468
‫جلب وتفسير استجابة لن تُرى أبداً، صحيح؟

00:01:41.167 --> 00:01:43.167
‫ماذا لو دورنا الجهاز عدة مرات؟

00:01:43.434 --> 00:01:46.935
‫سيصبح لدينا طناً من AsyncTasks
‫والأنشطة في الذاكرة

00:01:47.100 --> 00:01:49.500
‫جميعهم يعمل ويحاول الاتصال
‫بالشبكة في آنٍ واحد

00:01:49.567 --> 00:01:50.567
‫والنتيجة..

00:01:50.634 --> 00:01:53.268
‫نستخدم كل هذه الذاكرة بلا داعٍ

00:01:53.501 --> 00:01:55.268
‫وربما نبطئ هاتفنا

00:01:55.567 --> 00:01:57.567
‫بينما لا نحتاج إلا لنشاط واحد

00:01:57.701 --> 00:02:00.935
‫ومهمة AsyncTask واحدة
‫لما يتم عرضه حالياً على الشاشة

00:02:01.033 --> 00:02:02.700
‫وأضف، إن تدبرها حقاً..

00:02:02.968 --> 00:02:05.435
‫كل هذه المهام الجديدة
‫ستتلقى النتيجة نفسها

00:02:05.467 --> 00:02:10.134
‫لأنه على الأرجح لن تتغير البيانات خلال
‫الثواني القليلة التي ندير الجهاز فيها

00:02:10.434 --> 00:02:14.501
‫مثالياً، وعندما ننشئ نشاطاً
‫يدعم تدوير التوجه..

00:02:14.868 --> 00:02:19.402
‫سيكون من الأفضل إذا استخدمنا
‫النتيجة الأصلية من طلب HTTP الأول

00:02:19.675 --> 00:02:21.475
‫بفرض أنه اكتمل بنجاح بالطبع

00:02:21.647 --> 00:02:24.975
‫بدلاً من هذا لدينا عدة طلبات شبكة
‫في طريقها إلى الملقم نفسه

00:02:25.133 --> 00:02:27.101
‫جميعهم يجلب ويفسر نفس الاستجابة

00:02:27.217 --> 00:02:28.949
‫مبذر جداً، ياللأسى

00:02:29.434 --> 00:02:32.460
‫رويدك (كريس) أنت تخيفهم،
‫لابد من وجود طريقة أفضل

00:02:33.262 --> 00:02:34.763
‫في الواقع، توجد طريقة

00:02:35.377 --> 00:02:37.712
‫شاهد فيديو (نمط أداء آندرويد)

00:02:37.887 --> 00:02:39.187
‫والذي وضعناه رابطه أدناه

00:02:39.259 --> 00:02:40.893
‫ثم أجب سؤال الاختبار هذا

00:02:40.934 --> 00:02:44.468
‫أي مكون في آندرويد يساعدنا
‫في حل هذه المشكلة؟

