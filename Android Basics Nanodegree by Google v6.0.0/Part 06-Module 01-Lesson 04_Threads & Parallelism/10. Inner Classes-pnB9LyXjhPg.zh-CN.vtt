WEBVTT
Kind: captions
Language: zh-CN

00:00:00.170 --> 00:00:03.890
到目前为止 我们已看过孤立
浮动的代码段

00:00:03.890 --> 00:00:08.460
在本视频中 我们来看一看
代码如何融入 Android 地图

00:00:08.460 --> 00:00:11.680
既然 EarthquakeAsyncTask
是自有类

00:00:11.680 --> 00:00:13.460
那么 为什么不使用单独的 Java 文件呢？

00:00:14.460 --> 00:00:17.850
我们在执行网络请求来获取
地震数据并

00:00:17.850 --> 00:00:23.350
获得返回结果与
onPostExecute 后 想要更新 UI

00:00:23.350 --> 00:00:27.500
但如何能够引用屏幕中的
视图来进行更新呢？

00:00:27.500 --> 00:00:31.100
这些视图属于我们在 MainActivity
中设置的布局

00:00:31.100 --> 00:00:33.890
在 Java 中 这就表示
事实上我们可以声明

00:00:33.890 --> 00:00:37.670
EarthquakeAsyncTask 为
内部类

00:00:37.670 --> 00:00:40.510
这意味着 整个
AsyncTask 类定义

00:00:40.510 --> 00:00:43.520
囊括在 MainActivity
类定义内

00:00:43.520 --> 00:00:46.170
一个诸如 EarthquakeAsyncTask 内部类

00:00:46.170 --> 00:00:49.970
保持隐式引用
外部 MainActivity 类

00:00:49.970 --> 00:00:53.400
而一个 EarthquakeAsyncTask
类的实例

00:00:53.400 --> 00:00:56.950
只能存在于
MainActivity 实例内部

00:00:56.950 --> 00:00:58.070
换言之

00:00:58.070 --> 00:01:03.570
如果没有封闭的 MainActivity
就不会有 EarthquakeAsyncTask

00:01:03.570 --> 00:01:06.740
这样就会产生一些相关的
物理内存风险

00:01:06.740 --> 00:01:08.730
这一点 我们在本课后续部分就会发现

00:01:08.730 --> 00:01:13.640
但到目前为止 作为内部类而言
EarthquakeAsyncTask 实例可以

00:01:13.640 --> 00:01:18.530
访问封闭 MainActivity 实例内的任何
全局变量与方法

00:01:18.530 --> 00:01:22.980
例如 在 MainActivity 中
如果我们针对

00:01:22.980 --> 00:01:26.830
显示地震强度的 TextView 声明一个
全局变量 我们可以在

00:01:26.830 --> 00:01:32.640
AsyncTask 中引用 TextView
onPostExecute 方法便会更新文本

00:01:32.640 --> 00:01:36.530
你选择将某个对象声明为另一个类的内部类
可能还有一个原因

00:01:36.530 --> 00:01:40.800
即精简你的代码
从而产生较少的 Java 文件

00:01:40.800 --> 00:01:44.390
这在两类密切相关时
特别有用

00:01:44.390 --> 00:01:50.110
例如 EarthquakeAsyncTask
仅在 MainActivity 内使用过

00:01:50.110 --> 00:01:56.150
这样 我们便可将 EarthquakeAsyncTask
设为私有类 而不是公共类

00:01:56.150 --> 00:01:59.760
现在 请 Chris 带你一览
真实代码的示例

00:01:59.760 --> 00:02:02.260
而不是黑色横线

00:02:02.260 --> 00:02:03.480
— 下面我将通过示例
为你演示

00:02:03.480 --> 00:02:06.660
希望你能看到我们在
前几个视频中探讨的

00:02:06.660 --> 00:02:08.530
所有概念如何彼此融合

00:02:08.530 --> 00:02:11.070
这是 Network Connect 应用
项目中的代码

00:02:11.070 --> 00:02:14.490
该应用是 Android Studio 提供的
示例应用之一

00:02:14.490 --> 00:02:17.820
为了快点找到此应用 我们转至
文件 (File) 菜单 选择新建 (New)

00:02:17.820 --> 00:02:20.010
然后选择导入示例 (Import Sample)

00:02:21.770 --> 00:02:25.450
在此处你将看到一个 UI
可浏览 Android Studio 提供的所有示例代码

00:02:25.450 --> 00:02:29.790
如你所见 其中含有一组
按主题分开的子菜单

00:02:29.790 --> 00:02:33.980
如 Android TV 有关执行
后台工作的代码示例

00:02:33.980 --> 00:02:38.430
但在这里 我要继续操作
使用搜索栏来查找 Network

00:02:40.070 --> 00:02:43.530
很好 在连接 (Connectivity)
菜单下 第二个项目

00:02:43.530 --> 00:02:47.130
即为 Network Connect 应用 也就是
我们当前所探讨的应用

00:02:47.130 --> 00:02:50.780
Network Connect 应用用于
提取 Google.com 网站中原始

00:02:50.780 --> 00:02:53.270
HTML 的前 500 个字符

00:02:53.270 --> 00:02:56.400
当我们单击提取 (Fetch) 菜单按钮时
该应用会继续在

00:02:56.400 --> 00:02:59.210
后台线程发出
网络请求

00:02:59.210 --> 00:03:01.980
随后我们便可在屏幕
底部的文本视图中

00:03:01.980 --> 00:03:03.910
看到原始 HTML 响应

00:03:03.910 --> 00:03:06.940
让我们进一步看看 场景的背后
代码是如何编写的

00:03:06.940 --> 00:03:10.990
在这里 我们可以看到 DownloadTask
为 AsyncTask 的子类

00:03:10.990 --> 00:03:14.780
它调用 loadFromNetwork 方法
来执行网络请求并

00:03:14.780 --> 00:03:17.620
将产生的输入字符串
可以是数据的任意字符串

00:03:17.620 --> 00:03:20.410
转换为所返回的
字符串响应

00:03:21.670 --> 00:03:22.630
此时 你还会看到

00:03:22.630 --> 00:03:27.270
download 类事实上被声明
为 MainActivity 的内部类

00:03:28.380 --> 00:03:33.000
这意味着 整个 download 类
定义实际上位于

00:03:33.000 --> 00:03:37.070
更广泛的 MainActivity 类定义
的左括号和右括号之间

00:03:37.070 --> 00:03:39.180
我们稍后便可
了解到其中含义

00:03:39.180 --> 00:03:42.200
当此应用启动时
便会创建 MainActivity 同时

00:03:42.200 --> 00:03:44.150
我们也可以在这里看到已设置布局

00:03:44.150 --> 00:03:47.090
按下选项菜单中的
提取 (Fetch) 按钮后

00:03:47.090 --> 00:03:51.910
便会创建一个新的 DownloadTask
随后在该任务上调用 execute 方法

00:03:51.910 --> 00:03:56.650
传入 Google.com 网站
作为 URL 参数

00:03:56.650 --> 00:03:59.180
现在 我们来进一步
检查 DownloadTask

00:03:59.180 --> 00:04:01.910
如前面所述
我们为 AsyncTask 定义子类

00:04:01.910 --> 00:04:04.150
随后指定三个泛型参数

00:04:04.150 --> 00:04:07.700
首先 我们为第一个参数 也就是作为后台
方法输入的参数指定 String 数据类型

00:04:07.700 --> 00:04:11.510
接着 我们对进度
参数使用 Void 因为

00:04:11.510 --> 00:04:15.320
在这种情况下 我们并不会真正
报告 UI 的增量进度更新

00:04:15.320 --> 00:04:18.452
这样产生的主要结果就是 此处不会
执行任何实际 onProgressUpdate

00:04:18.452 --> 00:04:20.089
回调

00:04:20.089 --> 00:04:23.570
最后 我们对 doInBackground
方法的结果使用 String 数据类型

00:04:23.570 --> 00:04:28.290
该方法同时会传入为
onPostExecute 方法的输入

00:04:28.290 --> 00:04:31.200
现在 让我们进一步看看
我们在第一次执行此任务时

00:04:31.200 --> 00:04:35.290
调用的 doInBackground 方法
我们预计得到大量存储在数组中的

00:04:35.290 --> 00:04:39.280
字符串输入参数
即 URL

00:04:39.280 --> 00:04:40.900
然后 在调用 loadFromNetwork 时

00:04:40.900 --> 00:04:45.720
我们实际上是使用 0 索引来
提取 URL 数组中的第一个元素

00:04:45.720 --> 00:04:47.390
随后从网络加载数据

00:04:47.390 --> 00:04:50.550
请再次注意 loadFromNetwork
定义实际上位于

00:04:50.550 --> 00:04:53.794
DownloadTask 的左括号
和右括号之外

00:04:53.794 --> 00:04:56.920
通常情况下 此时
我们不能调用其他类中的

00:04:56.920 --> 00:04:59.420
私有方法或变量 但是

00:04:59.420 --> 00:05:03.270
由于 DownloadTask 实际上是一个
内部类 因此可以接受这种操作

00:05:03.270 --> 00:05:05.946
现在 当后台工作
完成后 字符串响应

00:05:05.946 --> 00:05:09.270
实际上会返回为 doInBackground
方法的结果

00:05:09.270 --> 00:05:13.160
执行完该方法后 系统
会调用 onPostExecute 方法

00:05:13.160 --> 00:05:16.490
传入 String 结果
接着 我们来记录消息

00:05:16.490 --> 00:05:19.500
在本示例中其实有一种特殊行为
来使日志片段生效

00:05:19.500 --> 00:05:22.930
即在屏幕上显示
系统日志消息

00:05:22.930 --> 00:05:26.100
因此 当你调用 log.i 或
log.v 来记录消息时

00:05:26.100 --> 00:05:29.450
也会在该应用中屏幕
的底部显示输出

00:05:29.450 --> 00:05:31.459
无需在你的应用
中使用日志片段

00:05:31.459 --> 00:05:33.470
但对于示例而言 这是一个很有用的类

00:05:33.470 --> 00:05:37.880
无论怎样 重点始终在
AsyncTask onPostExecute 方法中

00:05:37.880 --> 00:05:40.981
我们从后台线程获得
响应 然后更新 UI

00:05:40.981 --> 00:05:44.375
至此 你已见证如何将 AsyncTask
声明为 Activity 的内部类

00:05:44.375 --> 00:05:47.315
接下来 你便可通过
在 Digifield 应用中

00:05:47.315 --> 00:05:50.280
编写 AsyncTask 的子类
执行同样的操作

