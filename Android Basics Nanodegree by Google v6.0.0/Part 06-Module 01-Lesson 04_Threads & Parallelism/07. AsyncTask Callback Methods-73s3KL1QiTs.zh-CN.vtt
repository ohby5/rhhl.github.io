WEBVTT
Kind: captions
Language: zh-CN

00:00:00.387 --> 00:00:04.870
AsyncTask 不用于 我们之前使用的所有其他类

00:00:04.870 --> 00:00:06.120
所有其他类

00:00:06.120 --> 00:00:09.443
比如 Activity 或 View, 在主线程中执行工作

00:00:09.443 --> 00:00:11.663
是的 但是 AsyncTask 类的某些部分

00:00:11.663 --> 00:00:15.886
在前台主线程的位置 运行

00:00:15.886 --> 00:00:19.868
那么显然 该任务的其他部分 在后台单独的

00:00:19.868 --> 00:00:22.682
线程上运行

00:00:22.682 --> 00:00:26.510
- 是的 AsyncTask 处理多个线程

00:00:26.510 --> 00:00:29.610
所以 让我们 逐个浏览

00:00:29.610 --> 00:00:32.740
AsyncTask 是一个抽象类

00:00:32.740 --> 00:00:37.385
上节课与 Jessica 学习构建 Miwok 语言应用时

00:00:37.385 --> 00:00:40.495
你已经对抽象类 有了一定的了解

00:00:40.495 --> 00:00:43.595
抽象类包含一些 留空的方法

00:00:43.595 --> 00:00:49.425
使开发商可以覆盖和 提供自己的程序

00:00:49.425 --> 00:00:54.050
要使用 AsyncTask 我们需要创建一个自定义的子类

00:00:54.050 --> 00:00:56.470
我们将其称之为 EarthquakeAsyncTask

00:00:58.110 --> 00:01:01.995
该子类需要覆盖 方法 doInBackground()

00:01:03.340 --> 00:01:06.970
从早期的演示中我们得知 无论在后台线程中进行何种工作

00:01:06.970 --> 00:01:11.780
该工作都包括在 doInBackground() 方法中

00:01:13.120 --> 00:01:15.780
从服务器上获取 地震数据后

00:01:15.780 --> 00:01:17.330
你可能要对 UI 进行更新

00:01:17.330 --> 00:01:23.360
但是必须在主线程更新 UI 而不是后台线程

00:01:25.130 --> 00:01:29.320
所以要使用何种方法在 主线程和后台线程之间进行通信呢?

00:01:29.320 --> 00:01:34.020
你可以覆盖 AsyncTask 中 名为 onPostExecute() 的方法

00:01:34.020 --> 00:01:38.320
该方法在主线程上运行 这就是我用绿色对其突出显示的原因

00:01:38.320 --> 00:01:41.790
将在后台工作完成后 调用此方法

00:01:41.790 --> 00:01:43.996
这就是它称为 onPostExecute() 的原因

00:01:45.550 --> 00:01:47.990
我们可以查看 doInBackground() 返回的结果

00:01:47.990 --> 00:01:51.460
来了解更多有关 方法的详细信息

00:01:52.790 --> 00:01:58.263
该结果会传入为 onPostExecute 方法的输入

00:01:58.263 --> 00:02:02.526
如果 doInBackground() 结果 为来自服务器的地震列表

00:02:02.526 --> 00:02:07.187
那么在 onPostExecute() 中的 数据列表现在已经迁移回主线程

00:02:07.187 --> 00:02:10.651
我们可以在主线程上的 更新应用中 ListView

00:02:10.651 --> 00:02:11.930
来显示新的数据

00:02:13.140 --> 00:02:18.540
如果需要的话 还有一种名为 OnPreExecut() 的 AsyncTask 方法

00:02:18.540 --> 00:02:22.420
因为后台工作开始前 该方法就被调用到主线程上

00:02:22.420 --> 00:02:24.440
因此称为 onPreExecute()

00:02:24.440 --> 00:02:28.930
在准备运行后台工作之前 开发商可以覆盖此方法

00:02:28.930 --> 00:02:30.930
来完成某些 有待完成的工作

00:02:32.590 --> 00:02:35.540
有时候后台工作可能会 需要很长时间

00:02:36.920 --> 00:02:40.320
一些开发商可能想要对 后台任务中的用户进度

00:02:40.320 --> 00:02:41.010
进行更新

00:02:42.280 --> 00:02:45.000
例如 应用从网上下载 图片时

00:02:45.000 --> 00:02:47.070
会显示图片下载的 进度条

00:02:48.446 --> 00:02:52.786
在 doInBackground() 方法中 我们可以定期调用

00:02:52.786 --> 00:02:56.978
publishProgress 方法 并传入新的进度值

00:02:56.978 --> 00:03:01.252
我们可以覆盖 主线程上的 onProgressUpdate 方法

00:03:01.252 --> 00:03:06.301
并用新的进度值 来更新 UI

00:03:06.301 --> 00:03:08.850
在本例中进度值为 72%

00:03:08.850 --> 00:03:12.700
让我们一起来看一下 AsyncTask 类文档

00:03:12.700 --> 00:03:15.219
向下滚动至 方法部分

00:03:15.219 --> 00:03:19.319
然后你会看到 doInBackground 在抽象方法中列出

00:03:19.319 --> 00:03:22.480
所以我们需要 执行此方法

00:03:22.480 --> 00:03:26.124
我们也了解其他方法 例如 onPreExecute()、

00:03:26.124 --> 00:03:28.662
onProgressUpdate 和 onPostExecute

00:03:28.662 --> 00:03:31.934
这些方法都不是抽象的 所以不需要我们

00:03:31.934 --> 00:03:33.745
来执行

00:03:34.905 --> 00:03:38.411
向上滚动 我们可以发现 AsyncTask 的子类

00:03:38.411 --> 00:03:42.815
名为 DownloadFilesTask 类的 代码示例

00:03:42.815 --> 00:03:46.060
我们会在后面的课程中 对该示例做出更详细的介绍

00:03:46.060 --> 00:03:49.700
但是主要的 gist  在 doInBackground() 方法中

00:03:49.700 --> 00:03:54.680
下载文件时 可能需要很长的时间 所以应该在后台线程中下载文件

00:03:54.680 --> 00:03:57.910
请注意 doInBackground() 方法中的 输入可以是待处理的项目列表

00:03:57.910 --> 00:04:02.350
在本例中 输入为 待下载的文件列表

00:04:02.350 --> 00:04:04.940
下载的进度会逐渐增加

00:04:04.940 --> 00:04:08.590
我们可以使用当前的百分比进度 来更新屏幕

00:04:08.590 --> 00:04:12.420
后台工作结束后 会显示一个对话框

00:04:12.420 --> 00:04:15.110
该对话框显示 已成功下载的字节数

00:04:16.279 --> 00:04:20.483
在本次测验中 你需要在表格中填写

00:04:20.483 --> 00:04:22.528
在 AsyncTask 中最常用的调用方法

00:04:22.528 --> 00:04:27.240
用自己的话来描述 每种调用方法

00:04:27.240 --> 00:04:31.640
然后指出该方法是在主线程上运行 还是在后台线程上运行

00:04:31.640 --> 00:04:34.120
如果有需要 可以查阅 测验下方的链接

