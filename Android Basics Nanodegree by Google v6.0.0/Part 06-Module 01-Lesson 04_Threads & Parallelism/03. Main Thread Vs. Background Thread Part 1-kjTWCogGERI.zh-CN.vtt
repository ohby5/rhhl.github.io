WEBVTT
Kind: captions
Language: zh-CN

00:00:00.780 --> 00:00:01.540
Joe

00:00:01.540 --> 00:00:02.220
等一下

00:00:02.220 --> 00:00:05.250
你给学生的 Did you feel it 应用
发生崩溃？

00:00:05.250 --> 00:00:06.060
— 是的

00:00:06.060 --> 00:00:07.440
— 发生什么了？

00:00:07.440 --> 00:00:10.350
— 我想让学生看到这款
应用因为出现异常

00:00:10.350 --> 00:00:11.560
而崩溃

00:00:11.560 --> 00:00:13.404
— 好吧
— 出现的异常称为

00:00:13.404 --> 00:00:15.730
NetworkOnMainThreadException

00:00:15.730 --> 00:00:17.479
— 等等 你解释了
这是什么意思吗？

00:00:18.740 --> 00:00:21.389
— 没有 但我想到了
如何解释

00:00:21.389 --> 00:00:22.587
— 好的 让我们来听听看

00:00:22.587 --> 00:00:25.167
— 好吧
NetworkOnMainThreadException

00:00:25.167 --> 00:00:28.644
的意思是 我们正在主线程上
执行网络操作 而这是

00:00:28.644 --> 00:00:29.742
不允许的

00:00:29.742 --> 00:00:31.509
— 但你说到了网络

00:00:31.509 --> 00:00:35.056
意思是像我们上节课中
学到的网络请求一样？

00:00:35.056 --> 00:00:35.783
— 是的
— 好的 但

00:00:35.783 --> 00:00:37.840
你还提到了主线程？

00:00:37.840 --> 00:00:40.078
学生可能也希望了解
主线程是什么意思

00:00:40.078 --> 00:00:41.090
— 正好

00:00:41.090 --> 00:00:42.815
我带来了一些线来进行解释

00:00:42.815 --> 00:00:45.087
给 拿着

00:00:45.087 --> 00:00:46.529
— 这是

00:00:46.529 --> 00:00:49.840
— 这捆线将代表
应用的主线程

00:00:49.840 --> 00:00:52.790
线程是保存指令
序列的容器

00:00:52.790 --> 00:00:56.030
例如 设备将执行的
Java 代码

00:00:56.030 --> 00:00:59.510
并且 Android 需要它来安排
所有需要在设备硬件上

00:00:59.510 --> 00:01:01.270
运行的任务

00:01:01.270 --> 00:01:02.560
所以在构建 Android 应用时

00:01:02.560 --> 00:01:06.050
理解应用程序代码
默认在主线程上运行

00:01:06.050 --> 00:01:10.060
是极为重要的
主线程也称为 UI 线程

00:01:11.370 --> 00:01:12.810
让我们进行详细说明

00:01:12.810 --> 00:01:16.270
主线程可处理绘图操作
以响应用户输入

00:01:16.270 --> 00:01:19.970
像点击 滚动之类

00:01:19.970 --> 00:01:23.250
但主线程一次只能
处理一个事件 所以

00:01:23.250 --> 00:01:26.900
如果在同一时间
发生多起事件

00:01:26.900 --> 00:01:29.560
这些事件会像这样
被放到队列中

00:01:29.560 --> 00:01:32.039
— 所以队列就像是
我走进杂货店

00:01:32.039 --> 00:01:33.642
然后我站在很长的队伍中

00:01:33.642 --> 00:01:37.380
但只有一位收银员
每次只能接待一位顾客？

00:01:37.380 --> 00:01:37.980
— 是的

00:01:37.980 --> 00:01:38.580
— 哇哦

00:01:38.580 --> 00:01:40.498
— 这就是队列类型

00:01:40.498 --> 00:01:41.840
这些 UI 是绘图操作 

00:01:41.840 --> 00:01:45.600
每次只能按照队列顺序
处理一个用户输入事件

00:01:45.600 --> 00:01:49.670
— 到目前为止 我们编写的所有
代码都已在主线程中执行

00:01:49.670 --> 00:01:52.770
当读取 Java 代码时
可以从上到下读取

00:01:52.770 --> 00:01:55.690
可以循环或选取
特定分支 或

00:01:55.690 --> 00:01:57.890
跳入跳出其他方法

00:01:57.890 --> 00:01:59.210
运行程序时

00:01:59.210 --> 00:02:02.630
移动到下一个任务前
必须等待前一个任务完成

00:02:02.630 --> 00:02:04.620
这大致就是单线程
的操作流程

00:02:04.620 --> 00:02:07.470
按编写的顺序
运行 Java

00:02:07.470 --> 00:02:08.130
等下

00:02:08.130 --> 00:02:11.820
所以 Joe 学生可能会想 如果我们
的代码到目前为止都运行良好

00:02:11.820 --> 00:02:15.070
那我们为什么不继续在主线程
中编写我们的所有代码呢？

00:02:15.070 --> 00:02:16.450
— 这是个好问题

00:02:16.450 --> 00:02:17.440
让我来演示下为什么

