WEBVTT
Kind: captions
Language: ar

00:00:00.067 --> 00:00:04.001
‫ذكرنا أنه عندما يطبق نشاط وظيفة
‫onCreateLoader في LoaderCallback..

00:00:04.071 --> 00:00:07.169
‫نحتاج لإنشاء وإرجاع محمل،
‫فكيف نفعل ذلك؟

00:00:07.701 --> 00:00:12.228
‫لإنشاء محمل، سنحتاج لتفريع
‫فئة AsyncTaskLoader

00:00:12.419 --> 00:00:15.352
‫تتمتع AsyncTaskLoader
‫بكافة امتيازات المحمل

00:00:15.539 --> 00:00:17.805
‫مثل إدارتها بواسطة مدير المحملات..

00:00:18.197 --> 00:00:22.145
‫وفي الكواليس، فإنها تستخدم
‫AsyncTask لتنفذ عملها

00:00:22.622 --> 00:00:26.419
‫سينتعامل مع AsyncTaskLoader
‫كأي محمل آخر..

00:00:26.574 --> 00:00:30.070
‫لاحظ أن AsyncTaskLoader
‫يرث سلوكه من فئة Loader

00:00:30.523 --> 00:00:33.324
‫وهي أيضاً فئة عامة
‫بالباراميتر العام D

00:00:34.074 --> 00:00:36.207
‫بالتمرير لأسفل إلى قسم
‫الوظائف العامة

00:00:36.245 --> 00:00:40.979
‫نرى أن الباراميتر العام D يستخدم لقيمة
‫الإرجاع في وظيفة loadInBackground

00:00:41.287 --> 00:00:44.649
‫هذه وظيفة تجريدية أيضاً، بما يعني
‫أنه يتعين علينا تعريف سلوكها

00:00:44.745 --> 00:00:48.178
‫وإرجاع قيمة بأي نوع بيانات من اختيارنا

00:00:48.295 --> 00:00:52.395
‫طالما أن إعلان الفئة
‫يحدد نوع البيانات مقدماً

00:00:54.354 --> 00:00:58.362
‫أظن أن مثالاً جيداً سيساعدك على
‫فهم وتركيب كل ما غطيناه هنا

00:00:59.267 --> 00:01:02.335
‫هذا الدرس قديم نسبياً
‫كما تخمن من واجهة المستخدم

00:01:02.677 --> 00:01:04.277
‫لكني أحببت بساطة الكود

00:01:04.616 --> 00:01:08.247
‫هدف الكود أن يعرض قائمة موظفين
‫في واجهة القائمة ListView

00:01:08.373 --> 00:01:11.839
‫عبر تحميل البيانات في
‫خيط خلفي داخل AsyncTaskLoader

00:01:12.480 --> 00:01:15.001
‫رابط الصفحة أدناه إن رغبت
‫في تفقدها لاحقاً

00:01:15.668 --> 00:01:17.837
‫لننظر إلى فئة EmployeeLoader

00:01:17.957 --> 00:01:21.292
‫كما ترى فإننا نمدد فئة
‫AsyncTaskLoader

00:01:21.767 --> 00:01:25.510
‫للبارامتير العام بين الأقواس نحدد
‫&lt;List&lt;Employees&gt;&gt;

00:01:25.931 --> 00:01:30.365
‫هذا يعني أن قيمة الإرجاع لوظيفة
‫loadInBackground هي قائمة موظفين

00:01:30.911 --> 00:01:33.245
‫لذا في وظيفة loadInBackground..

00:01:34.145 --> 00:01:36.412
‫نرى قائمة مصفوفة جديدة بالموظفين..

00:01:36.872 --> 00:01:38.606
‫ونضيف 3 مدخلات إلى القائمة

00:01:38.930 --> 00:01:40.234
‫ثم نرجع القائمة

00:01:40.631 --> 00:01:44.244
‫عملياً العمل المنجز في هذه الوظيفة
‫يمكن إجراؤه على الخيط الرئيسي

00:01:44.530 --> 00:01:47.564
‫لأنه ليست معالجة ثقيلة أو اتصال شبكي

00:01:48.089 --> 00:01:52.422
‫لكن كاتب هذا المقال أراد مثالاً
‫بسيطاً ليعرض فئة AsyncTaskLoader

00:01:53.434 --> 00:01:56.837
‫كما لدينا دالة إنشائية لإنشاء
‫نسخة EmployeeLoader جديدة

00:01:57.133 --> 00:02:01.127
‫بداخله سنستدعي الدالة الإنشائية العليا
‫ونمرر له السياق

00:02:01.659 --> 00:02:02.659
‫وقُضي الأمر

00:02:02.838 --> 00:02:05.314
‫أترى؟ المحمل مباشر وسهل التطبيق

00:02:06.085 --> 00:02:07.246
‫تراجع قليلاً..

00:02:07.509 --> 00:02:10.742
‫يمكننا النظر إلى كيفية استخدام المحمل
‫في سياق التطبيق

00:02:11.043 --> 00:02:13.220
‫في إعلان فئة النشاط..

00:02:13.475 --> 00:02:16.575
‫نرى أن MainActivity
‫يمتد من FragmentActivity

00:02:17.240 --> 00:02:20.219
‫ثم يطبق واجهة LoaderManager
‫ومنها LoaderCallbacks

00:02:20.688 --> 00:02:23.516
‫والنوع العام المحدد هو &lt;قائمة&lt;الموظفين&gt;&gt;

00:02:24.263 --> 00:02:25.996
‫بالتمرير لأسفل، وكما ترى..

00:02:26.250 --> 00:02:30.050
‫فهذا يعني أن النشاط يجب أن يطبق
‫وظائف الاستدعاء التجريدية الثلاث

00:02:30.133 --> 00:02:31.300
‫onCreateLoader

00:02:31.400 --> 00:02:32.567
‫وonLoaderFinished

00:02:32.868 --> 00:02:34.035
‫وonLoaderReset

00:02:34.368 --> 00:02:38.568
‫لاحظ أن نوع البيانات (قائمة الموظفين)
‫يستخدم عبر وظائف الاستدعاء

00:02:38.944 --> 00:02:43.010
‫رغم وجود أقواس كثيرة، فتعامل
‫مع قائمة الموظفين ككتلة واحدة

00:02:43.520 --> 00:02:47.572
‫هذه الكتلة نفسها أدخلت في عدة أماكن
‫في توقيعات وظائف الاستدعاء

00:02:47.668 --> 00:02:49.989
‫مثلاً في وظيفة onCreateLoader..

00:02:50.180 --> 00:02:54.873
‫فإنها ترجع محملاً يحمل البيانات في شكل
‫(قائمة موظفين)، الكتلة نفسها كما بالأعلى

00:02:55.802 --> 00:02:58.870
‫ثم في الوظيفة، أنشئنا
‫EmployeeLoader جديد

00:02:59.180 --> 00:03:01.280
‫والتي تمتد من (محمل قائمة الموظفين)

00:03:01.382 --> 00:03:03.449
‫لذا تطابق قيمة الإرجاع المطلوبة

00:03:03.981 --> 00:03:05.657
‫ثم نرجع نسخة المحمل

00:03:05.868 --> 00:03:09.535
‫في وظيفة onLoadFinished
‫نتلقى مُدخلين

00:03:10.000 --> 00:03:11.767
‫محمل ونتيجة

00:03:12.103 --> 00:03:14.570
‫نوع بيانات النتيجة هو
‫(قائمة الموظفين)

00:03:14.700 --> 00:03:17.167
‫والمحمل يحمل بيانات
‫(قائمة الموظفين)

00:03:17.584 --> 00:03:20.518
‫القيمة التي نهتم لها حقاً
‫هي كائن النتيجة هذا

00:03:20.734 --> 00:03:23.934
‫نأخذ قائمة الموظفين
‫ونحدث البيانات في المحول

00:03:24.137 --> 00:03:25.902
‫والذي سيحدث
‫واجهة القائمة المقترنة به

00:03:26.522 --> 00:03:29.571
‫في وظيفة onLoadReset
‫نتلقى مدخلاً واحداً

00:03:29.945 --> 00:03:31.154
‫المحمل نفسه

00:03:32.043 --> 00:03:34.443
‫وحيث لدينا محملاً واحداً في النشاط..

00:03:34.515 --> 00:03:37.915
‫يمكننا إزالة البيانات السابقة
‫التي أعطاناها المحمل آخر مرة

00:03:38.152 --> 00:03:41.419
‫لذا نضبط بيانات المحول
‫إلى قائمة موظفين خالية

00:03:41.572 --> 00:03:42.873
‫إليك السيناريو الكامل

00:03:43.067 --> 00:03:45.668
‫في نشاطنا ولإطلاق المحمل في البداية..

00:03:45.816 --> 00:03:48.438
‫نجلب LoaderManager
‫ونستدعي initLoader عليه

00:03:49.319 --> 00:03:50.319
‫بالمناسبة

00:03:50.400 --> 00:03:53.867
‫getSupportLoaderManager
‫هو نفسه getLoaderManager

00:03:54.133 --> 00:03:57.400
‫إلا أن هذا يستخدم نسخة الدعم من
‫getLoaderManager

00:03:57.767 --> 00:03:59.301
‫في استدعاء initLoader..

00:03:59.465 --> 00:04:02.444
‫يتأكد المدير من وجود المحمل مسبقاً

00:04:02.793 --> 00:04:04.962
‫ويمرر النسخة الموجودة إن وجدت

00:04:05.510 --> 00:04:07.370
‫إن لم توجد نسخة بالفعل..

00:04:07.474 --> 00:04:10.474
‫يتم استدعاء onCreateLoader
‫لإنشاء نسخة جديدة

00:04:10.834 --> 00:04:13.901
‫ثم يمكننا إنشاء نسخة جديدة
‫من EmployeeLoader وإرجاعها

00:04:14.501 --> 00:04:15.901
‫إليك السيناريو الكامل

00:04:16.033 --> 00:04:18.667
‫في نشاطنا ولإطلاق المحمل في البداية..

00:04:18.801 --> 00:04:21.669
‫نجلب LoaderManager
‫ونستدعي initLoader عليه

00:04:22.000 --> 00:04:23.000
‫بالمناسبة

00:04:23.067 --> 00:04:26.301
‫getSupportLoaderManager
‫هو نفسه getLoaderManager

00:04:26.334 --> 00:04:29.601
‫إلا أن هذا يستخدم نسخة الدعم من
‫getLoaderManager

00:04:30.534 --> 00:04:32.368
‫في استدعاء initLoader..

00:04:32.567 --> 00:04:35.667
‫يتأكد المدير من وجود المحمل مسبقاً

00:04:35.968 --> 00:04:38.202
‫ويمرر النسخة الموجودة إن وجدت

00:04:38.934 --> 00:04:40.768
‫إن لم توجد نسخة بالفعل..

00:04:40.934 --> 00:04:44.067
‫يتم استدعاء onCreateLoader
‫لإنشاء نسخة جديدة

00:04:44.757 --> 00:04:47.358
‫ثم يمكننا إنشاء نسخة جديدة
‫من EmployeeLoader وإرجاعها

00:04:47.596 --> 00:04:49.757
‫تلاحظ أنه بعد بدء المحمل..

00:04:49.932 --> 00:04:51.736
‫فإن الكود يستدعي forceLoad

00:04:52.054 --> 00:04:54.920
‫وهذا مطلوب لإطلاق المحمل
‫ليبدأ عمل الخلفية

00:04:56.048 --> 00:05:00.348
‫الممارسة الأفضل رغم هذا هي وضع استدعاء
‫forceLoad في فئة المحمل الفرعية

00:05:00.671 --> 00:05:05.404
‫ستقوم بتجاوز وظيفة onStartLoading
‫في فئة المحمل، واستدع forceLoad منها

00:05:06.090 --> 00:05:09.586
‫يتم إطلاق oStartLoading
‫آلياً من initLoader

00:05:10.103 --> 00:05:13.138
‫ما أن نستدعي forceLoad
‫يبدأ المحمل عمله

00:05:13.940 --> 00:05:16.556
‫ستعمل loadInBackground
‫على خيط خلفي..

00:05:17.151 --> 00:05:18.951
‫ويتم إنشاء (قائمة الموظفين)

00:05:19.210 --> 00:05:20.911
‫وترجع تلك كنتيجة المحمل

00:05:21.400 --> 00:05:23.296
‫ما أن ينهي المحمل تحميل البيانات..

00:05:23.337 --> 00:05:27.737
‫سيخطر مدير المحملات والذي سيمرر
‫البيانات إلى وظيفة onLoadFinished

00:05:28.466 --> 00:05:31.599
‫وعند استدعاء onLloadFinished
‫بقائمة الموظفين..

00:05:31.892 --> 00:05:35.958
‫نحدث بيانات المحول بتلك الجديدة
‫بما يحدث القائمة ويعيد رسمها

00:05:36.387 --> 00:05:38.187
‫عند إغلاق النشاط..

00:05:38.336 --> 00:05:40.941
‫سيتولى مدير المحملات مسح المحمل

00:05:41.092 --> 00:05:45.285
‫وسيخبرنا عندما لا تكون
‫بياناته غير صالحة

00:05:45.738 --> 00:05:49.004
‫وفي تلك الحالة نزيلها من الواجهة
‫ونوقف استخدامها

00:05:49.624 --> 00:05:53.758
‫إذا مُسح النشاط قبل انتهاء المحمل..
‫فلن يتم استدعاء هذه الوظيفة

00:05:54.168 --> 00:05:58.069
‫إذا شغلنا التطبيق على جهازنا..
‫سيبدو التطبيق كهذه اللقطة

00:05:58.871 --> 00:06:01.071
‫أعلم، واجهة المستخدم تبدو قديمة..

00:06:01.447 --> 00:06:05.980
‫ولكن هذا بسبب تحديث محاكي آندرويد
‫ستوديو قليلاً منذ إنشاء هذا الدرس

00:06:06.490 --> 00:06:10.458
‫تناولنا دورة كاملة حول كيفية عمل
‫المحمل واستدعاءات مدير المحملات

00:06:10.968 --> 00:06:13.535
‫وحيث ناقشنا تطبيق المحملات
‫في هذا الفيديو..

00:06:13.593 --> 00:06:16.327
‫أريد منك محاول حل الاختبار
‫بملء الفراغات

00:06:16.732 --> 00:06:20.599
‫أي نوع من المحملات يستخدم AsyncTask
‫لينفذ عمل في الخلفية؟

00:06:20.783 --> 00:06:24.050
‫لإنشاء محمل مخصص
‫يجلب قائمة كائنات الزلازل..

00:06:24.216 --> 00:06:27.584
‫يمكننا تعريف فئة EarthquakeLoader
‫والتي تمتد من ماذا؟

00:06:27.997 --> 00:06:31.197
‫في فئة EarthquakeLoader
‫نحتاج لتجاوز أي وظيفة..

00:06:31.431 --> 00:06:34.431
‫والتي ستعمل على خيط خلفي
‫وترجع قائمة الزلازل

00:06:34.934 --> 00:06:39.568
‫مجدداً، وللتلميح.. يمكنك الاختيار من
‫الخيارات في الملاحظات أسفل الاختبار

