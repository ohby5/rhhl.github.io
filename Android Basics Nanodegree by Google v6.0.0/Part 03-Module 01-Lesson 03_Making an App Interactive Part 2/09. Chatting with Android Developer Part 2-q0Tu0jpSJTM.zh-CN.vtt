WEBVTT
Kind: captions
Language: zh-CN

00:00:00.590 --> 00:00:04.400
我们的学生已经在课程中学习了变量和数据类型

00:00:04.400 --> 00:00:07.120
特别是整型和字符串型

00:00:07.120 --> 00:00:13.030
对于这些应用 你工作中有遇到类似的例子吗？

00:00:13.030 --> 00:00:13.970
是的 很多

00:00:13.970 --> 00:00:15.840
整型和字符串无处不在

00:00:17.460 --> 00:00:22.850
例如 Gmail 当你第一次打开邮箱时 它会告诉你有多少

00:00:22.850 --> 00:00:27.990
未读信息 这是非常重要的数字

00:00:27.990 --> 00:00:30.710
实际上还存在一些非常细微的 bug

00:00:31.930 --> 00:00:36.820
这个数可能和你实际未读信息数不匹配

00:00:36.820 --> 00:00:37.463
但

00:00:37.463 --> 00:00:38.271
我还没有遇到过

00:00:38.271 --> 00:00:38.788
你呢

00:00:38.788 --> 00:00:39.550
那就好

00:00:39.550 --> 00:00:40.630
你从来没有遇到过

00:00:40.630 --> 00:00:45.328
但这是一个很有趣的要解决的问题

00:00:45.328 --> 00:00:49.620
因为对于 Gmail 我们需要先同步这个数字

00:00:49.620 --> 00:00:51.010
同步是指

00:00:51.010 --> 00:00:54.770
我先从云端抓取数据到我的 Android 设备

00:00:54.770 --> 00:00:55.910
所以 数据实际上

00:00:55.910 --> 00:00:59.790
是和你的实际邮件分别同步的

00:00:59.790 --> 00:01:02.820
所以它们可能不同步

00:01:02.820 --> 00:01:05.790
这是一个非常棘手的难题

00:01:05.790 --> 00:01:10.210
所以我们确定未读邮件数是一个变量

00:01:10.210 --> 00:01:11.460
这将是它的数据类型

00:01:11.460 --> 00:01:12.344
它是整型

00:01:12.344 --> 00:01:13.200
它是整型

00:01:14.370 --> 00:01:17.280
它的值在设备之间被计算

00:01:17.280 --> 00:01:21.560
根据使用场景的不同 它的值相应改变

00:01:21.560 --> 00:01:22.650
我根据经验使用它

00:01:22.650 --> 00:01:24.260
完全正确

00:01:24.260 --> 00:01:26.110
另一个使用

00:01:26.110 --> 00:01:29.450
整型变量的例子 他是可以改变的

00:01:29.450 --> 00:01:31.510
另一个例子是 ID

00:01:31.510 --> 00:01:35.080
对于 ID  保持不变是非常重要的

00:01:35.080 --> 00:01:36.351
尤其是我的 Email ID

00:01:36.351 --> 00:01:37.260
确实是

00:01:37.260 --> 00:01:40.200
服务器上的 Email ID表示

00:01:40.200 --> 00:01:43.680
需要和客户端的 ID 完全一致

00:01:43.680 --> 00:01:46.150
因为这是我们在各个设备之间的唯一标识

00:01:46.150 --> 00:01:48.260
这些邮件的方法

00:01:48.260 --> 00:01:52.320
这是为了邮件会话 与邮件地址不同

00:01:52.320 --> 00:01:56.930
对于邮件会话 例如 Gmail 中的整个线程

00:01:56.930 --> 00:02:02.460
邮件线程中有非常多的信息 整个线程称为

00:02:02.460 --> 00:02:05.390
— 一个会话 它有一个会话 — 好的 我明白了

00:02:05.390 --> 00:02:08.460
每个信息自己都有一个唯一得标识 ID

00:02:08.460 --> 00:02:13.330
每一个 ID 都是用变量存储 那是什么数据类型呢？

00:02:13.330 --> 00:02:14.010
又是整型

00:02:14.010 --> 00:02:14.840
好的

00:02:14.840 --> 00:02:16.040
一天要发

00:02:16.040 --> 00:02:17.640
多少封邮件呢

00:02:17.640 --> 00:02:18.410
你知道吗?

00:02:18.410 --> 00:02:19.580
这是个很大的数目

00:02:19.580 --> 00:02:23.160
我不知道到底有多少封邮件

00:02:23.160 --> 00:02:28.320
我要想像一下如果每个会话的信息是唯一的

00:02:28.320 --> 00:02:31.570
所有邮件中的每一封也是唯一的

00:02:31.570 --> 00:02:32.190
是的

00:02:32.190 --> 00:02:33.580
那应该是一个非常大的数目

00:02:33.580 --> 00:02:34.690
这是一个非常好的问题

00:02:34.690 --> 00:02:37.810
所以实际上我们使用long 类型而不是int 类型

00:02:37.810 --> 00:02:40.542
因为它是 64 位的

00:02:40.542 --> 00:02:41.784
所以我们继续

00:02:41.784 --> 00:02:43.655
所以 long 只是给你更多空间

00:02:43.655 --> 00:02:45.070
来存储更大的数字 是吧？

00:02:45.070 --> 00:02:46.284
这就是 int 和 long 之间的区别

00:02:46.284 --> 00:02:49.642
字符串的例子呢？

00:02:49.642 --> 00:02:51.660
字符串

00:02:51.660 --> 00:02:53.460
我觉得它是主观的

00:02:53.460 --> 00:02:55.530
一个字符串 或者它是怎么存储的？

00:02:55.530 --> 00:02:57.380
所有都是

00:02:57.380 --> 00:02:59.420
Subject 本身就是字符串

00:02:59.420 --> 00:03:00.660
对

00:03:00.660 --> 00:03:03.510
很明显 邮件地址就是字符串

00:03:03.510 --> 00:03:05.560
这是非常重要的

00:03:05.560 --> 00:03:08.980
在应用中你看到的一切

00:03:08.980 --> 00:03:12.960
几乎所有的带文本的都是字符串

00:03:12.960 --> 00:03:16.130
一个好的工程师不必要知道所有的一切

00:03:16.130 --> 00:03:17.070
但是你必须

00:03:17.070 --> 00:03:21.010
擅长寻找答案

00:03:21.010 --> 00:03:26.060
你可以找到有很多好的教程

00:03:26.060 --> 00:03:28.720
只需要知道如何找到正确的关键字

00:03:29.810 --> 00:03:31.850
搜寻正确的关键字

00:03:31.850 --> 00:03:34.470
你也可以向其他人寻求帮助

00:03:34.470 --> 00:03:36.610
这也是非常重要的

00:03:36.610 --> 00:03:39.880
我经常后悔怎么没早点问其他人

00:03:39.880 --> 00:03:44.830
当我尝试用了一整天修复一些事情

00:03:44.830 --> 00:03:45.800
到最后

00:03:45.800 --> 00:03:50.490
或许我应该问问是谁写了这个组件

00:03:50.490 --> 00:03:55.610
所以我认为早点联系其他人是绝对有价值的

00:03:55.610 --> 00:03:57.500
能节省宝贵的时间

00:03:57.500 --> 00:04:03.000
并且要知道 Google 中正在进行的其它项目

00:04:03.000 --> 00:04:06.140
或者是你自己的 或者是你周围的

00:04:06.140 --> 00:04:11.270
我认为真正好的工程师 不光只关注自己的项目

00:04:11.270 --> 00:04:16.870
还关注像这样的技术讲座

00:04:16.870 --> 00:04:18.769
这个是可以公开观看的

00:04:18.769 --> 00:04:20.420
至少是其中一部分

00:04:20.420 --> 00:04:21.140
是的

00:04:21.140 --> 00:04:21.839
其中一些可以观看 好的

00:04:21.839 --> 00:04:26.330
所以从这些技术讲座中 可以得知最新的技术

00:04:26.330 --> 00:04:31.600
或者是发送到整个工程组织的公告

00:04:31.600 --> 00:04:34.340
所以一定要参与其中

00:04:34.340 --> 00:04:38.320
让我们回到你刚开始学习编程的时候

00:04:39.390 --> 00:04:42.340
如果你能和 Alice 对话

00:04:42.340 --> 00:04:45.440
你会给她提什么建议

00:04:45.440 --> 00:04:47.680
这是个非常有趣的问题

00:04:47.680 --> 00:04:51.980
我觉得我应该在编程时更开心一些

00:04:55.140 --> 00:04:57.458
我认为我学习编程的方法

00:04:57.458 --> 00:05:02.240
和现在非常不同 因为我生于中国

00:05:02.240 --> 00:05:06.100
我们集中于学术

00:05:06.100 --> 00:05:11.461
比如 我参加过一些 老师教授的课程

00:05:11.461 --> 00:05:15.781
我们会得到一些任务 就像现在你学习

00:05:15.781 --> 00:05:17.790
解决一些问题

00:05:18.870 --> 00:05:23.447
现在回过头想想

00:05:23.447 --> 00:05:31.100
我希望我能做一些更有趣的项目

00:05:31.100 --> 00:05:34.130
你会做一个生日的应用吗

00:05:34.130 --> 00:05:35.078
生日应用？

00:05:35.078 --> 00:05:35.898
当然

00:05:35.898 --> 00:05:40.322
像这种类型的应用 我想我会学到更多

00:05:40.322 --> 00:05:44.280
因为它不止是一个正确的答案

00:05:44.280 --> 00:05:47.310
在做应用的过程中 我可以学到

00:05:47.310 --> 00:05:49.240
设计 如果他是个生日应用

00:05:49.240 --> 00:05:52.645
我会学习不同的 UI 组件 它不会只是

00:05:52.645 --> 00:05:56.100
把数据从这里发送到那里

00:05:56.100 --> 00:06:01.117
然后更有效的解决它

00:06:01.117 --> 00:06:06.240
我认为现实生活中工程师是

00:06:06.240 --> 00:06:10.250
不仅仅解决技术难题

00:06:10.250 --> 00:06:12.560
还创造伟大的产品

00:06:12.560 --> 00:06:14.800
就像被你的好奇心驱使

00:06:14.800 --> 00:06:15.790
确实是

00:06:15.790 --> 00:06:16.790
是的

00:06:16.790 --> 00:06:19.290
Cathy 和我非常感谢你的到来

00:06:19.290 --> 00:06:20.250
不客气

00:06:20.250 --> 00:06:23.008
我想学生们会从你的观点中收益颇丰

00:06:23.008 --> 00:06:23.508
好的

