WEBVTT
Kind: captions
Language: zh-CN

00:00:00.580 --> 00:00:02.050
做好准备

00:00:02.050 --> 00:00:03.390
这将是个很长的解决方案视频

00:00:03.390 --> 00:00:06.150
但是我们将一步一步地应对

00:00:06.150 --> 00:00:08.790
首先 我们想要请求 Audio Focus

00:00:08.790 --> 00:00:11.380
意味着我们需要 AudioManager 对象实例

00:00:12.630 --> 00:00:16.050
在 NumbersActivity 中 我将为 AudioManager

00:00:16.050 --> 00:00:20.010
创建一个全局变量 并在生命周期 Activity 中初始化一次

00:00:20.010 --> 00:00:22.212
接着 在 NumbersActivity 的 onCreate 方法中

00:00:22.212 --> 00:00:26.020
我将通过调用 getSystemService 来初始化 AudioManager

00:00:26.020 --> 00:00:28.410
并传入 AUDIO_SERVICE 常量

00:00:28.410 --> 00:00:30.750
我知道要写这行代码 是因为

00:00:30.750 --> 00:00:33.170
在这个 MediaPlayer 教程中,

00:00:33.170 --> 00:00:37.260
我看到了如何引用 AudioManager 系统服务

00:00:37.260 --> 00:00:39.100
获得 AudioManager 对象后

00:00:39.100 --> 00:00:41.910
我们可以对其调用 requestAudioFocused 方法

00:00:41.910 --> 00:00:44.730
我们复制这段代码 并添加到我们的应用中

00:00:47.310 --> 00:00:50.370
应该在哪请求 Audio Focus 呢？

00:00:50.370 --> 00:00:51.900
我知道 当某项内容被点击后

00:00:51.900 --> 00:00:55.060
我希望使用 AudioManager 来请求 Audio Focus

00:00:55.060 --> 00:00:57.430
然后再设置 MediaPlayer 来播放声音

00:00:57.430 --> 00:01:01.168
所以我将代码粘贴到这里 放在 Word 对象的代码之后

00:01:01.168 --> 00:01:04.724
以及释放 MediaPlayer 之后

00:01:04.724 --> 00:01:07.124
现在 我希望这些变量名称更具描述性

00:01:07.124 --> 00:01:11.870
我将当前的变量名称从 am 更改成了 mAudioManager

00:01:11.870 --> 00:01:13.500
当我们请求 Audio Focus 时

00:01:13.500 --> 00:01:15.540
我们将传入三个输入参数

00:01:15.540 --> 00:01:16.620
我需要传入一个监听器

00:01:16.620 --> 00:01:19.490
需要指定音乐 streamType

00:01:19.490 --> 00:01:21.710
以及需要请求音频的时长

00:01:22.790 --> 00:01:26.580
我们复制的代码示例请求的是 AUDIOFOCUS_GAIN

00:01:26.580 --> 00:01:30.690
以便请求 Audio Focus 并持续很长的未知时间

00:01:30.690 --> 00:01:32.750
例如播放一首歌曲

00:01:32.750 --> 00:01:36.400
但是 在 Miwok 应用中 我们的音频片段只有一两秒钟

00:01:36.400 --> 00:01:39.420
因此我们的 Audio Focus 只需很短的时间

00:01:39.420 --> 00:01:42.415
因此 我们将 AUDIOOCUS_GAIN 改为

00:01:42.415 --> 00:01:44.570
AUDIOOCUS_GAIN_TARNSIENT

00:01:44.570 --> 00:01:46.630
看起来似乎还有几个错误

00:01:46.630 --> 00:01:49.550
Android Studio 依然无法识别监听器

00:01:49.550 --> 00:01:51.070
并报错了

00:01:51.070 --> 00:01:53.570
这是因为我们尚未定义监听器

00:01:53.570 --> 00:01:55.460
但我们可以稍后再来解决该错误

00:01:55.460 --> 00:01:57.100
现在回到该教程

00:01:57.100 --> 00:01:59.840
并仔细阅读下 requestAudioFocus 方法

00:01:59.840 --> 00:02:02.680
我们看到该方法返回了一个整数

00:02:02.680 --> 00:02:03.430
你猜怎么着?

00:02:03.430 --> 00:02:05.870
结果也是个常量值

00:02:05.870 --> 00:02:08.270
在下面关于该方法的部分

00:02:08.270 --> 00:02:11.260
文中指出两个可能的返回值都是常量

00:02:11.260 --> 00:02:15.580
即 AUDIOFOCUS_REQUEST_FAILED 或 AUDIOFOCUS_REQUEST_GRANTED

00:02:15.580 --> 00:02:19.210
每个常量都是 static final 变量

00:02:19.210 --> 00:02:21.940
相当于固定的整数值

00:02:21.940 --> 00:02:23.960
回到这里的代码示例部分

00:02:23.960 --> 00:02:27.890
如果结果等于 AUDIOFOCUS_REQUEST_GRANTED

00:02:27.890 --> 00:02:30.280
那么我们就成功地获取了 Audio Focus

00:02:30.280 --> 00:02:32.720
可以开始在我们的应用中播放音频了

00:02:32.720 --> 00:02:33.660
回到我们的代码

00:02:33.660 --> 00:02:37.440
我们将该 if 语句添加到这段请求 Audio Focus 的代码下面

00:02:37.440 --> 00:02:39.200
一旦获得 Audio Focus

00:02:39.200 --> 00:02:41.680
我们就希望创建并开始 MediaPlayer

00:02:41.680 --> 00:02:43.570
然后设置 CompletionListener

00:02:43.570 --> 00:02:47.145
所以 这段代码需要移到这个 if 语句中

00:02:47.145 --> 00:02:51.885
我将这个右括号移到这里

00:02:51.885 --> 00:02:53.485
修改下该注释

00:02:53.485 --> 00:02:56.825
写成“现在已经具有 Audio Focus 了”

00:02:56.825 --> 00:02:58.745
然后缩进下这几行代码

00:02:58.745 --> 00:03:00.705
因为它们位于 if 语句内

00:03:00.705 --> 00:03:02.730
如果我们没有获得 Audio Focus

00:03:02.730 --> 00:03:04.670
那么就不需要设置 MediaPlayer

00:03:04.670 --> 00:03:06.650
用户将需要再次点击列表项

00:03:06.650 --> 00:03:09.305
希望这时候我们能获得 Audio Focus

00:03:09.305 --> 00:03:12.844
第一项任务就解决了

00:03:12.844 --> 00:03:17.365
现在我们来实施 OnAudioFocusChangeListener

00:03:17.365 --> 00:03:20.445
这将有助于我们解决当前代码中存在的错误

00:03:20.445 --> 00:03:22.400
我们来看看该监听器应该是怎样的

00:03:22.400 --> 00:03:23.805
向下滚动该教程

00:03:23.805 --> 00:03:26.290
这里有个示例展示了监听器可能的样子

00:03:26.290 --> 00:03:29.220
因为每次请求 Audio Focus 时 我们都需要传入该监听器

00:03:29.220 --> 00:03:30.290
并作为输入参数

00:03:30.290 --> 00:03:32.440
所以我们将该监听器设为全局变量

00:03:32.440 --> 00:03:34.960
这样每次都可以重复使用相同的监听器

00:03:34.960 --> 00:03:36.200
我将复制这段代码

00:03:36.200 --> 00:03:39.440
并粘贴到我们的 NumbersActivity 中

00:03:40.960 --> 00:03:44.619
我将这段代码粘贴到所有其他全局变量下面

00:03:45.690 --> 00:03:48.130
你可以将该变量重命名为任何名称

00:03:48.130 --> 00:03:53.170
我将其重命名为 mOnAudioFocusChangeListener

00:03:53.170 --> 00:03:56.280
这里 我们将创建一个新的对象实例

00:03:56.280 --> 00:03:57.940
并实施该监听器接口

00:03:57.940 --> 00:04:02.130
这意味着我们需要重写 onAudioFocusChange 方法

00:04:02.130 --> 00:04:06.900
该方法具有一个参数 即新的 Audio Focus 状态

00:04:06.900 --> 00:04:09.740
在这个 onAudioFocusChange 方法中

00:04:09.740 --> 00:04:11.200
我们将放入说明 指出当系统调用该方法时

00:04:11.200 --> 00:04:14.010
会发生的情况

00:04:14.010 --> 00:04:16.310
因为 Audio Focus 状态已经在我们的应用中发生变化

00:04:17.410 --> 00:04:20.240
这里的明智做法是弄明白新状态是什么

00:04:20.240 --> 00:04:23.230
方法是查看传入的 focusChange 变量

00:04:23.230 --> 00:04:26.780
这里我们使用了 if else 条件语句

00:04:26.780 --> 00:04:28.810
看看 focusChange 变量的值是什么

00:04:28.810 --> 00:04:32.000
注意“==”符号可以检查

00:04:32.000 --> 00:04:33.190
左右两边的值是否相等

00:04:33.190 --> 00:04:34.910
如果相等 这整个表达式就为真

00:04:34.910 --> 00:04:38.320
然后我们就执行位于这个 if 部分的代码

00:04:38.320 --> 00:04:39.980
否则的话 如果这个表达式为假

00:04:39.980 --> 00:04:42.052
那么我们就跳过前面的代码块

00:04:42.052 --> 00:04:44.305
直接转到这里的 else if 语句

00:04:44.305 --> 00:04:48.225
如果 Audio Focus 变量等于 AUDIOFOCUS_LOSS_TRANSIENT 状态

00:04:48.225 --> 00:04:51.470
那么我们暂时失去了 Audio Focus

00:04:51.470 --> 00:04:53.370
意味着我们可以暂停 MediaPlayer

00:04:53.370 --> 00:04:55.170
我在这里添加这两行代码

00:04:55.170 --> 00:04:56.850
对于 mMediaPlayer.seekTo 方法

00:04:56.850 --> 00:04:59.425
我将位置改成从音频文件的

00:04:59.425 --> 00:05:00.485
开头位置开始

00:05:00.485 --> 00:05:01.885
即从位置 0 开始

00:05:01.885 --> 00:05:04.295
这是因为 如果我们确实重新获得了 Audio Focus

00:05:04.295 --> 00:05:05.195
那么最好

00:05:05.195 --> 00:05:07.625
能让用户从音频文件的开头位置开始聆听单词发音

00:05:07.625 --> 00:05:09.235
而不是聆听剩余的发音内容

00:05:09.235 --> 00:05:11.512
毕竟我们的单词发音很短

00:05:11.512 --> 00:05:13.411
现在我将修改下这里的测试用例

00:05:13.411 --> 00:05:16.812
因为我希望该行为同时适用于 LOSS_TRANSIENT_CAN_DUCK

00:05:16.812 --> 00:05:18.217
状态

00:05:18.217 --> 00:05:21.052
同时通过指定为 AudioManager.AUDIOFOCUS_LOSS_TRANSIENT

00:05:21.052 --> 00:05:24.168
解决该错误

00:05:24.168 --> 00:05:25.838
在上一道测试题中

00:05:25.838 --> 00:05:29.580
我们判断出这两个状态 AUDIOFOCUS_LOSS_TRANSIENT 和

00:05:29.580 --> 00:05:34.618
AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK 是两个处理方法相同的状态

00:05:34.618 --> 00:05:37.738
在两种情况下 MediaPlayer 都应该暂停

00:05:37.738 --> 00:05:40.648
我们可以使用这个双竖线“||”表示或者

00:05:40.648 --> 00:05:41.698
即 OR

00:05:41.698 --> 00:05:43.198
这是我们第一次使用该符号

00:05:43.198 --> 00:05:45.708
如果看起来不熟悉 也正常

00:05:45.708 --> 00:05:48.000
使用该符号后 这个语句就可以读成

00:05:48.000 --> 00:05:52.620
如果 focusChange 变量等于 AUDIOFOCUS_LOSS_TRANSIENT 状态

00:05:52.620 --> 00:05:55.270
或者如果 focusChange 变量等于

00:05:55.270 --> 00:05:58.060
AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK 状态

00:05:58.060 --> 00:06:00.450
那么这整个表达式就为真

00:06:00.450 --> 00:06:03.000
我们就可以执行这个 if 代码块

00:06:03.000 --> 00:06:06.700
表示“||”符号左侧的表达式

00:06:06.700 --> 00:06:09.500
或右侧的表达式必须为真

00:06:09.500 --> 00:06:12.680
整个表达式才为真

00:06:12.680 --> 00:06:14.445
如果你不想使用这个“||”符号

00:06:14.445 --> 00:06:16.980
可以直接创建另一个 else if 语句块

00:06:16.980 --> 00:06:20.860
以便检查 AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK 状态

00:06:20.860 --> 00:06:23.080
对我们来说 我们直接合并到一起 检查一次

00:06:23.080 --> 00:06:24.800
因为对两种情况来说 暂停和重新设置

00:06:24.800 --> 00:06:28.058
MediaPlayer 位置的逻辑是相同的

00:06:28.058 --> 00:06:31.175
我在这里添加些注释 解释下为何选择这种行为

00:06:31.175 --> 00:06:31.867
 148
00:06:31,867 --&gt; 00:06:35,055
如果 focusChange 变量不是上述任一状态

00:06:35.055 --> 00:06:38.700
那么我们检查下它是否等于 AUDIOFOCUS_GAIN 状态

00:06:38.700 --> 00:06:40.490
现在回到上一道测试题中的表格

00:06:40.490 --> 00:06:43.710
当我们获得 Audio Focus 我们可以恢复 MediaPlayer

00:06:43.710 --> 00:06:47.220
MediaPlayer API 中没有恢复方法

00:06:47.220 --> 00:06:49.720
你可以直接调用 start() 方法

00:06:49.720 --> 00:06:51.600
它会从上次离开的地方继续

00:06:51.600 --> 00:06:58.510
我将这个注释改成 mMediaPlayer.start()

00:06:58.510 --> 00:07:00.800
同时添加个注释 解释下这种情况

00:07:01.840 --> 00:07:05.190
最后 如果 focusChange 变量不等于这三种状态中的任何一种

00:07:05.190 --> 00:07:08.890
但是等于 AUDIOFOCUS_LOSS 状态

00:07:08.890 --> 00:07:11.270
那么我们执行这段代码

00:07:11.270 --> 00:07:13.600
再次回到上一道测试题中的表格

00:07:13.600 --> 00:07:15.060
我们提到 当我们永久失去 Audio Focus 时

00:07:15.060 --> 00:07:18.980
我们应该停止并清空 MediaPlayer

00:07:18.980 --> 00:07:19.650
幸运的是

00:07:19.650 --> 00:07:23.930
我们有一个辅助方法 称为 releaseMediaPlayer() 可以帮助我们处理这种情况

00:07:23.930 --> 00:07:25.742
在最后的 else if 语句块中

00:07:25.742 --> 00:07:27.620
我将删除示例代码

00:07:27.620 --> 00:07:30.760
并调用我们自己的 releaseMediaPlayer() 方法

00:07:30.760 --> 00:07:32.974
同时添加些注释 保持一致

00:07:32.974 --> 00:07:34.650
并解释下发生的情况

00:07:34.650 --> 00:07:36.800
第二项任务解决了

00:07:36.800 --> 00:07:39.520
创建 focusChangeListener 的实例

00:07:39.520 --> 00:07:41.350
并重写调用方法

00:07:41.350 --> 00:07:43.340
第三项任务也解决了

00:07:43.340 --> 00:07:47.470
我们根据这些 Audio Focus 状态变化修改了媒体播放行为

00:07:47.470 --> 00:07:49.240
看来只有一项任务要完成了

00:07:49.240 --> 00:07:52.285
当我们播放完音频后 我们需要释放 Audio Focus

00:07:52.285 --> 00:07:54.944
现在再回到“Managing Audio Focus”教程

00:07:54.944 --> 00:07:59.710
这里有个关于放弃 Audio Focus 的实例代码段

00:07:59.710 --> 00:08:02.010
代码段上面的这段内容指出

00:08:02.010 --> 00:08:05.540
当你播放完音频后 应该放弃 Audio Focus

00:08:05.540 --> 00:08:08.600
这样就可以取消注册指定的监听器

00:08:08.600 --> 00:08:10.375
即这里的输入参数

00:08:10.375 --> 00:08:13.625
这样我们就不会再获得 Focus 状态变化方面的通知

00:08:13.625 --> 00:08:17.545
文档同时还指出 如果你请求了 transient focus（我们的确请求了）

00:08:17.545 --> 00:08:21.580
则允许设备上受到干扰的应用继续播放音频

00:08:21.580 --> 00:08:24.250
我们复制这段代码并粘贴到我们的应用中

00:08:24.250 --> 00:08:26.870
应该将这行代码放在 NumbersActivity 的什么地方呢？

00:08:26.870 --> 00:08:28.850
结束播放音频文件后

00:08:28.850 --> 00:08:30.110
我们应该还具有 Audio Focus

00:08:30.110 --> 00:08:33.559
因此我们可以将其粘贴到 MediaPlayer 的 onCompletion 回调中

00:08:33.559 --> 00:08:36.799
但是我们还要注意下 Activity 生命周期

00:08:36.799 --> 00:08:38.020
因此我们将代码再往前添加下

00:08:38.020 --> 00:08:40.909
当该 Activity 停止并对用户隐藏了

00:08:40.909 --> 00:08:43.400
我们就停止并清空 MediaPlayer

00:08:43.400 --> 00:08:46.390
因此我们希望在两个位置都放弃 Audio Focus

00:08:46.390 --> 00:08:50.190
而这两个位置已经调用了 releaseMediaPlayer() 方法

00:08:50.190 --> 00:08:53.340
因此我们直接在辅助方法 releaseMediaPlayer() 中

00:08:53.340 --> 00:08:54.250
放弃 Audio Focus

00:08:55.520 --> 00:08:56.940
在这个方法的底部

00:08:56.940 --> 00:08:59.500
我将添加这行放弃 Audio Focus 的代码

00:08:59.500 --> 00:09:01.840
并添加到 if 语句块中

00:09:01.840 --> 00:09:04.260
我们知道可以在这里释放 Audio Focus 了

00:09:04.260 --> 00:09:06.150
因为我们不再播放音频了

00:09:07.450 --> 00:09:10.060
我将我们的变量名称从 am

00:09:10.060 --> 00:09:12.470
改成 mAudioManager

00:09:12.470 --> 00:09:16.830
同时将监听器名称改成 mOnAudioFocusChangeListener

00:09:16.830 --> 00:09:19.160
并更新这部分的注释

00:09:19.160 --> 00:09:20.150
 209
00:09:20,150 --&gt; 00:09:22,210
第四步操作完毕了

00:09:22.210 --> 00:09:24.220
我知道要更改很多代码

00:09:24.220 --> 00:09:26.100
但是现在所有四步都完成了

00:09:26.100 --> 00:09:27.350
表扬下自己吧

00:09:28.720 --> 00:09:31.351
如果还剩下任何变量需要更新

00:09:31.351 --> 00:09:33.045
我们在这里更改下

00:09:33.045 --> 00:09:34.784
没有错误了

00:09:34.784 --> 00:09:36.680
现在检查下应用是否还能正常运转

00:09:36.680 --> 00:09:37.230
我们运行下

00:09:38.420 --> 00:09:40.050
这是应用在设备上的运行效果

00:09:40.050 --> 00:09:43.145
我们看看行为是否依然像预期的那样

00:09:43.145 --> 00:09:45.445
进入 NumbersActivity

00:09:45.445 --> 00:09:50.074
&gt;&gt;[FOREIGN] &gt;&gt; 不错

00:09:50.074 --> 00:09:52.720
当另一个音频开始播放时 当前的音频就会停止

00:09:52.720 --> 00:09:55.170
但我不会再去检查所有测试用例了

00:09:55.170 --> 00:09:57.950
如果你想测试下我们是否正确地处理了音频干扰情况

00:09:57.950 --> 00:10:00.350
你应该尝试在来电期间播放下音频

00:10:00.350 --> 00:10:02.120
甚至可以在尝试播放音频的时候

00:10:02.120 --> 00:10:03.750
拉下通知栏

00:10:03.750 --> 00:10:06.360
理想情况下 你需要测试下 if else 语句中的

00:10:06.360 --> 00:10:07.560
每个用例

00:10:07.560 --> 00:10:10.230
确保当我们失去 Audio Focus 后 我们可以暂停音频

00:10:10.230 --> 00:10:13.050
当我们获得 Audio Focus 后 可以继续播放

00:10:13.050 --> 00:10:14.572
NumbersActivity 能正常运转后

00:10:14.572 --> 00:10:17.360
我将对其他 Activity 应用相同的更改

00:10:17.360 --> 00:10:19.130
这些是 ColorsActivity

00:10:19.130 --> 00:10:23.390
FamilyActivity PhrasesActivity 的代码更改情况

00:10:24.490 --> 00:10:27.110
要获取解决方案代码的链接 请参阅下面的备注

00:10:28.460 --> 00:10:30.875
哇 好大的功能啊

00:10:30.875 --> 00:10:34.040
祝贺大家 终于完成了应用 Audio Focus 编程任务

