WEBVTT
Kind: captions
Language: zh-CN

00:00:00.360 --> 00:00:03.290
你可能已经注意到网络代码中 存在许多不同类型的

00:00:03.290 --> 00:00:06.750
例外 但是 你不知道它们有何作用

00:00:06.750 --> 00:00:10.500
之前我们没有正式地介绍过 它们 所以我们现在来了解一下

00:00:10.500 --> 00:00:14.080
你第一次见到例外是在 微学位课程的第一节课

00:00:14.080 --> 00:00:17.670
也就是我们构建 Just Java coffee ordering 应用时

00:00:17.670 --> 00:00:20.740
现在此应用运行出现例外并且 已崩溃

00:00:20.740 --> 00:00:24.340
为了调试程序 我们打开了 Android 日志

00:00:24.340 --> 00:00:29.000
来显示堆栈跟踪 然后发现当在主活动中

00:00:29.000 --> 00:00:32.790
无法找到 submitOrder 方法时 就会引发 IllegalStateException

00:00:34.480 --> 00:00:36.700
我们来看一些关于 例外的文档

00:00:37.760 --> 00:00:41.220
Java 方法运行失败时 或 遇到意外状态时

00:00:41.220 --> 00:00:45.570
会引发例外 简称例外事件

00:00:45.570 --> 00:00:49.020
例外是基本的错误 但例外也会被捕获到或

00:00:49.020 --> 00:00:53.430
包含到例外类的实际 实例中 其中包含了关于

00:00:53.430 --> 00:00:57.090
出现了什么错误以及当时系统 发生了什么状况的信息

00:00:57.090 --> 00:00:58.250
例如 如果看左边

00:00:58.250 --> 00:01:02.130
你会发现存在许多 特殊的异常类型

00:01:02.130 --> 00:01:05.209
这些异常类型实际上是从 例外超类中延伸而来

00:01:05.209 --> 00:01:08.760
继承的一个很好的例子就是 在 Java 框架中使用

00:01:08.760 --> 00:01:09.800
换言之

00:01:09.800 --> 00:01:14.380
所有这些特定类都是 例外基类的子类

00:01:14.380 --> 00:01:17.820
例如 这里我们有 IllegalStateException 或

00:01:17.820 --> 00:01:19.780
NullPointerException

00:01:19.780 --> 00:01:22.710
在本节课早些时候 我们还了解了 SecurityException

00:01:22.710 --> 00:01:24.970
当时我们的 Soonami 应用缺少 Internet 权限

00:01:26.180 --> 00:01:28.959
现在你可以根据自己的目的 创建新的例外类

00:01:30.050 --> 00:01:33.727
例如 我们可以创建一个 InvalidEarthquakeException 并

00:01:33.727 --> 00:01:35.350
正常对其进行定义

00:01:35.350 --> 00:01:36.720
创建自定义类

00:01:36.720 --> 00:01:41.160
然后将该自定义类仅作为 例外基类的扩展

00:01:41.160 --> 00:01:43.910
从那里 我们可以自定义 例外 从而保留

00:01:43.910 --> 00:01:47.190
关于无效地震场景的 明确信息

00:01:48.350 --> 00:01:51.900
因此 作为开发人员 你可以编写 声明将会引发例外的

00:01:51.900 --> 00:01:53.400
一种方法

00:01:53.400 --> 00:01:57.220
这意味着此方法中的代码 要么会生成

00:01:57.220 --> 00:02:01.100
例外来指定 特殊条件或者

00:02:01.100 --> 00:02:05.050
更常见的情况是 调用引发例外的方法

00:02:05.050 --> 00:02:08.840
这表示 Android 在运行时尝试 执行某些代码 但遇到了

00:02:08.840 --> 00:02:12.460
问题 因此通过引发例外 通知该问题

00:02:13.750 --> 00:02:17.850
值得注意的是 如果 引发了例外 还意味着

00:02:17.850 --> 00:02:21.640
引发例外的代码行后面的 代码将无法执行

00:02:22.670 --> 00:02:25.000
所以在 Java 代码中要怎么做?

00:02:25.000 --> 00:02:27.890
我希望大家能够注意 两点区别

00:02:27.890 --> 00:02:32.049
第一 无论要在 Java 代码的 哪个地方造成或

00:02:32.049 --> 00:02:35.294
引发例外 都要使用关键字 throw

00:02:35.294 --> 00:02:36.916
例如在这个示例中

00:02:36.916 --> 00:02:41.010
我们希望引发 InvalidPurchase Exception() 因为

00:02:41.010 --> 00:02:45.760
我们发现在 completePurchase() 方法中出现了错误

00:02:45.760 --> 00:02:48.380
第二 这一点 更加微妙

00:02:48.380 --> 00:02:52.940
在任何时候 如果代码引发的例外 不是错误的后代或

00:02:52.940 --> 00:02:56.920
执行时期例外类 我们都必须 在方法签名中明确指出

00:02:56.920 --> 00:03:00.350
我们的方法会引发 这种例外

00:03:00.350 --> 00:03:04.120
就 Java 编程而言 这被称为受检例外并

00:03:04.120 --> 00:03:08.120
意味着任何调用或 使用我们的方法的代码

00:03:08.120 --> 00:03:12.440
都必须处理此例外 例如 在 try 区块调用我们的方法

00:03:12.440 --> 00:03:14.660
这是 Java 编译器的强制性要求

00:03:14.660 --> 00:03:18.740
也就是说 无论谁调用 completePurchase 方法 都必须

00:03:18.740 --> 00:03:23.480
制定备份方案 以防引发或出现 InvalidPurchase 例外

00:03:23.480 --> 00:03:25.960
我们会在下个视频中介绍 如何处理例外

00:03:27.290 --> 00:03:30.790
如果你想了解关于 非受检例外和受检例外的

00:03:30.790 --> 00:03:35.040
更多详细内容 请参阅本视频下方 注释中链接的教程

00:03:35.040 --> 00:03:36.790
还有一点需要特别注意

00:03:36.790 --> 00:03:38.700
虽然对于在 Java 中 使用例外的方法有一个

00:03:38.700 --> 00:03:42.000
标准的框架 但这并不 意味着每次

00:03:42.000 --> 00:03:44.870
出现错误时都要 引发例外

00:03:44.870 --> 00:03:48.130
这种情况需要开发人员 自行衡量

00:03:48.130 --> 00:03:52.260
理论上 如果发现问题或 特殊情况 就应该在代码中

00:03:52.260 --> 00:03:54.190
尝试对其进行得体的处理

00:03:54.190 --> 00:03:57.680
例如 提供一些合理的 默认行为 并且

00:03:57.680 --> 00:04:00.200
如果可能的话就继续执行

00:04:00.200 --> 00:04:02.810
我们称此为静默失败

00:04:02.810 --> 00:04:06.680
但是 如果我们认为继续 保持错误状态是

00:04:06.680 --> 00:04:11.030
不利的 那么我们可能会决定最好 通过引发例外向调用代码

00:04:11.030 --> 00:04:12.770
通知此错误

00:04:12.770 --> 00:04:15.050
这一点我们在视频中已经看到了

00:04:15.050 --> 00:04:18.459
在 Soonami 应用的案例中 当我们 尝试从互联网请求地震

00:04:18.459 --> 00:04:23.040
数据时 Android 框架代码 会引发 SecurityException

00:04:23.040 --> 00:04:25.660
这种情况下 引发 例外并造成应用

00:04:25.660 --> 00:04:29.860
崩溃比没有 Internet 权限 仍继续执行更好

00:04:29.860 --> 00:04:32.610
如果现在 Android 框架 代码静默失败

00:04:32.610 --> 00:04:35.560
那么作为开发人员的我们可能会 非常困惑

00:04:35.560 --> 00:04:38.600
为什么我们收到了 服务器的响应

00:04:38.600 --> 00:04:42.010
在 Soonami 和 Quick Report 应用的案例中 我们不会真的

00:04:42.010 --> 00:04:46.210
创建自己的自定义例外或 故意引发例外

00:04:46.210 --> 00:04:50.620
但我们会调用可以引发例外的 Android 框架代码

00:04:50.620 --> 00:04:53.330
而且我们还需要合理地处理 这些例外

00:04:53.330 --> 00:04:54.340
我们下节课再讲这个内容吧

