WEBVTT
Kind: captions
Language: zh-CN

00:00:00.410 --> 00:00:03.650
所以 当出现错误且 产生例外时

00:00:03.650 --> 00:00:08.530
作为开发人员 我们要通过提供 备份方案进行处理

00:00:08.530 --> 00:00:09.980
我们捕获异常并

00:00:09.980 --> 00:00:14.680
提供一些合理的默认 行为 否则应用可能会崩溃

00:00:14.680 --> 00:00:15.594
换言之

00:00:15.594 --> 00:00:19.854
一些应用崩溃可能仅仅是因为 没有捕获例外

00:00:19.854 --> 00:00:23.698
所以 为了完成此操作 我们将要 了解 Java 中称为 try catch 区块的

00:00:23.698 --> 00:00:25.598
相关内容

00:00:25.598 --> 00:00:28.699
Try 的意思是试着 执行一组语句

00:00:28.699 --> 00:00:33.254
包括调用可能引发 例外的方法

00:00:33.254 --> 00:00:36.216
例外引发之后 将其捕获

00:00:36.216 --> 00:00:40.367
如果没有人捕获该例外 应用将会崩溃

00:00:40.367 --> 00:00:41.377
你没事吧 Joe?

00:00:41.377 --> 00:00:42.010
— 我没事

00:00:42.010 --> 00:00:45.570
无论是否引发 例外

00:00:45.570 --> 00:00:49.250
我们都可以在 finally 区块 完成代码执行

00:00:49.250 --> 00:00:52.848
因此 首先要执行一些可能 引发例外的操作

00:00:52.848 --> 00:00:54.918
如果例外引发 则将其捕获

00:00:54.918 --> 00:00:57.009
最后 无论是否发生 例外 都执行

00:00:57.009 --> 00:00:58.990
一些代码

00:00:58.990 --> 00:01:00.880
我们应该为大家展示 这部分的一些代码

00:01:00.880 --> 00:01:02.210
是的

00:01:02.210 --> 00:01:04.917
我们来展示吧 — 在 Tsunami 应用中 存在多个

00:01:04.917 --> 00:01:07.560
try catch 区块的示例

00:01:07.560 --> 00:01:10.540
我们来看一下在创建你自己 的方法中的一个区块

00:01:10.540 --> 00:01:13.770
此方法的目的是为 所提供的输入字符串 URL

00:01:13.770 --> 00:01:16.570
返回 URL 对象

00:01:16.570 --> 00:01:21.385
理论上 我们仅需调用 URL 构造函数并传入字符串 URL

00:01:21.385 --> 00:01:25.502
但 Android Studio 通过 红色波浪线通知我们

00:01:25.502 --> 00:01:28.002
检测到的错误情况

00:01:28.002 --> 00:01:31.638
也就是说 我们有一个 未处理的例外

00:01:31.638 --> 00:01:34.500
其类型为格式错误的 URL 例外

00:01:34.500 --> 00:01:38.800
这意味着 URL 构造函数 引发了一个格式错误的 URL 例外 并且

00:01:38.800 --> 00:01:41.040
我们需要捕获并处理此错误

00:01:41.040 --> 00:01:43.810
否则 我们无法构建应用 也 无法在设备上运行

00:01:44.890 --> 00:01:47.000
你可以通过查看文档

00:01:47.000 --> 00:01:50.760
检查所有构造函数或方法调用 是否会引发例外

00:01:50.760 --> 00:01:53.961
例如 如果我们访问 URL 参考文档

00:01:53.961 --> 00:01:57.789
将会看到接受字符串作为 通过 MalformedURLException 的

00:01:57.789 --> 00:01:59.250
输入的 URL 构造函数

00:01:59.250 --> 00:02:03.719
如果输入参数无法 转换成 URL

00:02:03.719 --> 00:02:06.062
则该 URL 为 MalformedURL

00:02:06.062 --> 00:02:10.880
要修复代码 可以使用 快捷键 Alt+Enter 进行快速修复

00:02:10.880 --> 00:02:14.060
我们可以选择 surround with try catch 选项 之后

00:02:14.060 --> 00:02:16.790
Android Studio 将会自动 更新代码

00:02:16.790 --> 00:02:18.163
很不错吧?

00:02:18.163 --> 00:02:23.156
现在我们将得到一个关键字 try 后面跟着一个左大括号

00:02:23.156 --> 00:02:25.750
在 try 区块中 放入可以 引发例外的

00:02:25.750 --> 00:02:27.330
全部代码

00:02:27.330 --> 00:02:31.268
通常情况下 这是保持此区块中 的代码精益的好方法

00:02:31.268 --> 00:02:33.368
在这里 你并不需要采用此操作的全部方法

00:02:33.368 --> 00:02:36.220
然后 使用右大 括号结束

00:02:36.220 --> 00:02:40.310
接下来就是关键字 catch 和一对包含捕获例外的

00:02:40.310 --> 00:02:43.905
精确数据类型的 圆括号

00:02:43.905 --> 00:02:47.555
在此示例中 MalformedURLException 位于例外对象 e 的

00:02:47.555 --> 00:02:49.725
变量名内

00:02:49.725 --> 00:02:52.400
接下来是一个左大括号 我们将在此处理例外

00:02:52.400 --> 00:02:57.835
e.printStackTrace 将以详细信息 格式打印出错误堆叠

00:02:57.835 --> 00:03:01.505
另一选项则用于通过 Androids log 方法记录区域

00:03:01.505 --> 00:03:04.937
并且包含自己的日志标签 和自定义消息

00:03:04.937 --> 00:03:08.305
log.e 方法可以将 例外视为第三个参数

00:03:09.480 --> 00:03:12.540
总的来说 如果 URL 构造函数中一切正常

00:03:12.540 --> 00:03:16.570
那么就不会引发例外并且 不会在 catch 区块进行任何运行

00:03:16.570 --> 00:03:19.800
但是 如果 try 区块中的代码 引发了例外 我们会立即

00:03:19.800 --> 00:03:24.120
跳到包含该例外的 cash 区块 并在那里执行代码

00:03:24.120 --> 00:03:25.980
然后 退出 try catch 语句并

00:03:25.980 --> 00:03:28.679
继续逐行执行 代码

00:03:29.870 --> 00:03:34.182
请注意 URL 变量已在使用 try catch 区块之前进行初始化

00:03:34.182 --> 00:03:36.680
在此 我们必须考虑变量的范围

00:03:36.680 --> 00:03:39.720
如果在 try 区块中定义 URL 变量

00:03:39.720 --> 00:03:43.600
语句完成之后将无法访问 URL 变量

00:03:43.600 --> 00:03:47.060
所以 如果想要在方法结束后 在 try catch 语句之外

00:03:47.060 --> 00:03:48.930
参考 URL 变量

00:03:48.930 --> 00:03:53.050
则必须在语句之外初始化 URL 变量

00:03:53.050 --> 00:03:57.130
在这种情况下 我们可以仅仅将 URL 设置为 null 这表示一个空值

00:03:57.130 --> 00:04:01.162
现在 我们已经了解 在你需要将 代码包含到 try catch 语句中时

00:04:01.162 --> 00:04:02.840
Android Studio 会如何进行通知

00:04:02.840 --> 00:04:04.360
如果要了解更多信息

00:04:04.360 --> 00:04:06.289
可以查看官方的 Java 文档

00:04:07.290 --> 00:04:10.260
下一个示例稍微 有一点复杂

00:04:10.260 --> 00:04:13.870
此示例表明你可以在 try 区块中 设置任意多个代码行

00:04:13.870 --> 00:04:17.459
如果有任何代码行引发了 例外 则会停止执行

00:04:17.459 --> 00:04:21.300
try 区块中的该语句并 直接跳到 catch 区块

00:04:21.300 --> 00:04:23.870
如你所见 如果需要 在这里你可以 并且应该设置

00:04:23.870 --> 00:04:27.860
多个 catch 区块来处理 不同类型的错误

00:04:27.860 --> 00:04:31.320
在此 代码捕获索引值 超出范围的例外并

00:04:31.320 --> 00:04:33.030
打印系统日志消息

00:04:33.030 --> 00:04:37.330
该代码还捕获 IO 例外并 打印不同的日志消息

00:04:37.330 --> 00:04:39.450
现在 根据所引发的 例外

00:04:39.450 --> 00:04:42.690
将会跳到其中一个 catch 区块中 但不会跳到两个 catch 区块中

00:04:44.430 --> 00:04:47.490
这样便可以了解为何在 try 区块执行所有代码

00:04:47.490 --> 00:04:49.260
没有保障

00:04:49.260 --> 00:04:52.360
有时候 即使引发了例外 你也清除了

00:04:52.360 --> 00:04:53.950
需要进行的操作

00:04:53.950 --> 00:04:57.340
因此 无论是否引发 例外 始终会执行

00:04:57.340 --> 00:04:58.440
finally 区块

00:04:59.730 --> 00:05:01.900
在结束此讨论之前

00:05:01.900 --> 00:05:06.180
我想解释一下处理检查 例外的一个最终方法

00:05:06.180 --> 00:05:10.910
如你所见 在这里 通过修改 createURL 方法 即方法签名

00:05:10.910 --> 00:05:15.160
你可以通过声明你的 方法可能会引发例外

00:05:15.160 --> 00:05:17.710
从而需要调用方法 进行处理

00:05:17.710 --> 00:05:20.390
以便将例外处理递延 到调用链

00:05:21.430 --> 00:05:24.940
如果例外是由内部的辅助方法引发 的 也可以使用这种方式进行处理

00:05:24.940 --> 00:05:27.840
你希望其他地方也在 try catch 中对例外进行处理

00:05:27.840 --> 00:05:32.480
例如 无论是谁调用 createUrl 方法 现在都需要围绕此方法

00:05:32.480 --> 00:05:37.650
调用的 try catch 区块 并且 必须捕获 MalformedURLException

00:05:37.650 --> 00:05:40.570
我们可以在 doInBackground 方法 中了解这种情况

00:05:40.570 --> 00:05:44.030
就 Tsunami 应用的目的而言 如果你调用了某些引发例外的

00:05:44.030 --> 00:05:47.960
Android 框架代码 你应该在例外 发生时将其捕获

00:05:47.960 --> 00:05:50.700
并进行处理而不是递延到 以后处理

