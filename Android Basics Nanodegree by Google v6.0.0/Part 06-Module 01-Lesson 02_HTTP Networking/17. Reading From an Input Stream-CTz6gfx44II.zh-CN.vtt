WEBVTT
Kind: captions
Language: zh-CN

00:00:00.340 --> 00:00:02.520
每一段数据 无论是文本 还是图片

00:00:02.520 --> 00:00:05.810
实际上都存储在字节大小的块中

00:00:05.810 --> 00:00:09.362
在应用接收数据时 数据以输入流 的形式进入

00:00:09.362 --> 00:00:11.850
即 由字节组成的流

00:00:11.850 --> 00:00:16.149
输入流是抽象的 也就是说 输入流会隐藏详细信息

00:00:16.149 --> 00:00:20.890
例如 这些字节是否表示文件或网页 甚至是媒体内容

00:00:20.890 --> 00:00:23.150
它只是一个信息流

00:00:23.150 --> 00:00:26.360
然后 在接收到输入流之后 需要把字节重组为

00:00:26.360 --> 00:00:29.090
应用可以使用的有意义的 内容

00:00:29.090 --> 00:00:33.070
对于文本数据 需要将字节 重新转换回字符

00:00:33.070 --> 00:00:35.260
而这正是 Buffered Reader 类 的作用

00:00:36.260 --> 00:00:38.580
然后 我们构建一个 JSON 响应字符串

00:00:38.580 --> 00:00:40.809
字符串本质上就是由字符 组成的流

00:00:42.080 --> 00:00:45.070
我们来看看这段代码的 makeHttpRequest 方法

00:00:45.070 --> 00:00:47.330
是如何完成转换过程的

00:00:47.330 --> 00:00:53.370
注意 在开始时有两个变量 HttpURLConnection 类型的 urlConnection

00:00:53.370 --> 00:00:56.010
和 InputStream 类型的 inputStream

00:00:56.010 --> 00:00:58.180
在某些情况下 函数并不返回

00:00:58.180 --> 00:01:02.302
字符串等最终结果 而是 返回一个 inputStream

00:01:02.302 --> 00:01:06.430
利用 inputStream 一次可以取回 一大块数据信息

00:01:06.430 --> 00:01:09.700
它适用于流的返回数据过多 或流代表的数据源

00:01:09.700 --> 00:01:13.434
需要在一段时间内分批 提交数据的情况

00:01:13.434 --> 00:01:16.822
而用于获取 JSON 数据的 HttpURLConnection 类

00:01:16.822 --> 00:01:19.479
就是通过 inputStream 来返回 服务器响应的

00:01:21.000 --> 00:01:24.111
接下来 我们要在一个方法的帮助下 读取来自

00:01:24.111 --> 00:01:25.120
inputStream 的数据

00:01:25.120 --> 00:01:27.400
让我们跳转到 readFromStream 方法

00:01:27.400 --> 00:01:31.350
记得之前说过 inputStream 实际上并不会 返回数字或字母等

00:01:31.350 --> 00:01:32.890
可读字符

00:01:32.890 --> 00:01:35.820
而是返回原始的二进制 0 1 数据

00:01:35.820 --> 00:01:39.860
而且并不会具体说明数据 所代表的含义

00:01:39.860 --> 00:01:44.930
数据可能是一张图片、一段音频或一些 需要解析的 geoJSON 数据

00:01:44.930 --> 00:01:48.020
在这里 我们知道 inputStream 返回的数据

00:01:48.020 --> 00:01:51.340
确实只是文本 我们可以利用 inputStreamReader

00:01:51.340 --> 00:01:56.120
处理从原始数据到人类可读字符 的翻译过程

00:01:56.120 --> 00:01:59.590
但 InputStreamReader 一次只允许 读取一个字符

00:01:59.590 --> 00:02:03.190
这可能导致较为严重的性能问题 具体取决于

00:02:03.190 --> 00:02:06.760
底层 inputStream 实际提供数据的方式

00:02:06.760 --> 00:02:09.520
例如 如果一次可以从计算机硬盘中读取 较大的数据块

00:02:09.520 --> 00:02:12.560
那么检索数据的过程 就可以很快

00:02:12.560 --> 00:02:15.495
但是 如果一次只能从硬盘中 读取一个字符的数据

00:02:15.495 --> 00:02:17.420
就会耗费很长时间

00:02:17.420 --> 00:02:21.988
为避免这种情况 可以将 inputStreamReader 包装到 BufferedReader 中

00:02:21.988 --> 00:02:25.040
BufferedReader 在接收到对某个 字符的请求后

00:02:25.040 --> 00:02:28.460
会读取并保存该字符前后的 一大块数据

00:02:28.460 --> 00:02:30.230
当继续请求另一个 字符时

00:02:30.230 --> 00:02:33.530
BufferedReader 就能够利用提前 读取的数据

00:02:33.530 --> 00:02:37.730
来满足请求 而无需再回到 inputStreamReader

00:02:37.730 --> 00:02:41.380
如你所见 为了开始从 inputStream 中 读取数据

00:02:41.380 --> 00:02:45.040
我们将 inputStream 作为构造函数的一个参数 传递给 InputStreamReader

00:02:45.040 --> 00:02:46.210
实例

00:02:46.210 --> 00:02:50.257
同时还为构造函数提供了一个字符集  简称 Charset

00:02:50.257 --> 00:02:54.680
Charset 指定如何将 inputStream 的 原始数据逐个字节

00:02:54.680 --> 00:02:56.405
翻译为可读字符

00:02:56.405 --> 00:03:00.693
也就是说 Charset 知道如何将各个字节 解码为人类可读的

00:03:00.693 --> 00:03:03.347
特定字符 如大写 A 或等于符号

00:03:03.347 --> 00:03:05.900
UTF-8 是用于 网络上

00:03:05.900 --> 00:03:09.100
能够找到的所有文本 的 Unicode 字符编码

00:03:09.100 --> 00:03:12.200
最后 将 InputStreamReader 包装到 BufferedReader 中

00:03:12.200 --> 00:03:14.810
就可以开始读取代码了

00:03:14.810 --> 00:03:19.709
好了 我知道这些包装和层 可能有些难以理解

00:03:19.709 --> 00:03:22.599
把 inputStream 包装到 inputStreamReader 中

00:03:22.599 --> 00:03:24.300
而后者又包装在 BufferedReader 中?

00:03:24.300 --> 00:03:25.020
能否用一种

00:03:25.020 --> 00:03:28.850
更简单的方式来读取 HttpURLConnection 返回的数据呢?

00:03:28.850 --> 00:03:29.890
的确可以

00:03:29.890 --> 00:03:33.770
用一种读取方法读取响应中的所有文本 似乎很方便

00:03:33.770 --> 00:03:37.120
但问题是 这种方法 无法重用

00:03:37.120 --> 00:03:39.550
因此 通常不会预先构建 从头至尾的解决方案

00:03:39.550 --> 00:03:43.020
而是利用强大的编程框架 和各类库来提供

00:03:43.020 --> 00:03:46.510
能够以多种不同方式进行结合的 独立部分

00:03:46.510 --> 00:03:50.610
就我们的例子而言 在 Readers 中的 各种流链相对较长

00:03:50.610 --> 00:03:53.470
但此后会遇到需要 以不同配置方式

00:03:53.470 --> 00:03:55.960
来组合这些流 的情况

00:03:55.960 --> 00:03:58.810
届时 与所收获的灵活性相比 现在忍受的麻烦

00:03:58.810 --> 00:04:00.640
也都是值得的

00:04:00.640 --> 00:04:03.470
为测试你对于这些类的 必要性的理解

00:04:03.470 --> 00:04:08.040
请用自己的话描述 InputStream 的用途是什么?

00:04:08.040 --> 00:04:09.766
以及 BufferedReader 的用途是什么?

00:04:09.766 --> 00:04:12.993
可查看测验下方 链接的资源

00:04:12.993 --> 00:04:15.778
在明确 HTTP 请求 成功后

00:04:15.778 --> 00:04:19.730
我们可以使用 BufferedReader 从 inputStream 中读取结果

00:04:19.730 --> 00:04:23.640
然后将其转换为字符串 并解析 JSON

00:04:23.640 --> 00:04:27.460
那么 InputStream 的用途 是什么?

00:04:27.460 --> 00:04:30.218
相似地 BufferedReader 的用途是什么?

