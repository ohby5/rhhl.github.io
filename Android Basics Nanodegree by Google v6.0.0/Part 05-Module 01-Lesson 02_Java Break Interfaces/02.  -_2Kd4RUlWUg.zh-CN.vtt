WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.929
“接口”就像是某假想类的外立面或者轮廓

00:00:05.929 --> 00:00:10.964
其的唯一目的就是被其它类继承

00:00:10.964 --> 00:00:13.185
它只定义需要做什么

00:00:13.185 --> 00:00:15.280
而不是如何去做

00:00:15.279 --> 00:00:18.570
也就是说 接口会列出类中需要包含的方法

00:00:18.570 --> 00:00:22.454
但不包括实现代码等

00:00:22.454 --> 00:00:24.479
这些方法的具体实现

00:00:24.480 --> 00:00:28.594
是由应用了这个接口的类去负责的

00:00:28.594 --> 00:00:30.794
一旦你在一个类中实现了该接口

00:00:30.795 --> 00:00:34.320
你就可以像往常一样开始实例化对象

00:00:34.320 --> 00:00:39.615
Java 引入接口就是为了解决多重继承的问题

00:00:39.615 --> 00:00:43.435
一个类可以被多个类扩展

00:00:43.435 --> 00:00:48.070
但是一个子类仅允许扩展一个父类

00:00:48.070 --> 00:00:51.405
但接口却不受此限制

00:00:51.405 --> 00:00:56.100
这就意味着 一个类可以实现多个接口

00:00:56.100 --> 00:01:01.230
从而使得设计更加灵活 同时也消除了多重继承的歧义问题

00:01:01.229 --> 00:01:03.209
我们来看一个例子

00:01:03.210 --> 00:01:07.159
想象一下 你要负责实现一个叫做 Caravan 的类

00:01:07.159 --> 00:01:10.319
我们知道 caravan 是半车半房的旅行拖车

00:01:10.319 --> 00:01:13.604
那如果你有一个类是车 一个类是房

00:01:13.605 --> 00:01:17.659
却也知道不能同时扩展两个类

00:01:17.659 --> 00:01:20.859
这时 引入接口就是一个好的解决方案

00:01:20.859 --> 00:01:24.599
比如 可移动类接口就是个不错的接口

00:01:24.599 --> 00:01:28.509
它将对任何可移动的类 (比如“车”类) 

00:01:28.510 --> 00:01:30.540
所应该包含的方法进行定义

00:01:30.540 --> 00:01:34.065
另一个接口叫做可居住的接口

00:01:34.064 --> 00:01:39.344
它会对所有可居住类所包含的所有方法进行定义

00:01:39.344 --> 00:01:41.295
一旦我们定义了这两个接口

00:01:41.295 --> 00:01:45.859
就可以在 Caravan 类中同时实现这两者

00:01:45.859 --> 00:01:47.984
我们来看下对应的 Java 代码

00:01:47.984 --> 00:01:51.825
在 Java 中创建接口的方法与创建类非常相似

00:01:51.825 --> 00:01:54.915
只需将关键词 class 替换为 interface 即可

00:01:54.915 --> 00:01:57.000
在接口内 你可以看到

00:01:57.000 --> 00:01:59.745
我们列出了方法签名

00:01:59.745 --> 00:02:01.710
但没有列出任何实现代码

00:02:01.709 --> 00:02:05.399
因为后者是由实现接口的类负责完成的

00:02:05.400 --> 00:02:07.500
可居住接口也是一样

00:02:07.500 --> 00:02:11.219
本例中的可居住接口仅包括 canFit 方法

00:02:11.219 --> 00:02:13.259
创建好这两个接口

00:02:13.259 --> 00:02:16.169
我们就可以开始实现 Caravan 类了

00:02:16.169 --> 00:02:20.699
它会实现可居住和可移动这两个接口

00:02:20.699 --> 00:02:22.589
请注意 这里我所使用的关键词是 implements

00:02:22.590 --> 00:02:25.050
而非由父类继承子类时 

00:02:25.050 --> 00:02:27.055
所用的关键词 extends  

00:02:27.055 --> 00:02:30.580
implements 是从接口继承时所使用的关键词

00:02:30.580 --> 00:02:32.415
在实现了这些接口之后

00:02:32.414 --> 00:02:34.394
我们必须执行这两个接口所包含的

00:02:34.395 --> 00:02:37.980
每个方法的代码

00:02:37.979 --> 00:02:40.780
如可移动接口所包含的移动方法

00:02:40.780 --> 00:02:44.974
和可居住接口所包含的 canFit 方法

00:02:44.974 --> 00:02:46.560
如果任一接口中的任何方法

00:02:46.560 --> 00:02:49.800
未在 Caravan 类中实现

00:02:49.800 --> 00:02:52.050
将会显示编译错误

00:02:52.050 --> 00:02:55.530
请注意 继承接口并没有像之前我们扩展类时一样

00:02:55.530 --> 00:02:59.370
为我们省去了重写代码的麻烦

00:02:59.370 --> 00:03:02.159
这是因为接口的意义更多地还是在于

00:03:02.159 --> 00:03:05.794
执行一个好的设计 而非帮我们减少代码

00:03:05.794 --> 00:03:08.684
创建接口的做法会迫使任何将要实现该接口的类

00:03:08.685 --> 00:03:12.530
先实现一定数量的方法

00:03:12.530 --> 00:03:13.789
这就意味着

00:03:13.789 --> 00:03:15.870
如果将来你看到某个类在实现某接口

00:03:15.870 --> 00:03:18.944
即便不看那个类的代码

00:03:18.944 --> 00:03:23.965
也可以确信 该类已经包含有接口内的所有方法了

00:03:23.965 --> 00:03:25.819
让我们来做个总结

00:03:25.819 --> 00:03:28.919
我们知道接口定义了类要做什么

00:03:28.919 --> 00:03:30.559
而不是怎样做

00:03:30.560 --> 00:03:34.409
我们也看到创建一个接口和创建一个类非常相似

00:03:34.409 --> 00:03:36.944
也了解了接口唯一的目的就是

00:03:36.944 --> 00:03:40.134
被一个或多个类实现

00:03:40.134 --> 00:03:41.849
也就是说 你不可以直接从接口

00:03:41.849 --> 00:03:44.489
创建一个实例或对象

00:03:44.490 --> 00:03:46.420
你必须首先通过类来实现它

00:03:46.419 --> 00:03:48.500
然后才可以从中创建对象

00:03:48.500 --> 00:03:51.259
我们也知道 实现接口并不意味着要减少代码或者分割

00:03:51.259 --> 00:03:54.000
它更关注的是执行一个好的设计

