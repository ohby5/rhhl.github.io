WEBVTT
Kind: captions
Language: zh-CN

00:00:00.680 --> 00:00:03.570
我们再回到 OnClickListener 文档

00:00:03.570 --> 00:00:06.680
我们发现 Android 对如何监听某个输入事件

00:00:06.680 --> 00:00:09.110
有非常详细的规定

00:00:09.110 --> 00:00:11.110
该方法不能命名为任何其他内容

00:00:11.110 --> 00:00:14.130
必须是 onClick

00:00:14.130 --> 00:00:18.640
只能有一个输入 即被点击的视图 并且没有返回值

00:00:18.640 --> 00:00:21.870
你可以将这里关于 OnClickListener 的概述

00:00:21.870 --> 00:00:26.100
（包括类和方法）想象成合同 作为开发者

00:00:26.100 --> 00:00:29.330
你需要遵守该合同 才能获得点击事件通知

00:00:29.330 --> 00:00:33.360
用更正式的 Java 术语来表示 这就是接口的定义

00:00:33.360 --> 00:00:37.740
在此文档页面的顶部 有个用小字体显示的“接口 (interface)”

00:00:37.740 --> 00:00:40.680
以后 很有可能你会在 Android 中遇到

00:00:40.680 --> 00:00:43.950
另一个组件也叫做接口

00:00:43.950 --> 00:00:44.780
现在

00:00:44.780 --> 00:00:49.290
你可能好奇 为何接口与类不同？

00:00:49.290 --> 00:00:51.490
二者的文档介绍页面看起来非常相似

00:00:51.490 --> 00:00:55.500
在上一门课程中 我们学习了一些类 例如 textView

00:00:55.500 --> 00:00:59.830
其中包含完全实现的状态和方法

00:00:59.830 --> 00:01:02.420
每个方法中都有说明

00:01:02.420 --> 00:01:06.540
现在我们介绍了接口 其中不含状态

00:01:06.540 --> 00:01:09.110
但是却包含方法标记

00:01:09.110 --> 00:01:13.390
方法标记会标明返回值 方法名称

00:01:13.390 --> 00:01:14.560
和输入参数

00:01:14.560 --> 00:01:17.410
结尾是个分号 没有大括号

00:01:17.410 --> 00:01:20.500
中间的代码用来实现该方法

00:01:20.500 --> 00:01:22.900
表明它是个抽象方法

00:01:22.900 --> 00:01:27.060
抽象方法的实现故意留空

00:01:27.060 --> 00:01:30.160
这样如果你想使用该接口

00:01:30.160 --> 00:01:32.790
就可以自己提供特定的说明

00:01:32.790 --> 00:01:34.880
相当于在空白处填上

00:01:34.880 --> 00:01:37.140
当用户点击该视图时你希望发生的情况

00:01:38.240 --> 00:01:42.010
接口中可以存在多个抽象方法

00:01:42.010 --> 00:01:46.720
但是这个 onClickListener 接口示例只有一个抽象方法 即 onClick 方法

00:01:46.720 --> 00:01:49.520
以后我们还会遇到抽象类

00:01:49.520 --> 00:01:53.520
它是一种部分实现的类 包含状态和

00:01:53.520 --> 00:01:57.790
一些完全实现的方法 同时还包含一些

00:01:57.790 --> 00:01:59.770
让其他人去定义行为的抽象方法

00:01:59.770 --> 00:02:02.730
可以将这几个概念想象成是一个连续状态

00:02:02.730 --> 00:02:06.000
接口是完全没有实现 抽象类是部分实现了

00:02:06.000 --> 00:02:08.220
而具体类是完全实现了

00:02:08.220 --> 00:02:11.380
那么为何点击监听器不是具体类呢？

00:02:11.380 --> 00:02:13.347
为何 textView 不是接口呢？

00:02:13.347 --> 00:02:16.520
为何 ViewGroup 是抽象类？

00:02:16.520 --> 00:02:18.990
Android 团队做出这些决策是考虑到

00:02:18.990 --> 00:02:22.730
怎样才能更便于开发者构建应用

00:02:22.730 --> 00:02:25.310
每个开发者都需要在屏幕上显示文本

00:02:25.310 --> 00:02:28.800
所以他们创建了具体 textView 类来实现这一点

00:02:28.800 --> 00:02:31.980
我们可以直接调用方法来更改视图中的文本

00:02:31.980 --> 00:02:36.070
对于这个抽象类示例 我们想要标准化

00:02:36.070 --> 00:02:38.980
作为多个子视图容器的 ViewGroup 的行为

00:02:38.980 --> 00:02:42.130
但是 关于如何在屏幕上放置视图的详情则未定

00:02:42.130 --> 00:02:45.610
并留给子类来确定

00:02:45.610 --> 00:02:47.490
在这种情形下 线性布局和相对布局

00:02:47.490 --> 00:02:50.790
是 ViewGroup 类的子类

00:02:50.790 --> 00:02:55.030
它们各自都可以定义关于视图应该如何放置在屏幕上的规则

00:02:55.030 --> 00:02:58.820
另一方面 Android 团队知道很多开发者可能想要

00:02:58.820 --> 00:03:00.760
自定义点击行为

00:03:00.760 --> 00:03:03.320
所以没必要提供按钮被点击后

00:03:03.320 --> 00:03:04.780
会发生什么情况的默认行为

00:03:04.780 --> 00:03:08.103
但是 Android 团队还是会标准化 onClickListener 的

00:03:08.103 --> 00:03:10.710
方法调用以及类类型

00:03:10.710 --> 00:03:13.010
然后让开发者自己写出

00:03:13.010 --> 00:03:14.690
方法内部的逻辑

00:03:14.690 --> 00:03:15.690
总结下

00:03:15.690 --> 00:03:19.470
如果你在 Android 中采用的是具体类 那么可以直接使用该类

00:03:19.470 --> 00:03:22.490
如果采用的是抽象类 则需要用到子类

00:03:22.490 --> 00:03:25.290
并为抽象方法提供自己的代码

00:03:25.290 --> 00:03:28.260
如果采用的是接口

00:03:28.260 --> 00:03:29.480
则需要提供所有的抽象方法

