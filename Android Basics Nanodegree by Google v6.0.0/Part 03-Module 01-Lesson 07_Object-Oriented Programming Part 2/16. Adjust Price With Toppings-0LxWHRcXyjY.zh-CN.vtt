WEBVTT
Kind: captions
Language: zh-CN

00:00:00.250 --> 00:00:02.250
为了计算订单的正确价格

00:00:02.250 --> 00:00:05.230
我们需要给 calculatePrice 方法输入

00:00:05.230 --> 00:00:09.500
用户选择的配料

00:00:09.500 --> 00:00:12.820
我将在 calculatePrice 方法内

00:00:12.820 --> 00:00:18.340
做繁重的计算 所以它集中了所有相关的逻辑

00:00:18.340 --> 00:00:22.040
通过把所有的东西都整合到这个方法中 如果

00:00:22.040 --> 00:00:25.620
在计算价格时出了问题 我们就可以只检查这个地方的代码

00:00:26.620 --> 00:00:28.340
这更易于管理

00:00:28.340 --> 00:00:29.880
在这个方法中

00:00:29.880 --> 00:00:33.450
我们要找出一杯咖啡的基本价格

00:00:33.450 --> 00:00:35.510
就像我之前向你展示的那样

00:00:35.510 --> 00:00:38.110
如果一杯咖啡加了生奶 那么价格也会增加1美元

00:00:38.110 --> 00:00:41.000
如果加巧克力 它的价格加2美元

00:00:41.000 --> 00:00:43.630
然后 用一杯咖啡的基本价格

00:00:43.630 --> 00:00:47.860
乘以订购的咖啡数量 来计算订单的总价

00:00:47.860 --> 00:00:50.550
首先 让我们把生奶

00:00:50.550 --> 00:00:54.302
和巧克力的复选框信息添加到 calculatePrice 方法中

00:00:54.302 --> 00:00:58.380
我将输入 boolean 类型的 hasWhippedCream 和 hasChocolate

00:00:58.380 --> 00:01:02.570
将实际的 CheckBox 对象传入方法内是没有意义的 因为

00:01:02.570 --> 00:01:06.430
我们只关心这些用于计算价格的 boolean 类型的值

00:01:06.430 --> 00:01:09.560
Android Studio 提示这里有一个错误 因为这个方法签名

00:01:09.560 --> 00:01:10.530
不匹配

00:01:10.530 --> 00:01:13.530
我尝试调用一个方法 这个方法已经定义过了

00:01:13.530 --> 00:01:15.390
它的输入参数个数是0

00:01:15.390 --> 00:01:18.820
让我们找到定义 calculatePrice 方法的地方

00:01:18.820 --> 00:01:20.700
我将修改方法名称

00:01:20.700 --> 00:01:25.620
使得它有两个输入参数 这个参数分别是 boolean 类型的 addWhippedCream

00:01:25.620 --> 00:01:27.730
和 boolean 类型的 addChocolate

00:01:27.730 --> 00:01:30.850
参数的名称可以随意设定

00:01:30.850 --> 00:01:34.220
我只是使用不同的名称传入这个方法

00:01:34.220 --> 00:01:36.900
只是向大家展示这些名称不必匹配

00:01:36.900 --> 00:01:40.580
我也更新了 Javadoc 来描述这两个新的输入参数

00:01:40.580 --> 00:01:43.570
这样调用这个方法的人就知道输入什么参数了

00:01:43.570 --> 00:01:47.580
接下来 在 calculatePrice 方法内部 我需要

00:01:47.580 --> 00:01:49.930
根据配料的不同 修改价格的相关逻辑

00:01:49.930 --> 00:01:52.130
首先 我要计算基本价格 所以

00:01:52.130 --> 00:01:54.720
我将创建一个整型变量 basePrice

00:01:54.720 --> 00:01:58.500
我从5美元开始 因为每杯咖啡花费5美元

00:01:58.500 --> 00:02:00.930
然后创建一个 if 语句

00:02:00.930 --> 00:02:05.600
如果 boolean类型的 addWhippedCream 为真 那么用户需要生奶

00:02:05.600 --> 00:02:09.720
这意味着 我们要在每杯咖啡基本价格的基础上加1美元

00:02:09.720 --> 00:02:11.920
好的 这应该能处理加生奶的情况了

00:02:11.920 --> 00:02:13.740
现在 来看看巧克力的情况

00:02:13.740 --> 00:02:16.110
再建立一个 if 语句

00:02:16.110 --> 00:02:19.000
我不需要 else 代码 因为

00:02:19.000 --> 00:02:23.000
如果用户不需要生奶 我不需要做任何事情

00:02:23.000 --> 00:02:26.550
实际上 如果我想输入一个 else 情形 它看起来 应该是这个样子的

00:02:26.550 --> 00:02:29.990
我将注释一下说 什么也不做

00:02:29.990 --> 00:02:31.960
Android studio 更聪明

00:02:31.960 --> 00:02:35.010
它会注意到 else 语句是空的

00:02:35.010 --> 00:02:38.040
它们的提示是这段代码令人困惑

00:02:38.040 --> 00:02:39.930
也许是打错了

00:02:39.930 --> 00:02:41.800
这些行也是我们不需要的代码 所以

00:02:41.800 --> 00:02:43.660
我们将 else 代码块清除

00:02:43.660 --> 00:02:45.930
然后 我们来看看巧克力的情况

00:02:45.930 --> 00:02:48.610
巧克力配料和生奶配料是完全

00:02:48.610 --> 00:02:49.800
独立的

00:02:49.800 --> 00:02:51.880
用户选择这个或者那个并不重要

00:02:51.880 --> 00:02:53.540
它们是无关的

00:02:53.540 --> 00:02:57.060
所以我将建立一个独立的 if 情形

00:02:57.060 --> 00:02:59.480
如果用户需要巧克力

00:02:59.480 --> 00:03:04.010
那么我们需要修改基本价格 使得它为 basePrice+2

00:03:04.010 --> 00:03:08.810
再说一次 我们可以使用 else 代码块 但是它不起任何作用

00:03:08.810 --> 00:03:12.690
如果用户不需要巧克力 我们就不需要调整价格

00:03:12.690 --> 00:03:15.530
所以我们删除这些代码 它们都是不必要的

00:03:15.530 --> 00:03:20.450
阅读我们的代码 每杯咖啡的基本价格是5 美元

00:03:20.450 --> 00:03:24.945
如果用户需要生奶 那么基本价格就会加1

00:03:24.945 --> 00:03:27.610
如果用户需要巧克力

00:03:27.610 --> 00:03:29.703
那么基本价格就会加2

00:03:29.703 --> 00:03:32.290
然后计算订单的总价

00:03:32.290 --> 00:03:35.835
我们需要用数量乘以每杯咖啡的价格

00:03:35.835 --> 00:03:38.735
好的 代码看起来能正常工作了

00:03:38.735 --> 00:03:41.935
我在每个代码块的上面加了内嵌注释

00:03:41.935 --> 00:03:45.695
这样当我们看到这段代码时 就可以想起我们做了什么事情

00:03:45.695 --> 00:03:48.005
运行应用 检查一下它是否正常工作

00:03:48.005 --> 00:03:50.635
好的 让我们来测试一下我们早前一起考察的例子

00:03:51.965 --> 00:03:55.319
如果我们选择生奶 并选择数量为3

00:03:55.319 --> 00:03:56.906
那么每杯咖啡为6美元

00:03:56.906 --> 00:04:01.450
6美元乘以3是18美元 计算结果确实是18 很好

00:04:01.450 --> 00:04:07.679
如果我添加巧克力配料 那么每杯咖啡将花费8美元

00:04:07.679 --> 00:04:11.650
如果数量为2 那么总价就为16

00:04:11.650 --> 00:04:15.700
我们尝试只使用生奶 也得到了正确结果

00:04:15.700 --> 00:04:18.510
我们尝试既添加生奶又添加巧克力配料的情形

00:04:18.510 --> 00:04:21.350
得到了正确的结果

00:04:21.350 --> 00:04:23.760
现在我们来试一试只选择巧克力的情形

00:04:23.760 --> 00:04:27.290
把数量改为1 然后点击 ORDER

00:04:27.290 --> 00:04:31.810
看起来是正确的 因为每杯咖啡价格是5美元加上2美元

00:04:31.810 --> 00:04:34.840
的巧克力 就是7美元了

00:04:34.840 --> 00:04:41.150
如果我把这里改为4 那么总数价就更新了为28美元 给定每杯咖啡为7美元

00:04:41.150 --> 00:04:41.650
非常好

00:04:42.910 --> 00:04:44.550
看起来工作正常

00:04:44.550 --> 00:04:47.650
我快速的浏览了一遍哪些测试样例

00:04:47.650 --> 00:04:48.660
我想做的是

00:04:48.660 --> 00:04:53.160
保证代码的所有可能路径都能够执行通

00:04:53.160 --> 00:04:56.823
例如 如果我们运行应用 并且从不选择生奶复选框

00:04:56.823 --> 00:05:00.490
那么我们就永远不会测试这段代码是否能正常工作

00:05:00.490 --> 00:05:05.720
所以我们需要选择条件 使得代码的所有部分都能够执行

00:05:05.720 --> 00:05:09.180
我们选择生奶配料和巧克力配料

00:05:09.180 --> 00:05:12.550
来保证这段代码也能执行

00:05:12.550 --> 00:05:14.320
为了更加全面 我们应该测试

00:05:14.320 --> 00:05:17.450
这两个 boolean 变量的所有可能组合

00:05:17.450 --> 00:05:21.580
这些组合将导致这方法的不同行为

00:05:21.580 --> 00:05:24.870
所以我们需要保证代码在所有的情况下都能正常工作

00:05:24.870 --> 00:05:29.080
随着我们的进行 基本价格也被重新计算

00:05:29.080 --> 00:05:34.000
我们可以用日志消息来保证它的计算是正确的

00:05:34.000 --> 00:05:37.910
不管怎么样 这些是你需要记住的东西

00:05:37.910 --> 00:05:40.760
当你用这些控制流语句写更复杂的代码时

