WEBVTT
Kind: captions
Language: ko

00:00:00.452 --> 00:00:03.620
좋아요, 꽤나 까다로운
코딩 과제였습니다.

00:00:03.620 --> 00:00:08.150
구성 부분 그 각각에 이전에는 
써본 적이 없는 뷰가 들어있었죠.

00:00:08.150 --> 00:00:10.650
함께 해결책을 찾아보기로 하죠.

00:00:10.650 --> 00:00:13.840
우선, 작업 단계를 계획해 보라고
부탁드렸었죠.

00:00:13.840 --> 00:00:16.160
첫 단계는 사용자가 자신의
이름을 입력할 수 있도록

00:00:16.160 --> 00:00:18.250
이 텍스트 필드를 추가해야 합니다.

00:00:18.250 --> 00:00:20.880
두 번째로는 주문 버튼을 클릭시
텍스트 필드에 나오는 이름을

00:00:20.880 --> 00:00:24.630
변수로 저장할 필요가 있겠죠.

00:00:24.630 --> 00:00:27.270
세 번째로는 주문 요약을 
업데이트하여 그 이름이

00:00:27.270 --> 00:00:27.880
실제로 나오도록 하는 겁니다.

00:00:29.240 --> 00:00:30.460
첫 단계로 들어가 볼까요.

00:00:31.500 --> 00:00:34.800
우린 아직 텍스트 입력 필드를 
앱에 추가해 본 적이 없으니까

00:00:34.800 --> 00:00:36.250
구글 검색으로 방법을 찾아 보죠.

00:00:37.270 --> 00:00:38.850
사용자 입력 내용을 입수하는
방법에 관한 것이므로

00:00:38.850 --> 00:00:42.165
"사용자 입력 안드로이드"로
검색해 볼께요.

00:00:42.165 --> 00:00:45.275
developer.android.com이라는 사이트가
처음에 뜨네요. 괜찮은 것 같아요.
site, so that looks good.

00:00:46.295 --> 00:00:49.765
이 페이지는 사용자 입력을 위한
최선의 방법에 대해 설명하고 있습니다.

00:00:49.765 --> 00:00:55.455
터치, 키보드 입력 및 게임 
컨트롤러에 관해서도 나와 있군요.

00:00:55.455 --> 00:00:59.455
우리는 키보드 입력이 필요하므로
첫 번째 링크를 클릭합시다.

00:00:59.455 --> 00:01:02.045
일단 페이지 전체를 둘러볼께요.

00:01:02.045 --> 00:01:05.150
몇 가지 XML 예가 보이네요.
유용할 지도 몰라요.

00:01:05.150 --> 00:01:08.710
꺾쇠 괄호가 나온 후 뷰 이름이
등장하는 게 보이네요.

00:01:08.710 --> 00:01:11.550
이 경우에 뷰 이름은 
EditText가 되겠습니다.

00:01:12.610 --> 00:01:17.260
다른 예를 훑어보면,
이것 또한 EditText 뷰로군요.

00:01:17.260 --> 00:01:22.330
키보드 입력을 받아들이는 뷰를
EditText라고 하는 것 같아요.

00:01:22.330 --> 00:01:25.269
또 다른 방법으로는 일반 안드로이드
치트시트를 사용할 수 있겠습니다.

00:01:26.330 --> 00:01:29.360
여기 뷰 목록에도 EditText가
보이네요. 그리고 이 '앨범 설명'은

00:01:29.360 --> 00:01:32.670
우리 앱의 이름 입력 필드와
비슷합니다.

00:01:33.730 --> 00:01:35.680
이 XML을 복사해서 
우리 앱에 붙여 보죠.

00:01:36.850 --> 00:01:39.790
우리가 원하는 건 주문 양식 
맨 위, '토핑' 헤더 위에

00:01:39.790 --> 00:01:42.910
이름 입력란을 넣는 거죠.
그러니 여기에 붙입시다.

00:01:42.910 --> 00:01:45.440
바로 오류 메세지가 뜨는 군요.
이 기호는 hint의 구성 요소가

00:01:45.440 --> 00:01:46.449
될 수 없다고 합니다.

00:01:47.600 --> 00:01:51.430
이것은 '앨범 설명'이라는 텍스트의
레퍼런스입니다. 하지만 그건

00:01:51.430 --> 00:01:55.640
치트시트에서의 예니까, 이걸 지우고
'이름'으로 바꿉니다.

00:01:55.640 --> 00:01:58.640
이름 입력란을 주문 양식 맨 위,
그러니까 '토핑' 헤더 위에

00:01:58.640 --> 00:02:01.910
놓아야 하니까, 이걸 여기에
붙여넣기 합니다.

00:02:01.910 --> 00:02:05.150
이 수직선 레이아웃의 첫 번째
자식이 되겠네요.

00:02:05.150 --> 00:02:08.109
모든 속성이 우리가 원하는 대로
설정되었는지 보도록 합시다.

00:02:09.120 --> 00:02:10.220
우선, 뷰 ID가 있네요.

00:02:10.220 --> 00:02:13.350
album_description_view라고 합니다.

00:02:13.350 --> 00:02:15.590
이건 치트시트용 예니까,
이걸 우리가 쓰기에 알맞은

00:02:15.590 --> 00:02:18.000
내용으로 바꿔 봅시다.

00:02:19.020 --> 00:02:20.470
name field라고 하죠.

00:02:21.840 --> 00:02:24.419
그 다음 나오는 너비, 높이는
익숙한 속성이죠.

00:02:26.000 --> 00:02:29.052
현재 텍스트란 너비는 부모뷰에
맞춰져 있습니다.

00:02:29.052 --> 00:02:33.620
이 필드가 부모뷰의 레이아웃과
동일한 너비라는 뜻이지요.

00:02:33.620 --> 00:02:34.960
다음은 높이군요.

00:02:34.960 --> 00:02:36.820
높이는 내용 둘러싸기, 즉

00:02:36.820 --> 00:02:39.380
내용이 그 안에 들어갈 만큼의
높이라는 뜻입니다.

00:02:39.380 --> 00:02:42.630
이 두개 값은 괜찮아 보이네요.
그러니 이대로 둡시다.

00:02:42.630 --> 00:02:44.230
그다음은 힌트인데요.

00:02:44.230 --> 00:02:46.450
이 속성에 관해서는 아직 우리가
다뤄본 적이 없죠. 게다가

00:02:46.450 --> 00:02:49.800
이 문자열은 쓸 수 없다는
오류가 떴습니다.

00:02:49.800 --> 00:02:51.580
EditText android에 관해
자료를 검색해서

00:02:51.580 --> 00:02:55.020
이 속성이 무엇인지 알아봅시다.

00:02:56.020 --> 00:03:00.220
검색해 보니 관련 자료가 나오네요.

00:03:00.220 --> 00:03:05.040
간단한 클래스 개요가 있고, 
그 다음에 XML 속성 목록이 뜹니다.

00:03:05.040 --> 00:03:08.900
edit text 클래스는 텍스트뷰와
뷰에서 상속되는 것 같네요.

00:03:08.900 --> 00:03:12.250
이 상속된 XML 속성이
그 이유 때문에 있는 거로군요.

00:03:12.250 --> 00:03:14.720
이걸 펼쳐서 안드로이드 
힌트에 대해 찾아봅시다.

00:03:15.990 --> 00:03:18.230
좋아요. 우리가 찾던 속성이
이거 같군요.

00:03:18.230 --> 00:03:21.270
여기서 오른쪽을 보면

00:03:21.270 --> 00:03:24.860
텍스트가 공란일때 표시하는
힌트라고 나와 있습니다.

00:03:24.860 --> 00:03:27.850
사용자가 이 필드에 뭘 입력해야 
하는 지 알도록 해주는 거죠.

00:03:27.850 --> 00:03:31.870
여러분께 보여드린 앱 상에서는
힌트 텍스트가 '이름'이었습니다.

00:03:31.870 --> 00:03:35.440
그러니 우리 코드에는 이 문자열을
지우고 대신 '이름'을 입력하죠.

00:03:36.500 --> 00:03:37.750
다음은 inputType입니다.

00:03:37.750 --> 00:03:41.690
이것도 처음 보는 속성이네요.
자료를 다시 봅시다.

00:03:41.690 --> 00:03:44.790
Android input type으로
검색해 보겠습니다.

00:03:44.790 --> 00:03:46.100
여기 나와 있군요.

00:03:46.100 --> 00:03:50.830
설명을 보면, 텍스트 필드가
되는 데이터 유형이라고 합니다.

00:03:50.830 --> 00:03:54.980
사용자의 텍스트 입력 방식을
입력 메소드가 결정하게 해주죠.

00:03:54.980 --> 00:03:58.240
이 설명만으로는 좀 부족하네요.
이 속성을 클릭해서

00:03:58.240 --> 00:03:59.610
좀 더 자세히 알아봅시다.

00:03:59.610 --> 00:04:02.760
여기에 InputType에 대한
완전한 설명이 나와 있네요.

00:04:02.760 --> 00:04:05.780
여기 보이는 게 우리가 스스로 
설정할 수 있는 값입니다.

00:04:05.780 --> 00:04:09.750
치트시트의 예에서는
textMultiLine이라는 XML이었죠.

00:04:09.750 --> 00:04:14.120
edit text field가 여러 줄의
텍스트를 받을 수 있다는 뜻입니다.

00:04:14.120 --> 00:04:16.470
이름이니까 아주 길진 않겠죠.

00:04:16.470 --> 00:04:19.550
그러니 한 줄이면 충분할 겁니다.

00:04:19.550 --> 00:04:21.959
입력 유형은 그대로 text로 둡시다.

00:04:21.959 --> 00:04:25.010
textMultiline을 지우고
text라고 입력하면,

00:04:25.010 --> 00:04:29.710
사용 가능한 전체 목록을
자동 완성 기능으로 볼 수 있습니다.

00:04:29.710 --> 00:04:31.910
전 그냥 text를 골라 볼께요.

00:04:31.910 --> 00:04:34.660
이제 앱을 기기에서 작동시켜
EditText 필드가 나타나는지

00:04:34.660 --> 00:04:36.180
보도록 하겠습니다.

00:04:36.180 --> 00:04:38.490
앱이 구동되면
이름 필드가 보이네요.

00:04:38.490 --> 00:04:39.410
멋져요.

00:04:39.410 --> 00:04:40.055
이제 입력을 할 수 있군요.

00:04:40.055 --> 00:04:42.540
하지만 여기선
소문자로 시작됩니다.

00:04:42.540 --> 00:04:47.260
처음은 대문자로 나오도록
했으면 좋겠는데요.

00:04:47.260 --> 00:04:51.030
이 문제를 해결하기 위해서는,
여기 입력 유형을 수정하면 됩니다.

00:04:51.030 --> 00:04:52.350
다른 옵션을 한 번 볼까요.

00:04:53.390 --> 00:04:57.713
textCapcharacters, textCapwords, 
textCapsentences 등

00:04:57.713 --> 00:05:00.210
여러가지가 있습니다.

00:05:00.210 --> 00:05:02.350
대문자 사용에 관한 것들을
써보면 될 것 같군요.

00:05:03.690 --> 00:05:05.530
여기 설명들을 읽어보니,

00:05:05.530 --> 00:05:08.500
textCapwords을 써보면 
좋을 것 같습니다.

00:05:08.500 --> 00:05:10.000
이걸 복사해서 써보도록 하죠.

00:05:11.040 --> 00:05:13.699
텍스트 대신에 textCapwords를
사용해 보려 합니다.

00:05:14.930 --> 00:05:16.170
앱을 다시 작동시켜 보죠.

00:05:16.170 --> 00:05:19.415
좋아요, 이제 키보드가 
대문자로 시작하네요.

00:05:19.415 --> 00:05:22.306
이름 입력을 시작하고 공백을 주면

00:05:22.306 --> 00:05:24.088
다음 단어는 대문자로 시작됩니다.

00:05:24.088 --> 00:05:25.380
아주 좋아요.

00:05:25.380 --> 00:05:29.220
마지막으로 눈에 띄는 건,
이 이름 필드와 '토핑' 헤더 사이에

00:05:29.220 --> 00:05:31.645
공간이 약간 필요하다는 겁니다.

00:05:31.645 --> 00:05:36.010
지금까지는 세로 간격을 16 dp로
맞춰왔죠. 이번에도 마찬가지입니다.

00:05:36.010 --> 00:05:38.816
바닥 공란을 EditText field에
추가할 수도 있겠지만,

00:05:38.816 --> 00:05:42.800
이번에는 '토핑' 헤더 윗부분에
공란을 추가하겠습니다.

00:05:42.800 --> 00:05:45.700
좋아요. 이제 공백 및 이름 필드가
제대로 된 것 같네요.

00:05:46.730 --> 00:05:49.650
이로써 첫 단계에 필요한 
XML 변동 내용을 살펴봤습니다.

00:05:49.650 --> 00:05:51.970
이제 자바 코드를 수정해 보죠.

00:05:51.970 --> 00:05:54.340
두 번째 단계에선,
주문 버튼을 클릭하면

00:05:54.340 --> 00:05:57.650
텍스트 필드에서 이름을 받아
변수로 저장하려고 합니다.

00:05:58.730 --> 00:06:03.140
사람의 눈으로 보면 이름이 쉽게
보이지만, 안드로이드에선

00:06:03.140 --> 00:06:06.980
우리가 이 이름을 여기 주문 요약에
넣고자 한다는 걸 모르죠.

00:06:08.070 --> 00:06:10.840
힘들게 코딩한 라일라의 이름을
아직도 쓰고 있네요.

00:06:10.840 --> 00:06:13.190
여기 이 이름을 쓰도록 
바꿔야 겠습니다.

00:06:13.190 --> 00:06:16.540
주문 요약을 업데이트하기 위해
체크 박스가 체크가 되었는지

00:06:16.540 --> 00:06:19.560
확인하는 방식과 똑같아요.

00:06:19.560 --> 00:06:22.560
EditText 상의 텍스트를 어떻게
읽어들이는 지 아직 배우지 않았으니

00:06:22.560 --> 00:06:23.570
구글 검색으로 알아봅시다.

00:06:23.570 --> 00:06:29.190
'안드로이드 EditText 텍스트
읽는 법'으로 검색해 보겠습니다.

00:06:29.190 --> 00:06:30.390
첫 번째 결과가 괜찮아 보이네요.

00:06:30.390 --> 00:06:32.720
스택 오버플로우에 관한 질문인데

00:06:32.720 --> 00:06:35.880
질문 내용은 알겠지만 
제가 찾는 건 해답이므로

00:06:35.880 --> 00:06:40.050
이 페이지가 쓸모있는 지 
빨리 한 번 훑어 보겠습니다.

00:06:40.050 --> 00:06:43.510
여기 나온 대답이 초록색 마크가
찍히고 찬성도 많으니

00:06:43.510 --> 00:06:45.610
이걸 한 번 읽어보죠.

00:06:45.610 --> 00:06:47.810
짧은 코드가 먼저 등장하네요.

00:06:47.810 --> 00:06:51.820
activity 클래스에 
들어가는 걸로 보입니다.

00:06:51.820 --> 00:06:53.030
FindViewById 메소드를 
호출하고 있으니까요.

00:06:53.030 --> 00:06:57.970
이 ID에 해당하는 
뷰 계층구조를 검색해 보죠.

00:06:57.970 --> 00:07:01.910
이 뷰를 발견하면,
EditText 뷰에 넣어서

00:07:01.910 --> 00:07:05.250
text라는 변수로 저장하는 겁니다.

00:07:05.250 --> 00:07:09.100
두 번째 라인은 value라는 
문자열 변수를 선언하고,

00:07:09.100 --> 00:07:10.330
이것을 저장하는 겁니다.

00:07:10.330 --> 00:07:14.751
여기엔 괄호도 점도 단어도 많지만
여러분은 이제 우리가 이 텍스트를

00:07:14.751 --> 00:07:18.780
여기 EditText 필드에서 꺼내려
한다는 걸 눈치채셨을 거예요.

00:07:18.780 --> 00:07:23.260
이걸 이제 value라는 문자열 변수
안에 저장하려 합니다.

00:07:23.260 --> 00:07:27.120
이 코드를 복사해서 앱에 붙여넣고
작동하는 지 보도록 합시다.

00:07:27.120 --> 00:07:31.480
MainActivity 클래스에서 이 코드를
submitOrder 메소드에 붙이겠습니다.

00:07:31.480 --> 00:07:34.400
제가 이 메소드를 고른 건, 여기서
주문 버튼이 클릭되고

00:07:34.400 --> 00:07:37.170
이름 필드를 읽어들여야 하는 
곳도 여기기 때문입니다.

00:07:38.230 --> 00:07:41.260
스택 오버플로우 관련 게시물에서
받아온 코드를 이 메소드의

00:07:41.260 --> 00:07:41.820
맨 위에 붙여 넣겠습니다.

00:07:43.110 --> 00:07:46.610
곧바로 오류가 뜨네요. 이 기호는
처리할 수 없다고 합니다.

00:07:46.610 --> 00:07:50.340
여기를 ViewID의 이름 필드로
대체해야 겠네요.

00:07:50.340 --> 00:07:52.440
layout.xml로 돌아가서,

00:07:52.440 --> 00:07:56.588
EditText 필드에 name_field의
뷰 ID를 넣었습니다.

00:07:56.588 --> 00:08:01.410
따라서 자바 파일에서 이것을
R.id.name_field로 바꾸겠습니다.

00:08:01.410 --> 00:08:04.530
이제는 오류가 뜨지 않네요.
앱을 작동할 수 있겠습니다.

00:08:04.530 --> 00:08:07.400
하지만 이 코드가 실제 작동하는 
지는 어떻게 알 수 있을까요?

00:08:07.400 --> 00:08:10.520
여기 로그 메세지를 삽입하면

00:08:10.520 --> 00:08:14.300
이 필드에 있는 이름값을
갖고 있는지 확인할 수 있습니다.

00:08:14.300 --> 00:08:16.760
로그 메세지 코드는 여기 있군요.

00:08:16.760 --> 00:08:20.110
이름 다음에 콜론, 그리고
문자열 값을 출력합니다.

00:08:21.110 --> 00:08:23.150
이 변수 이름으로 Value는 좀
애매하므로, 이것을

00:08:23.150 --> 00:08:25.260
name으로 바꾸겠습니다.

00:08:25.260 --> 00:08:28.460
변수를 설명하기에는 그 쪽이 
좀 더 정확할 것 같아요.

00:08:28.460 --> 00:08:31.005
말이 나온 김에, 
EditText 변수 이름 역시

00:08:31.005 --> 00:08:33.760
name field로 바꿀께요.

00:08:33.760 --> 00:08:37.070
Text라고 해 놓으면 코드 안의
다른 부분과 헛갈릴 수 있으니까요.

00:08:37.070 --> 00:08:40.299
이제 앱을 작동시켜 
로그 메세지를 확인해 봅시다.

00:08:40.299 --> 00:08:40.840
좋아요.

00:08:40.840 --> 00:08:42.190
주문 양식을 작성하고

00:08:42.190 --> 00:08:46.810
주문 버튼을 누르면, 여기에서
로그를 확인할 수 있네요.

00:08:46.810 --> 00:08:51.210
MainActivity에서 새 메세지.
"Name: Antigravity Anthony"

00:08:51.210 --> 00:08:52.680
그러니 제대로 작동하는 거죠.

00:08:52.680 --> 00:08:56.360
코드에서 이 필드로부터
이름을 추출한 겁니다.

00:08:56.360 --> 00:08:59.620
좋아요. 이제
사용자명을 변수로 갖게 되었고,

00:08:59.620 --> 00:09:04.060
로그를 통해 
올바른 이름임을 확인했으니,

00:09:04.060 --> 00:09:06.330
주문 요약에 이 이름을 
업데이트 시킬 수 있습니다.

00:09:07.380 --> 00:09:10.280
주문 요약에서 올바른 이름을
표시하기 위해서는,

00:09:10.280 --> 00:09:13.860
이것을 입력 파라미터로 
이 메소드에 전달해야 겠죠.

00:09:13.860 --> 00:09:16.610
우리가 create order summary 
메소드를 호출하면,

00:09:16.610 --> 00:09:20.450
이 이름 변수를 입력 아규먼트로
전달해야 한다는 뜻입니다.

00:09:20.450 --> 00:09:22.410
그 부분을 먼저 바꿔 봅시다.

00:09:22.410 --> 00:09:24.840
이름을 입력 아규먼트로 추가하면,

00:09:24.840 --> 00:09:29.660
오류가 뜹니다. 메소드 호출이
서명과 일치하지 않기 때문이죠.

00:09:29.660 --> 00:09:31.950
아래 메소드 정의로 스크롤한 후,

00:09:31.950 --> 00:09:35.670
문자열 이름을 입력 파라미터로
추가하면 됩니다.

00:09:35.670 --> 00:09:38.410
자바 doc도 업데이트 해야 겠군요.

00:09:38.410 --> 00:09:41.600
이제 createOrderSummary 메소드에서
이 변수를 사용할 수 있습니다.

00:09:41.600 --> 00:09:46.630
직접 코딩한 이름을 이제 지우고
이 이름 변수를 연결해 보죠.

00:09:47.930 --> 00:09:51.360
요약하자면, name_field에서
얻은 이름을 가지고

00:09:51.360 --> 00:09:55.590
createOrderSummary 메소드에
입력으로 전달합니다.

00:09:55.590 --> 00:09:59.620
이 메소드 안에서 이름을
주문 요약에 첨가할 수 있습니다.

00:09:59.620 --> 00:10:01.720
앱을 작동시켜 코드를 확인해 보죠.

00:10:01.720 --> 00:10:05.200
앱이 구동되면, 이름을 입력하고
토핑을 고른 다음

00:10:05.200 --> 00:10:06.790
수량을 바꿔 넣습니다.

00:10:06.790 --> 00:10:08.600
그리고 주문 버튼을 누르죠.

00:10:08.600 --> 00:10:11.190
이제 주문 요약에 
제가 입력했던 이름이

00:10:11.190 --> 00:10:12.160
들어가 있습니다.

00:10:12.160 --> 00:10:13.458
야호!

00:10:13.458 --> 00:10:17.140
이름을 바꿔서 주문 버튼을 누르면
그대로 업데이트 되는군요.

00:10:17.140 --> 00:10:17.800
짜릿한데요.

00:10:17.800 --> 00:10:22.440
앱이 아무 문제 없이 작동하므로
이 로그 메세지는 삭제하면 됩니다.

00:10:22.440 --> 00:10:26.000
앱을 다시 한 번 작동해서
제대로 돌아가는 지 확인해 보죠.

00:10:26.000 --> 00:10:28.640
이제 돌아가서
문제에 답해 봅시다.

00:10:28.640 --> 00:10:31.700
우리가 앱에 추가한 뷰는
EditText입니다.

00:10:31.700 --> 00:10:35.260
두 번째 문제는 이 뷰에서
텍스트를 얻어내기 위해

00:10:35.260 --> 00:10:37.010
사용한 자바 메소드를 묻는 거네요.

00:10:38.120 --> 00:10:40.910
코드로 돌아가 보면
답을 찾을 수 있습니다.

00:10:40.910 --> 00:10:42.885
계층 구조를 다시 살펴보면

00:10:42.885 --> 00:10:46.710
이름 필드를 나타내는 것은 
EditText 자바 객체네요.

00:10:46.710 --> 00:10:49.570
nameField라는 변수로 
저장했었죠.

00:10:49.570 --> 00:10:52.310
이 객체에서 메소드를 호출했습니다.

00:10:52.310 --> 00:10:56.310
getText 메소드를 호출했는데,
여기엔 입력 아규먼트가 없고

00:10:56.310 --> 00:10:58.500
다른 객체를 리턴값으로 갖습니다.

00:10:59.510 --> 00:11:01.460
여기서 세 번째 문제네요.

00:11:01.460 --> 00:11:04.790
getText 메소드의 리턴 데이터
유형은 무엇일까요?

00:11:04.790 --> 00:11:06.330
정답은 editable이고

00:11:06.330 --> 00:11:09.540
이 문제는 안드로이드 자료를
살펴보면 답을 찾을 수 있습니다.

00:11:09.540 --> 00:11:14.320
Edit Text 클래스에서 아래쪽에
공용 메소드 전체가 보입니다.

00:11:14.320 --> 00:11:17.970
GetText는 텍스트뷰가 표시하는
텍스트를 리턴한다고

00:11:17.970 --> 00:11:19.350
나와 있군요

00:11:19.350 --> 00:11:21.960
리턴 데이터 유형은 
편집가능(editable)입니다.

00:11:21.960 --> 00:11:27.280
이것은 편집 가능한 객체를 리턴하며,
이 객체에서 다른 메소드로의 호출은

00:11:27.280 --> 00:11:30.750
여기에 점을 붙이고 메소드 네임을
추가하면 가능합니다.

00:11:30.750 --> 00:11:35.730
이 경우에는 편집가능 객체에서
toString 메소드를 호출하는 것이죠.

00:11:35.730 --> 00:11:38.790
toString 메소드는 문자열을
리턴하여, name이라는 변수에

00:11:38.790 --> 00:11:41.050
저장할 수 있게 해 줍니다.

00:11:42.080 --> 00:11:45.880
이것은 좀 고급 개념으로써
메소드 연쇄 호출이라고 합니다.

00:11:45.880 --> 00:11:49.560
한 메소드를 호출함으로써
리턴값을 얻고

00:11:49.560 --> 00:11:52.800
또 다른 메소드를 호출하여
객체가 리턴되면

00:11:52.800 --> 00:11:53.980
거기서 또다른 메소드를
호출할 수 있는 것이죠.

00:11:53.980 --> 00:11:57.690
이런 식으로 메소드를 연달아 
하나씩 계속 호출할 수 있습니다.

00:11:57.690 --> 00:12:01.230
연쇄 호출을 하는 이유는,
getText 메소드가 편집가능한

00:12:01.230 --> 00:12:02.650
객체를 리턴하기 때문입니다.

00:12:02.650 --> 00:12:05.920
편집가능한 객체의 경우 문자열에
저장할 수 없습니다. 이 경우

00:12:05.920 --> 00:12:09.980
안드로이드 스튜디오에서는 
호환 불가능이라는 오류가 뜨죠.

00:12:09.980 --> 00:12:14.410
따라서 toString 메소드를 추가하면
이 전체 리턴 값이 문자열이 되어

00:12:14.410 --> 00:12:17.790
이름 변수로 저장할 수
있게 되는 것입니다.

00:12:17.790 --> 00:12:20.550
이는 자료에서 확인할 수 있어요.

00:12:20.550 --> 00:12:23.160
getText 메소드는 편집가능한
객체를 리턴합니다.

00:12:23.160 --> 00:12:25.660
여기를 클릭하면, 
편집가능한 클래스에서

00:12:25.660 --> 00:12:27.880
toString이라는 메소드를 
찾을 수 있습니다.

00:12:27.880 --> 00:12:28.600
내려가 보면,

00:12:28.600 --> 00:12:32.830
공용 메소드에서는 toString을
찾을 수 없군요.

00:12:32.830 --> 00:12:34.670
하지만 상속 메소드 목록도 있으니

00:12:34.670 --> 00:12:38.520
여기를 열어 보면, 
toString이라는 메소드가 보입니다.

00:12:38.520 --> 00:12:40.930
그리고 리턴값은 문자열이죠.

00:12:40.930 --> 00:12:44.850
다시 한 번 핵심을 요약하면,
이 메소드를 호출하면

00:12:44.850 --> 00:12:48.000
편집가능한 객체를 리턴하며, 여기서
toString 메소드를 호출하게 됩니다.

00:12:48.000 --> 00:12:50.670
toString 메소드는 
문자열을 리턴하므로

00:12:50.670 --> 00:12:53.680
여기 오른쪽 전체가 
문자열을 리턴하는 결과가 되는 거죠.

00:12:53.680 --> 00:12:57.150
그리고 이는 name이라는 변수로
저장할 수 있습니다.

00:12:58.270 --> 00:13:00.180
와우, 정말 길고 긴 
코딩 과제였네요.

00:13:01.330 --> 00:13:04.070
이제 잠깐 쉬고 나서 
다시 강의로 돌아오세요.

00:13:04.070 --> 00:13:07.620
사용자 주문 내용에 따라 가격을
바꾸는 법을 알아봐야 하니까요.

00:13:07.620 --> 00:13:09.740
컨트롤 플로우에 대해 학습하여
해결해 보도록 하겠습니다.

