WEBVTT
Kind: captions
Language: es

00:00:00.158 --> 00:00:03.040
Si marco esta casilla en la aplicación,
agregará crema batida

00:00:03.040 --> 00:00:04.491
a nuestro café.

00:00:04.492 --> 00:00:06.445
Eso hará que el café sea más delicioso.

00:00:06.445 --> 00:00:09.250
- Sí.
- Y tal vez más caro.

00:00:09.250 --> 00:00:10.260
Cierto.

00:00:10.261 --> 00:00:13.276
Finalmente, tendremos que aprender
a crear un resumen del pedido

00:00:13.277 --> 00:00:14.280
y luego enviarlo.

00:00:14.281 --> 00:00:16.207
Ah, cuando enviamos
el resumen del pedido,

00:00:16.209 --> 00:00:17.422
obtenemos el café. ¿Correcto?

00:00:17.423 --> 00:00:18.450
- Sí.
- Está bien.

00:00:18.450 --> 00:00:21.750
El problema es que no sabemos exactamente
si la casilla ha quedado marcada o no.

00:00:21.751 --> 00:00:23.212
Espera, acabas de marcar la casilla.

00:00:23.213 --> 00:00:24.330
Vi que marcaste la casilla.

00:00:24.331 --> 00:00:28.180
Bueno, para un humano es fácil verlo,
pero es difícil para un teléfono.

00:00:28.180 --> 00:00:30.205
¿A quién llamas humano?

00:00:30.205 --> 00:00:33.700
De todas formas, cuando agregas
el <i>CheckBox</i> a tu aplicación,

00:00:33.700 --> 00:00:36.688
estás creando un objeto Java,

00:00:36.688 --> 00:00:38.168
como este.

00:00:38.168 --> 00:00:40.258
¿Cuántas de esas cajas hay ahí?

00:00:40.258 --> 00:00:41.899
Muchas, porque de hecho,

00:00:41.900 --> 00:00:45.300
dentro del objeto <i>CheckBox</i>
tenemos una variable.

00:00:45.300 --> 00:00:47.923
- Está bien.
- Una variable booleana.

00:00:47.924 --> 00:00:50.030
¿Booleana?
No he oído esa palabra antes.

00:00:50.030 --> 00:00:52.410
Bueno booleano significa
que hay dos estados.

00:00:52.410 --> 00:00:55.080
¿Como Nueva York y California?

00:00:55.080 --> 00:00:56.635
No, es como un interruptor de la luz.

00:00:58.070 --> 00:01:00.550
Caramba.
¿Cómo haces esto?

00:01:00.550 --> 00:01:04.890
Bien, dices que cuando creábamos
un <i>CheckBox</i>, teníamos un objeto Java.

00:01:04.890 --> 00:01:07.740
Dentro del cual hay
una variable de tipo booleano.

00:01:07.741 --> 00:01:08.764
Correcto.

00:01:08.772 --> 00:01:11.450
Y el tipo de esa variable
es encendido o apagado.

00:01:11.450 --> 00:01:13.300
Su valor lo es, sí, encendido o apagado.

00:01:13.300 --> 00:01:17.033
Bueno, puedo cambiar el valor
de encendido a apagado.

00:01:17.034 --> 00:01:18.470
No puedo ver nada.

00:01:18.470 --> 00:01:19.612
¿Puedes volver a encenderla?

00:01:19.613 --> 00:01:20.650
No terminamos todavía.

00:01:20.650 --> 00:01:22.957
Ah, está bien.

00:01:22.958 --> 00:01:24.227
Muy bien, entonces la booleana

00:01:24.228 --> 00:01:26.870
puede tener dos estados,
verdadero o falso.

00:01:26.870 --> 00:01:29.340
Y eso representa el estado de marcado
de esta <i>CheckBox</i>.

00:01:29.340 --> 00:01:32.390
Uh, hay muchas marcas
en esa oración.

00:01:32.390 --> 00:01:33.435
Recapitulemos.

00:01:33.436 --> 00:01:34.459
Voy a resumir.

00:01:34.460 --> 00:01:35.670
Dime si me equivoco.

00:01:35.670 --> 00:01:38.890
Cuando creamos el <i>CheckBox</i>
creamos este objeto Java.

00:01:38.890 --> 00:01:41.443
Dentro de ese objeto Java
tenemos una variable.

00:01:41.444 --> 00:01:43.865
Esa variable es de tipo booleano,

00:01:43.866 --> 00:01:46.580
y puede tener dos valores,

00:01:46.580 --> 00:01:49.840
ya sea, encendido o apagado, 
uno o cero, verdadero o falso.

00:01:49.840 --> 00:01:51.014
- Exactamente.
- Está bien.

00:01:51.015 --> 00:01:53.222
Entonces juguemos con los booleanos.

00:01:55.539 --> 00:01:57.760
Está bien.
Es hora de dejar eso.

00:01:59.419 --> 00:02:01.010
Veamos lo que la documentación

00:02:01.010 --> 00:02:02.767
dice sobre los booleanos.

00:02:02.768 --> 00:02:05.537
Haré una búsqueda en Google
de datos tipo Java.

00:02:06.315 --> 00:02:07.416
Esto es porque un booleano

00:02:07.417 --> 00:02:10.090
es uno de los tipos de datos
primitivos en Java.

00:02:10.090 --> 00:02:12.400
Primitivo, es decir,
los tipos de datos básicos.

00:02:12.400 --> 00:02:15.110
Voy a desplazarme por esta lista
de datos primitivos,

00:02:15.110 --> 00:02:17.440
hasta que encuentre un tipo booleano.

00:02:17.440 --> 00:02:18.570
Y aquí está.

00:02:18.570 --> 00:02:20.365
Se dice que el tipo de datos booleano,

00:02:20.366 --> 00:02:23.095
solo tiene dos valores posibles,
verdadero y falso.

00:02:23.103 --> 00:02:24.516
Se utiliza como indicadores simples,

00:02:24.517 --> 00:02:26.360
para rastrear condiciones
verdaderas o falsas.

00:02:26.360 --> 00:02:29.590
Luego dice que, un booleano
ocupa un bit de información.

00:02:29.590 --> 00:02:32.980
Se trata de la cantidad de espacio
que ocupa en un ordenador.

00:02:32.980 --> 00:02:36.797
Bien, lo importante es que un booleano
tiene dos valores posibles.

00:02:36.798 --> 00:02:38.120
Podrías pensar que verdadero y falso,

00:02:38.120 --> 00:02:41.454
son valores de <i>string</i> porque son textos,

00:02:41.455 --> 00:02:43.977
pero en realidad, no están
entre comillas dobles,

00:02:43.978 --> 00:02:45.800
así que no son <i>strings</i>.

00:02:45.800 --> 00:02:48.220
Son valores literales fijos.

00:02:48.220 --> 00:02:51.690
¿Te acuerdas que los valores
literales fijos son cero y uno

00:02:51.691 --> 00:02:54.302
o strings específicos como hola u hoy?

00:02:54.303 --> 00:02:57.205
Eso significa que cuando se crea
una variable booleana se puede asignar

00:02:57.206 --> 00:02:58.650
a uno de esos dos valores.

00:02:59.350 --> 00:03:03.498
Volviendo a nuestra analogía de la caja,
si tenemos una variable llamada <i>isChecked</i>

00:03:03.498 --> 00:03:07.102
que almacena información sobre si
un <i>CheckBox</i> está marcado o no,

00:03:07.102 --> 00:03:10.710
dentro de esta variable booleana
podemos almacenar el valor verdadero.

00:03:10.710 --> 00:03:14.800
Entonces podemos interpretar esto
como que <i>CheckBox</i> está marcado.

00:03:14.800 --> 00:03:18.060
O podemos almacenar el valor
falso dentro de esta variable.

00:03:18.060 --> 00:03:22.260
Entonces podríamos interpretarlo
como que el <i>CheckBox</i> no está marcado.

00:03:22.260 --> 00:03:26.590
El booleano es adecuado
cuando hay dos estados posibles.

00:03:26.590 --> 00:03:28.647
Entonces depende de ti como desarrollador

00:03:28.648 --> 00:03:30.850
interpretar a qué se le asigna
verdadero o falso.

00:03:31.850 --> 00:03:35.790
Si necesitas más de dos posibles estados
no puedes utilizar un booleano.

00:03:35.790 --> 00:03:38.960
Necesitas usar otra cosa
como un <i>string</i> o un entero.

00:03:38.960 --> 00:03:42.840
Declarar una variable booleana
es muy similar a declarar un entero.

00:03:42.840 --> 00:03:45.950
No es tan complicado como crear
una variable de objeto.

00:03:45.950 --> 00:03:49.850
Sigue el formato boleano
tiene CremaBatida = verdadero.

00:03:49.850 --> 00:03:51.841
Tenemos el tipo de dato, que es boleano,

00:03:51.842 --> 00:03:53.880
seguido por el nombre de la variable,

00:03:53.880 --> 00:03:55.303
que puede ser lo que queramos,

00:03:55.304 --> 00:03:58.225
y luego el valor inicial
que es verdadero o falso.

00:03:58.225 --> 00:04:00.020
Aquí hay un par de ejemplos.

00:04:00.020 --> 00:04:02.541
Aquí asigno falso al mismo booleano.

00:04:03.335 --> 00:04:05.716
Aquí hay otro booleano
llamado <i>esRegistrado</i>,

00:04:05.717 --> 00:04:08.360
y lo inicializo en falso.

00:04:08.360 --> 00:04:10.496
Por ejemplo, esta variable
podría representar

00:04:10.497 --> 00:04:12.400
si un usuario que usa
nuestra aplicación

00:04:12.400 --> 00:04:15.050
tiene una cuenta registrada con nosotros.

00:04:15.050 --> 00:04:16.329
He aquí otro ejemplo.

00:04:16.329 --> 00:04:19.470
booleano es PedidoParaRecoger = verdadero.

00:04:19.470 --> 00:04:22.740
Esta variable puede representar
si alguien que hace un pedido de café

00:04:22.740 --> 00:04:26.517
quiere recogerlo en la tienda
o que se lo lleven.

00:04:26.518 --> 00:04:28.657
Aunque nuestra aplicación
no tenga esas funciones,

00:04:28.658 --> 00:04:30.308
puedes imaginar cómo el uso de booleanos

00:04:30.309 --> 00:04:33.960
podría ser útil, porque estas cosas
tienen dos estados posibles.

00:04:35.020 --> 00:04:38.170
Observa también la forma
como nombré estas variables.

00:04:38.170 --> 00:04:41.070
Un nombre de variable booleana
tiene que seguir las mismas convenciones

00:04:41.070 --> 00:04:42.520
que otros nombres de variables.

00:04:42.520 --> 00:04:44.773
Sin embargo, es común
que comiencen con algo, así como

00:04:44.774 --> 00:04:48.620
tiene algo o es algo.

00:04:48.620 --> 00:04:50.836
Cuando veas nombres comenzando
con tiene o es,

00:04:50.837 --> 00:04:53.450
es probable que sea un booleano
pero no siempre.

00:04:53.450 --> 00:04:56.470
Lo que voy a mostrarles es
un poco más avanzado y opcional.

00:04:56.470 --> 00:04:58.180
Así que si estás interesado
puedes seguir.

00:04:59.230 --> 00:05:01.950
Esta es la página de documentación
de la clase <i>CheckBox</i>.

00:05:02.465 --> 00:05:05.195
Voy a hacer clic en <i>view source</i>
para mirar el código fuente

00:05:05.196 --> 00:05:06.960
de la clase <i>CheckBox</i>.

00:05:06.960 --> 00:05:09.820
Este código se guarda
en el archivo <i>CheckBox.java</i>.

00:05:09.820 --> 00:05:11.952
Quiero mostrar que hay
una variable booleana

00:05:11.953 --> 00:05:14.220
dentro de esta clase <i>CheckBox</i>.

00:05:14.220 --> 00:05:18.450
Pero no la veo aquí,
entonces veamos la superclase.

00:05:18.450 --> 00:05:21.200
Si este valor es verdadero,
el <i>CheckBox</i> está marcado.

00:05:21.200 --> 00:05:24.320
Si es falso la casilla no está marcada.

00:05:24.320 --> 00:05:27.800
Notarás que este nombre
no contiene la palabra tiene o es,

00:05:27.800 --> 00:05:30.850
pero si vas aquí, podrás ver
que las otras variables booleanas

00:05:30.850 --> 00:05:32.900
tienen la palabra tiene.

00:05:32.900 --> 00:05:35.108
Es todo cuestión de preferencia
del desarrollador.

00:05:35.109 --> 00:05:37.886
En este caso, es probable
que esté bastante claro que es un booleano

00:05:37.887 --> 00:05:39.037
por el estado marcado.

00:05:39.610 --> 00:05:41.603
Y aunque este booleano no se encuentra

00:05:41.604 --> 00:05:43.750
directamente en el archivo <i>CheckBox.java</i>,

00:05:43.750 --> 00:05:46.640
ya que lo estamos heredando
de la clase <i>CompoundButton</i>,

00:05:46.640 --> 00:05:49.270
obtenemos este booleano marcado
gratuitamente.

00:05:49.270 --> 00:05:51.110
En general, mirar el código fuente

00:05:51.110 --> 00:05:54.109
de las clases Android
no es necesario.

00:05:54.110 --> 00:05:55.767
Para desarrollar aplicaciones de Android,

00:05:55.768 --> 00:05:59.250
todo lo que necesitas saber es
cómo mirar las páginas de documentación.

00:05:59.250 --> 00:06:02.191
Bien, en este vídeo aprendimos
cómo almacenan los booleanos

00:06:02.192 --> 00:06:03.860
un valor de verdadero o falso.

00:06:04.960 --> 00:06:08.000
En esta prueba, practica
la creación de una variable booleana

00:06:08.000 --> 00:06:10.183
y actualízala escribiendo
las líneas de código

00:06:10.184 --> 00:06:12.420
en los cuadros correspondientes.

00:06:12.420 --> 00:06:15.720
Escribe esta línea exactamente aquí
y lo mismo para los otros cuadros.

00:06:16.990 --> 00:06:19.700
Luego quiero que pienses
en otros buenos casos

00:06:19.700 --> 00:06:21.720
para almacenar información en un booleano.

00:06:21.720 --> 00:06:23.550
Piensa en lo que tiene
dos estados posibles.

00:06:25.110 --> 00:06:28.200
¿Usas el reloj de alarma
de tu teléfono para despertarte?

00:06:28.200 --> 00:06:31.315
Bueno lo más probable es que cuando
activas la alarma o la desactivas,

00:06:31.316 --> 00:06:33.530
eso se estará almacenando
en una variable booleana.

00:06:34.680 --> 00:06:37.310
Otro posible variable booleana
es si quieres

00:06:37.310 --> 00:06:38.852
repetir la alarma o no.

00:06:39.439 --> 00:06:43.490
En la aplicación de Gmail, si quiero
destacar este mensaje especial que recibí

00:06:43.490 --> 00:06:46.355
del equipo de Gmail en 2011,

00:06:46.356 --> 00:06:48.960
puedo asignarle una estrella,
o eliminársela.

00:06:48.960 --> 00:06:52.140
Como hay dos estados, podrían
ser almacenados en una variable booleana.

00:06:52.140 --> 00:06:54.015
Un posible nombre
para la variable booleana

00:06:54.016 --> 00:06:56.752
podría ser <i>tieneEstrella</i>.

00:06:56.753 --> 00:06:58.411
También puedes usar una variable booleana

00:06:58.412 --> 00:07:01.210
para determinar si un correo
electrónico fue leído o no.

00:07:01.210 --> 00:07:04.230
Este correo electrónico está sin leer,
mientras que este ya se leyó.

00:07:05.300 --> 00:07:07.613
Hablando de YouTube, vayamos
a la aplicación YouTube.

00:07:08.494 --> 00:07:11.140
En la aplicación YouTube,
cuando se muestra una lista de vídeos,

00:07:11.140 --> 00:07:14.090
si ya los he visto,
muestra este pequeño cuadro de texto aquí

00:07:14.090 --> 00:07:17.770
que dice <i>visto</i> en la esquina izquierda
superior de la imagen en miniatura.

00:07:17.770 --> 00:07:19.359
El hecho de que haya visto o no

00:07:19.359 --> 00:07:22.753
el video, podría también
almacenarse como una variable booleana.

00:07:22.754 --> 00:07:25.140
Te acabo de mostrar algunos
casos de uso para booleanos,

00:07:25.140 --> 00:07:26.968
así que trata de mostrar los tuyos aquí.

00:07:26.969 --> 00:07:28.951
Puedes explorar
aplicaciones de Android existentes

00:07:28.952 --> 00:07:29.976
para algunas ideas.

