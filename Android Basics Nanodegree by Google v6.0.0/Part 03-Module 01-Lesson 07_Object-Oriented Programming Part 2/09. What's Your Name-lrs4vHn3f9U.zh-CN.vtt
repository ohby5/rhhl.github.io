WEBVTT
Kind: captions
Language: zh-CN

00:00:00.452 --> 00:00:03.620
这真是一个具有挑战性的编码任务

00:00:03.620 --> 00:00:08.150
里面包含很多部分 涉及到一个从没见过的 View

00:00:08.150 --> 00:00:10.650
我们先来走一遍整个实现过程

00:00:10.650 --> 00:00:13.840
首先我需要你计划好所需要的步骤

00:00:13.840 --> 00:00:16.160
第一步应该是添加这个文本框

00:00:16.160 --> 00:00:18.250
用户可以输入他们的名字

00:00:18.250 --> 00:00:20.880
第二步是当用户点击 ORDER 按钮时

00:00:20.880 --> 00:00:24.630
我们希望能从文本框中得到名字 把它存到变量中

00:00:24.630 --> 00:00:27.270
第三步是更新 ORDER SUMMARY

00:00:27.270 --> 00:00:27.880
来显示名称

00:00:29.240 --> 00:00:30.460
让我们先进行第一步

00:00:31.500 --> 00:00:34.800
之前我们还没有在应用中添加过文本输入框

00:00:34.800 --> 00:00:36.250
因此 我们用 Google 搜索一下如何添加

00:00:37.270 --> 00:00:38.850
因为需要用户来输入内容

00:00:38.850 --> 00:00:42.165
那么我们搜索 user input android

00:00:42.165 --> 00:00:45.275
结果是一个 developer.android.com 网站 看起来不错

00:00:46.295 --> 00:00:49.765
这个页面显示的是和用户输入相关的最佳实现方法

00:00:49.765 --> 00:00:55.455
里面提到了手势操作以及键盘输入和游戏控制

00:00:55.455 --> 00:00:59.455
键盘输入是我们所需的 所以点击第一个链接

00:00:59.455 --> 00:01:02.045
我先快速总览一下这个页面

00:01:02.045 --> 00:01:05.150
我看到了很多比较有用的 XML 例子

00:01:05.150 --> 00:01:08.710
注意到有一个开始尖括号 然后是视图名字

00:01:08.710 --> 00:01:11.550
这里视图名字似乎是 EditText

00:01:12.610 --> 00:01:17.260
如果我快速滚动看一下其它例子 同样是 EditText 

00:01:17.260 --> 00:01:22.330
看起来这个可以用来接受键盘输入数据的 View 就是 EditText

00:01:22.330 --> 00:01:25.269
还有一种方法是通过 Common Android Views 速查表

00:01:26.330 --> 00:01:29.360
EditText 也在视图列表中

00:01:29.360 --> 00:01:32.670
这里的 Album Description 例子和我们的应用类似

00:01:33.730 --> 00:01:35.680
让我们复制 XML 然后加入到我们的应用中

00:01:36.850 --> 00:01:39.790
我们将名字输入框放入到列表顶部的位置

00:01:39.790 --> 00:01:42.910
在布局最上面 把它加到这里

00:01:42.910 --> 00:01:45.440
马上就报错了 说它无法解析

00:01:45.440 --> 00:01:46.449
hint 关键字这句代码

00:01:47.600 --> 00:01:51.430
这里引用了 album_description 字符串 不过那是在 cheat sheet 中的字段

00:01:51.430 --> 00:01:55.640
我们删除它 用提示的 Name 替换它

00:01:55.640 --> 00:01:58.640
因为我们需要在表格顶部添加名字输入框

00:01:58.640 --> 00:02:01.910
在最上面 让我们把它粘贴在这里

00:02:01.910 --> 00:02:05.150
它将是这个垂直的 LinearLayout 的第一个子类

00:02:05.150 --> 00:02:08.109
现在我们要确保所有属性都按预期设想的设置好了

00:02:09.120 --> 00:02:10.220
首先我们设置 View 的ID

00:02:10.220 --> 00:02:13.350
它是 album_description_view

00:02:13.350 --> 00:02:15.590
这个是参考了速查表的例子 所以

00:02:15.590 --> 00:02:18.000
让我们给它换个更合适的名字

00:02:19.020 --> 00:02:20.470
就叫它 name_field

00:02:21.840 --> 00:02:24.419
然后是熟悉的 width 和 height 属性

00:02:26.000 --> 00:02:29.052
目前 EditText 的 width 属性被设置成 match_parent

00:02:29.052 --> 00:02:33.620
这意味着它的名字输入框会和父 LinearLayout 一样宽

00:02:33.620 --> 00:02:34.960
接下来 我们设置 height

00:02:34.960 --> 00:02:36.820
height 被设置为 wrap_content 所以

00:02:36.820 --> 00:02:39.380
它会和里面内容一样高

00:02:39.380 --> 00:02:42.630
这两个值比较合理 设置成这样就好

00:02:42.630 --> 00:02:44.230
下面我们设置 hint

00:02:44.230 --> 00:02:46.450
之前我们没见过这属性

00:02:46.450 --> 00:02:49.800
这里的错误显示 无法解析这个字符串

00:02:49.800 --> 00:02:51.580
让我们查查文档

00:02:51.580 --> 00:02:55.020
找一下 EditText 的内容 弄清楚这个属性是干什么的

00:02:56.020 --> 00:03:00.220
搜索 EditText Android 我们能找到具体的文档页

00:03:00.220 --> 00:03:05.040
有一个整个类的内容总览 和 XML 的属性列表

00:03:05.040 --> 00:03:08.900
结果是 EditText 继承自 TextView 和 View

00:03:08.900 --> 00:03:12.250
这就是我们为什么能继承 XML 属性

00:03:12.250 --> 00:03:14.720
一旦展开它们 我们就能看到 hint 属性了

00:03:15.990 --> 00:03:18.230
这就是我们要寻找的属性

00:03:18.230 --> 00:03:21.270
滚动往右看 它说

00:03:21.270 --> 00:03:24.860
当文本为空时 在文本控件上显示提示语

00:03:24.860 --> 00:03:27.850
它帮助用户了解在该位置输入哪些内容

00:03:27.850 --> 00:03:31.870
之前在应用里我演示过 提示文本是 Name

00:03:31.870 --> 00:03:35.440
在我们的代码中 应该删掉这段然后输入 Name

00:03:36.500 --> 00:03:37.750
接下来设置 inputType 

00:03:37.750 --> 00:03:41.690
这是一个新的属性 因此我们在文档中查询一下

00:03:41.690 --> 00:03:44.790
搜索 android:inputType

00:03:44.790 --> 00:03:46.100
这里列出来了

00:03:46.100 --> 00:03:50.830
描述说 这是在 text field 中使用的数据格式

00:03:50.830 --> 00:03:54.980
它用来帮助用户 决定输入哪种数据类型

00:03:54.980 --> 00:03:58.240
这个说的有些模糊 所以点击进入这个属性

00:03:58.240 --> 00:03:59.610
看看详细内容

00:03:59.610 --> 00:04:02.760
这是关于 InputType 的全部说明

00:04:02.760 --> 00:04:05.780
这里有我们能设置的所有值

00:04:05.780 --> 00:04:09.750
在速查表的示例中 XML 里写着 textMultiLine

00:04:09.750 --> 00:04:14.120
显然这意味着 EditText 可以接受多行输入

00:04:14.120 --> 00:04:16.470
我们不需要用户设定太长的名称

00:04:16.470 --> 00:04:19.550
所以有一行文本就够了

00:04:19.550 --> 00:04:21.959
所以我们将 inputType 设定为 text

00:04:21.959 --> 00:04:25.010
如果删掉 textMultiline 然后输入 text

00:04:25.010 --> 00:04:29.710
然后就会弹出提示列表

00:04:29.710 --> 00:04:31.910
直接选择 text 就可以了

00:04:31.910 --> 00:04:34.660
现在我们运行一下应用 检查一下 EditText 

00:04:34.660 --> 00:04:36.180
是否能显示

00:04:36.180 --> 00:04:38.490
当开始运行后 我们能看到 Name 字段

00:04:38.490 --> 00:04:39.410
不错

00:04:39.410 --> 00:04:40.055
我也能在这里输入

00:04:40.055 --> 00:04:42.540
但实际上 它是以小写字母开头的

00:04:42.540 --> 00:04:47.260
当我输入的时候 我希望它能变成大写

00:04:47.260 --> 00:04:51.030
修改这里 我能改变输入类型

00:04:51.030 --> 00:04:52.350
让我们再看看这里其它选项

00:04:53.390 --> 00:04:57.713
有 textCapcharacters、textCapwords、textCapsentences

00:04:57.713 --> 00:05:00.210
还有一堆其它的

00:05:00.210 --> 00:05:02.350
这个估计是设置大写字符的

00:05:03.690 --> 00:05:05.530
读完这些说明

00:05:05.530 --> 00:05:08.500
我认为 textCapwords 是最好的选择

00:05:08.500 --> 00:05:10.000
让我们复制并使用它

00:05:11.040 --> 00:05:13.699
用 textCapwords 替换一下 text

00:05:14.930 --> 00:05:16.170
再运行一下

00:05:16.170 --> 00:05:19.415
现在首字母大写了 

00:05:19.415 --> 00:05:22.306
然后可以输入名称了 如果我添加一个空格

00:05:22.306 --> 00:05:24.088
下一个单词首字母是大写的

00:05:24.088 --> 00:05:25.380
漂亮

00:05:25.380 --> 00:05:29.220
最后我发现需要一点空间

00:05:29.220 --> 00:05:31.645
在名称输入框和首行之间

00:05:31.645 --> 00:05:36.010
之前我们在垂直方向添加过 16dp 的空隙 这里做同样的处理

00:05:36.010 --> 00:05:38.816
我可以设置 EditText 的底部外边距

00:05:38.816 --> 00:05:42.800
但是我把它设置为首行的顶部内边距

00:05:42.800 --> 00:05:45.700
现在看来 空隙有了 名称也是对的

00:05:46.730 --> 00:05:49.650
第一步 所有 XML 的修改都已完成

00:05:49.650 --> 00:05:51.970
现在需要修改 Java 代码

00:05:51.970 --> 00:05:54.340
第二步 当点击 ORDER 按钮时

00:05:54.340 --> 00:05:57.650
我们需要从名称输入框中得到名称 存储到变量中

00:05:58.730 --> 00:06:03.140
在这个区域看到名字对人来说很容易 但对于 Android 

00:06:03.140 --> 00:06:06.980
应用 它并不知道我们希望名字显示在这里的订购信息中

00:06:08.070 --> 00:06:10.840
它还显示着 Lyla 写的代码里的名称

00:06:10.840 --> 00:06:13.190
我们需要用这个名字替换一下

00:06:13.190 --> 00:06:16.540
就像我们如何判断 CheckBox 是否被选中

00:06:16.540 --> 00:06:19.560
为了更新 ORDER SUMMARY

00:06:19.560 --> 00:06:22.560
我们还不清楚如何从 EditText 中读取字符串

00:06:22.560 --> 00:06:23.570
让我们用 Google 搜索一下

00:06:23.570 --> 00:06:29.190
我将搜索 how do I text from edittext field android (在 Android 中如何从 EditText 中获取字符串)

00:06:29.190 --> 00:06:30.390
第一个结果看起来不错

00:06:30.390 --> 00:06:32.720
它来自 StackOverflow 网站

00:06:32.720 --> 00:06:35.880
我们略过问题直接跳到答案

00:06:35.880 --> 00:06:40.050
快速浏览这个页面 看看是否对我们有帮助

00:06:40.050 --> 00:06:43.510
这个答案被采纳了 而且很多人赞

00:06:43.510 --> 00:06:45.610
我要更仔细的阅读

00:06:45.610 --> 00:06:47.810
先读代码

00:06:47.810 --> 00:06:51.820
看上去这段代码需要在 activity 类中执行

00:06:51.820 --> 00:06:53.030
因为我们调用了 FindViewById 方法

00:06:53.030 --> 00:06:57.970
我们需要从 View 层中找到这个 ID 对应的 View

00:06:57.970 --> 00:07:01.910
一旦我们找到这个 View 把它转换成一个 EditText 视图

00:07:01.910 --> 00:07:05.250
然后把它保存到 text 变量中

00:07:05.250 --> 00:07:09.100
在第二行 我们声明一个叫 value 的字符串类型的变量

00:07:09.100 --> 00:07:10.330
然后把它保存到这里

00:07:10.330 --> 00:07:14.751
现在已经有一堆括号、点号和文字 但你也许

00:07:14.751 --> 00:07:18.780
能猜到我们想从 EditText 中获得我们的字符串

00:07:18.780 --> 00:07:23.260
我们把它保存到一个叫 value 的字符串变量中

00:07:23.260 --> 00:07:27.120
把这段代码粘到应用里 看看是否能运作

00:07:27.120 --> 00:07:31.480
在 MainActivity 类中 我会将代码添加到 submitOrder 方法中

00:07:31.480 --> 00:07:34.400
我之所以选择这个方法 是因为当ORDER按钮被点击后

00:07:34.400 --> 00:07:37.170
我们也希望从这里读取名称字符串

00:07:38.230 --> 00:07:41.260
我打算将 StackOverflow 上复制的代码粘贴到

00:07:41.260 --> 00:07:41.820
这个方法的顶部

00:07:43.110 --> 00:07:46.610
这里有错误 编译器无法解析这个符号

00:07:46.610 --> 00:07:50.340
我们需要用视图 ID 来替换这里的名字

00:07:50.340 --> 00:07:52.440
切换回我们的 layout.xml 文件中

00:07:52.440 --> 00:07:56.588
我们赋给 EditText 的ID 为 name_field

00:07:56.588 --> 00:08:01.410
所以在 Java 文件中 我需要将这里改为 R.id.name_field

00:08:01.410 --> 00:08:04.530
没什么问题了 我们运行一下程序

00:08:04.530 --> 00:08:07.400
怎么判断这个代码可以运行呢？

00:08:07.400 --> 00:08:10.520
我可以在这里添加一个日志信息来验证

00:08:10.520 --> 00:08:14.300
这个 value 变量存储的是否是名称输入框里的名字

00:08:14.300 --> 00:08:16.760
这里是日志信息的代码

00:08:16.760 --> 00:08:20.110
我输出名称 冒号 然后是 value 的字符串

00:08:21.110 --> 00:08:23.150
对于变量 value 是个模糊的名称

00:08:23.150 --> 00:08:25.260
我们把它替换成 name

00:08:25.260 --> 00:08:28.460
其实应该用一个更加详细的名称代替它 

00:08:28.460 --> 00:08:31.005
说到这 我打算改变 EditText的变量名

00:08:31.005 --> 00:08:33.760
把它也改成 nameField

00:08:33.760 --> 00:08:37.070
叫text 的话可能会与我们代码中其它内容混淆

00:08:37.070 --> 00:08:40.299
现在让我们运行一下应用 检查日志内容

00:08:40.299 --> 00:08:40.840
好的

00:08:40.840 --> 00:08:42.190
如果我填写订单

00:08:42.190 --> 00:08:45.790
然后点击 ORDER 按钮 然后我在这检查日志信息

00:08:46.810 --> 00:08:51.210
看见了一条 MainActivity 的消息 显示 Name: Antigravity Anthony

00:08:51.210 --> 00:08:52.680
工作正常

00:08:52.680 --> 00:08:56.360
这段代码也将这个字段的字符串提取出来了

00:08:56.360 --> 00:08:59.620
现在变量中已经保存了用户的名称

00:08:59.620 --> 00:09:04.060
我们在日志中已经验证 名称正确

00:09:04.060 --> 00:09:06.330
然后我们可以刷新 ORDER SUMMARY 来显示名字

00:09:07.380 --> 00:09:10.280
为了 ORDER SUMMARY 能显示正确的名称

00:09:10.280 --> 00:09:13.860
我们需要在这个方法中添加一个输入参数

00:09:13.860 --> 00:09:16.610
那意味着当我们调用 createOrderSummary 方法时

00:09:16.610 --> 00:09:20.450
我们必须传给名称变量一个输入参数

00:09:20.450 --> 00:09:22.410
先修改一下这里

00:09:22.410 --> 00:09:24.840
如果我添加名称作为输入参数

00:09:24.840 --> 00:09:29.660
会出错 因为方法调用和方法说明不匹配

00:09:29.660 --> 00:09:31.950
滚动到下面的方法定义

00:09:31.950 --> 00:09:35.670
将 String name 添加到参数列表中

00:09:35.670 --> 00:09:38.410
然后更新一下 Java doc

00:09:38.410 --> 00:09:41.600
在 createOrderSummary 方法中 可以使用这个变量

00:09:41.600 --> 00:09:46.630
我要删除硬编码的名称 然后串联这个名字变量

00:09:47.930 --> 00:09:51.360
简单总结一下 我们从 name_field 中获取名称字符

00:09:51.360 --> 00:09:55.590
然后将它作为参数传入到 createOrderSummary 方法中

00:09:55.590 --> 00:09:59.620
在这个方法中 我们可以将名称合并到 ORDER SUMMARY

00:09:59.620 --> 00:10:01.720
让我们运行一下应用 检查代码

00:10:01.720 --> 00:10:05.200
打开程序 我输入一个名称 然后选择一些配料

00:10:05.200 --> 00:10:06.790
修改一下数量

00:10:06.790 --> 00:10:08.600
然后点击 ORDER 按钮

00:10:08.600 --> 00:10:11.190
之后 ORDER SUMMARY 里显示了我之前

00:10:11.190 --> 00:10:12.160
输入的名字

00:10:12.160 --> 00:10:13.458
哇！

00:10:13.458 --> 00:10:17.140
如果我修改一下名称 然后点击 ORDER 它也随之更新了

00:10:17.140 --> 00:10:17.800
有点小兴奋

00:10:17.800 --> 00:10:22.440
现在应用中一切都运转正常 我们可以删掉日志信息

00:10:22.440 --> 00:10:24.900
再运行一下程序 确保功能都正常

00:10:26.000 --> 00:10:28.640
现在让我们返回去 回答测试中的问题

00:10:28.640 --> 00:10:31.700
我们在应用中添加的 View 叫 EditText

00:10:31.700 --> 00:10:35.260
第二个问题是 我们要调用什么Java 方法

00:10:35.260 --> 00:10:37.010
获取这个 View 的字符串

00:10:38.120 --> 00:10:40.910
我们回到代码中来回答这个问题

00:10:40.910 --> 00:10:42.885
看一下 View 的层次

00:10:42.885 --> 00:10:46.710
找到 name_field 对应的 EditText 对象

00:10:46.710 --> 00:10:49.570
called nameField.我们把它存在 nameField 变量中

00:10:49.570 --> 00:10:52.310
对于那个对象 我们调用对应的方法

00:10:52.310 --> 00:10:56.310
即 getText 方法 它不需要参数

00:10:56.310 --> 00:10:58.500
它有个其它类型的返回值 

00:10:59.510 --> 00:11:01.460
这就引入了我们的第三个问题

00:11:01.460 --> 00:11:04.790
getText 方法的返回数值类型是什么？

00:11:04.790 --> 00:11:06.330
答案是 Editable

00:11:06.330 --> 00:11:09.540
从 Android 官方文档中 我们可以找到相关信息

00:11:09.540 --> 00:11:14.320
在 EditText 类中如果你滚动到下面 看到所有 public方法列表

00:11:14.320 --> 00:11:17.970
GetText 会返回 TextView 当前正在显示的

00:11:17.970 --> 00:11:19.350
文字

00:11:19.350 --> 00:11:21.960
返回数值类型是 Editable

00:11:21.960 --> 00:11:27.280
这里会返回 Editable 对象 我们可以通过输入

00:11:27.280 --> 00:11:30.750
“.”加方法 来调用这个对象的其他方法

00:11:30.750 --> 00:11:35.730
这里对于Editable 对象 我们调用 toString 方法

00:11:35.730 --> 00:11:38.790
toString 方法返回一个字符串

00:11:38.790 --> 00:11:41.050
我们可以将这个字符串存储到 name 变量中

00:11:42.080 --> 00:11:45.880
这里涉及到一个更高级的概念 叫链式调用

00:11:45.880 --> 00:11:49.560
因为我们调用一个方法 得到返回值

00:11:49.560 --> 00:11:52.800
然后调用另一个方法 如果返回的是一个对象 

00:11:52.800 --> 00:11:53.980
你可以对它调用另一个方法

00:11:53.980 --> 00:11:57.690
你可以一个接一个持续调用

00:11:57.690 --> 00:12:01.230
我们能进行链式调用的原因是 getText 方法返回了

00:12:01.230 --> 00:12:02.650
一个 Editable 对象

00:12:02.650 --> 00:12:05.920
一个 Editable 对象不能存放在在一个字符串变量中

00:12:05.920 --> 00:12:09.980
Android Studio 会报不兼容格式的错误

00:12:09.980 --> 00:12:14.410
所以如果我们加上 toString 方法 整体的返回值是一个

00:12:14.410 --> 00:12:17.790
字符串 这样就能赋值给 name 变量了

00:12:17.790 --> 00:12:20.550
我们可以通过检查文档来证实

00:12:20.550 --> 00:12:23.160
getText 方法返回了一个 Editable 对象

00:12:23.160 --> 00:12:25.660
如果在 Editable 类里点击这个

00:12:25.660 --> 00:12:27.880
就能找到 toString 方法

00:12:27.880 --> 00:12:28.600
往下看

00:12:28.600 --> 00:12:32.830
在 public 方法中 找不到 toString 方法

00:12:32.830 --> 00:12:34.670
因为它是Inherited Methods(继承方法)

00:12:34.670 --> 00:12:38.520
如果我展开这个下拉列表 然后就能看到了 toString 方法

00:12:38.520 --> 00:12:40.930
返回值是字符串

00:12:40.930 --> 00:12:44.850
再回顾一遍 这个方法返回一个 Editable 对象

00:12:44.850 --> 00:12:48.000
然后我们对它调用 toString 方法

00:12:48.000 --> 00:12:50.670
toString 方法返回一个字符串 所以

00:12:50.670 --> 00:12:53.680
右边的所有这些东西返回一个字符串

00:12:53.680 --> 00:12:57.150
这个字符串保存在变量 name 中

00:12:58.270 --> 00:13:00.180
这次的任务有些复杂

00:13:01.330 --> 00:13:04.070
大家可以稍作休息 之后我们会学习

00:13:04.070 --> 00:13:07.620
如何根据用户预订信息修改价格

00:13:07.620 --> 00:13:09.740
我们将通过学习控制流来实现它

