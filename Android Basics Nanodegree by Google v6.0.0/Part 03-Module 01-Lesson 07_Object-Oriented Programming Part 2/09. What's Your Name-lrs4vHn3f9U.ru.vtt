WEBVTT
Kind: captions
Language: ru

00:00:00.452 --> 00:00:03.620
Хорошо, это было довольно
сложное задание по написанию кода.

00:00:03.620 --> 00:00:07.750
Оно имело много частей и задействовало
элемент View: его вы еще не использовали.

00:00:08.150 --> 00:00:10.250
Давайте вместе посмотрим на решение.

00:00:10.650 --> 00:00:13.540
Для начала я просила вас
определить необходимые шаги.

00:00:13.840 --> 00:00:16.160
Первый шаг —
добавление этого текстового поля,

00:00:16.160 --> 00:00:17.950
чтобы пользователь мог ввести свое имя.

00:00:18.250 --> 00:00:20.880
Второй шаг — сделать так, чтобы
при нажатии на кнопку заказа

00:00:20.880 --> 00:00:24.130
имя из текстового поля
сохранялось в переменной.

00:00:24.630 --> 00:00:27.270
Третий шаг — обновление описания заказа

00:00:27.270 --> 00:00:28.600
и отображение в нем того имени.

00:00:29.240 --> 00:00:30.460
Давайте рассмотрим первый шаг.

00:00:31.500 --> 00:00:34.800
До этого мы не добавляли в приложение
поле для ввода текста, поэтому

00:00:34.800 --> 00:00:36.450
давайте поищем в Google, как это сделать.

00:00:37.270 --> 00:00:39.850
Поскольку нам нужно сделать
возможным ввод данных пользователем,

00:00:39.850 --> 00:00:42.465
я буду искать информацию о вводе
данных пользователем в Android.

00:00:42.465 --> 00:00:45.275
Результат поиска — сайт
developer.android.com.

00:00:46.295 --> 00:00:49.765
Эта страница содержит информацию
про ввод данных пользователем.

00:00:49.765 --> 00:00:55.455
На ней говорится о сенсорных жестах,
вводе с клавиатуры и игровых контроллерах.

00:00:55.455 --> 00:00:58.655
Нам нужен ввод с клавиатуры,
поэтому нажмем на первую ссылку.

00:00:59.455 --> 00:01:02.045
Я быстро просматриваю страницу.

00:01:02.045 --> 00:01:05.150
Я вижу несколько примеров кода XML,
которые нам пригодятся.

00:01:05.150 --> 00:01:08.710
Я замечаю, что здесь есть открывающая
угловая скобка и название элемента View.

00:01:08.710 --> 00:01:11.550
В этом случае название элемента View —
EditText.

00:01:12.610 --> 00:01:17.260
Просмотрев другие примеры,
я вижу, что это элемент View EditText.

00:01:17.260 --> 00:01:22.330
Похоже, элемент View, в который вносятся
данные с клавиатуры, называется EditText.

00:01:22.330 --> 00:01:25.269
Другой метод — использовать памятку
с распространенными элементами View.

00:01:26.330 --> 00:01:29.360
EditText находится в
этом списке элементов View,

00:01:29.360 --> 00:01:32.670
и пример с текстом album description похож
на поле ввода имени в нашем приложении.

00:01:33.730 --> 00:01:36.280
Давайте скопируем этот код XML
и добавим его в наше приложение.

00:01:36.850 --> 00:01:39.790
Нам нужно, чтобы поле ввода имени
было в самой верхней части формы заказа,

00:01:39.790 --> 00:01:42.510
выше заголовка Toppings [топинги],
поэтому добавим его сюда.

00:01:42.910 --> 00:01:45.440
Сразу же появляется ошибка,
говорящая, что невозможно определить

00:01:45.440 --> 00:01:46.849
этот символ в строке подсказки.

00:01:47.600 --> 00:01:51.430
Здесь речь идет об album description,
но это текст, использованный в памятке.

00:01:51.430 --> 00:01:55.640
Давайте удалим его и заменим
своим текстом-подсказкой — Name [имя].

00:01:55.640 --> 00:01:58.640
Так как нам нужно, чтобы поле ввода имени
было в верхней части формы заказа,

00:01:58.640 --> 00:02:01.510
выше заголовка Toppings,
давайте поместим текст вот здесь.

00:02:01.910 --> 00:02:04.750
Это будет первый дочерний элемент
в этой вертикальной линейной разметке.

00:02:05.150 --> 00:02:08.109
Теперь убедимся, что
все атрибуты заданы так, как нам нужно.

00:02:09.120 --> 00:02:10.620
Сначала у нас идет ID элемента View.

00:02:10.620 --> 00:02:13.350
Он назван album_description_view.

00:02:13.350 --> 00:02:15.590
Этот текст относится к
примеру из памятки, поэтому

00:02:15.590 --> 00:02:18.000
заменим его более подходящим названием.

00:02:19.020 --> 00:02:20.770
Назовем его name_field [поле ввода имени].

00:02:21.840 --> 00:02:24.419
Далее идут атрибуты ширины
и высоты, которые нам знакомы.

00:02:26.000 --> 00:02:29.052
Сейчас шириной поля EditText
назначено значение match_parent.

00:02:29.052 --> 00:02:33.620
Это значит, что ширина поля равна
ширине родительской линейной разметки.

00:02:33.620 --> 00:02:34.960
Далее идет высота.

00:02:34.960 --> 00:02:36.820
Высота обозначена как wrap_content,

00:02:36.820 --> 00:02:39.280
т. е. она будет равняться
высоте контента внутри элемента.

00:02:39.380 --> 00:02:42.330
Эти две величины нам подходят,
поэтому оставим их как есть.

00:02:42.630 --> 00:02:44.330
Далее идет атрибут hint [текст-подсказка].

00:02:44.330 --> 00:02:46.450
Мы еще не работали
с этим атрибутом, и здесь

00:02:46.450 --> 00:02:49.800
выдается сообщение об ошибке, говорящее,
что эту строку невозможно обработать.

00:02:49.800 --> 00:02:51.580
Давайте посмотрим информацию

00:02:51.580 --> 00:02:55.020
об EditText на Android, чтобы понять,
что означает данный атрибут.

00:02:56.020 --> 00:03:00.220
Если будем искать edittext android,
то найдем страницу с нужной информацией.

00:03:00.220 --> 00:03:05.040
Здесь дано краткое описание класса,
затем список атрибутов XML.

00:03:05.040 --> 00:03:08.600
Оказывается, класс EditText является
наследником элементов TextView и View.

00:03:08.900 --> 00:03:11.850
Поэтому здесь имеются эти
унаследованные атрибуты XML.

00:03:12.250 --> 00:03:14.820
Выбрав показ подробной информации,
мы можем искать атрибут Hint.

00:03:15.990 --> 00:03:18.230
Так, вот атрибут, который мы искали.

00:03:18.230 --> 00:03:21.270
В самом правом столбце
говорится о том, что

00:03:21.270 --> 00:03:24.860
это текст-подсказка, отображаемый,
когда текстовое поле является пустым.

00:03:24.860 --> 00:03:27.850
Он помогает пользователю понять,
что нужно вводить в это поле.

00:03:27.850 --> 00:03:31.870
В приложении, которое я вам показывала,
подсказкой служил текст name.

00:03:31.870 --> 00:03:35.440
В нашем коде мы должны стереть
эту строку и ввести name.

00:03:36.500 --> 00:03:38.050
Далее следует атрибут inputType.

00:03:38.050 --> 00:03:41.690
Это тоже новый для нас атрибут,
поэтому посмотрим справочную информацию.

00:03:42.090 --> 00:03:44.590
Теперь я буду искать ключевые слова
android:inputType.

00:03:44.790 --> 00:03:46.000
Атрибут расположен здесь,

00:03:46.100 --> 00:03:50.830
и в его описании говорится, что это
тип данных, вводимых в текстовое поле.

00:03:50.830 --> 00:03:54.980
Он используется для определения того,
как пользователь будет вводить текст.

00:03:54.980 --> 00:03:57.740
Это не совсем ясное описание,
поэтому давайте нажмем на этот атрибут,

00:03:57.740 --> 00:03:59.110
чтобы узнать больше подробностей.

00:03:59.610 --> 00:04:02.460
Вот полное описание атрибута InputType.

00:04:02.760 --> 00:04:05.780
Это возможные
значения, которые мы можем задать.

00:04:05.780 --> 00:04:09.350
В примере из памятки в коде XML
было задано значение textMultiLine.

00:04:09.750 --> 00:04:13.820
Это значит, что в поле EditText
можно вводить несколько строк текста.

00:04:14.120 --> 00:04:16.470
Мы не думаем, что вводимое
имя будет очень длинным,

00:04:16.470 --> 00:04:19.550
поэтому одной строки текста
должно хватить.

00:04:19.550 --> 00:04:21.959
Используем text как значение InputType.

00:04:21.959 --> 00:04:25.010
Если я сотру textMultiline
и начну печатать текст,

00:04:25.010 --> 00:04:29.710
то в качестве автозаполнения мне
будет предложен список всех вариантов.

00:04:29.710 --> 00:04:31.910
Я выбираю text и жму на enter.

00:04:31.910 --> 00:04:34.460
Теперь я запущу приложение
на устройстве, чтобы проверить,

00:04:34.460 --> 00:04:35.780
будет ли показано поле EditText.

00:04:36.180 --> 00:04:38.490
Приложение запускается,
и я вижу поле для ввода имени.

00:04:38.490 --> 00:04:39.510
Замечательно.

00:04:39.510 --> 00:04:40.755
И я могу печатать в нем текст.

00:04:41.155 --> 00:04:43.040
Однако текст начинается со строчной буквы.

00:04:43.140 --> 00:04:47.260
Мне нужно,
чтобы текст начинался с прописной буквы.

00:04:47.260 --> 00:04:50.530
Чтобы исправить это,
я изменю атрибут InputType.

00:04:51.030 --> 00:04:52.850
Давайте рассмотрим другие
значения атрибута.

00:04:53.390 --> 00:04:57.713
Здесь есть textCapcharacters,
textCapwords, textCapsentences

00:04:57.713 --> 00:05:00.210
и множество других значений.

00:05:00.210 --> 00:05:03.050
Мне должны подойти значения
о вводе текста прописными буквами.

00:05:03.690 --> 00:05:05.530
Прочитав эти описания,

00:05:05.530 --> 00:05:08.500
думаю, стоит попробовать
значение textCapwords.

00:05:08.500 --> 00:05:10.000
Скопируем его и используем.

00:05:11.040 --> 00:05:13.699
Вместо значения text я ввожу textCapwords.

00:05:14.930 --> 00:05:16.170
Запустим приложение снова.

00:05:16.170 --> 00:05:19.415
Так, теперь текст вводится,
начиная с заглавной буквы.

00:05:19.415 --> 00:05:22.306
Я ввожу имя,
и если я добавлю пробел, то следующее

00:05:22.306 --> 00:05:24.088
слово также начинается с прописной буквы.

00:05:24.088 --> 00:05:25.380
Замечательно.

00:05:25.380 --> 00:05:29.220
Наконец, я замечаю, что
лучше добавить немного места

00:05:29.220 --> 00:05:31.645
между полем ввода имени
и заголовком Toppings.

00:05:31.645 --> 00:05:36.010
Мы добавляли вертикальный интервал
размером 16 dp; сделаем то же и здесь.

00:05:36.010 --> 00:05:38.916
Я могла бы добавить интервал в качестве
нижнего поля компонента EditText,

00:05:38.916 --> 00:05:42.800
но я решила добавить его в качестве
верхнего поля заголовка Toppings.

00:05:42.800 --> 00:05:45.700
Отлично, теперь интервал и
поле ввода имени заданы правильно.

00:05:46.730 --> 00:05:49.650
Значит, мы проделали все изменения
в коде XML, нужные для первого шага.

00:05:49.650 --> 00:05:51.970
Теперь нам нужно изменить код Java.

00:05:51.970 --> 00:05:54.340
На втором этапе
нам нужно сделать так, чтобы при нажатии

00:05:54.340 --> 00:05:57.650
на кнопку заказа имя из текстового поля
сохранялось в переменной.

00:05:58.730 --> 00:06:03.140
Нам, людям, сразу видно
имя в этом поле, но приложение

00:06:03.140 --> 00:06:06.980
Android не знает, что мы хотим
добавить это имя в описание заказа.

00:06:08.070 --> 00:06:10.840
Оно все еще использует заданное имя Lyla.

00:06:10.840 --> 00:06:13.190
Нам нужно заменить его на это имя.

00:06:13.190 --> 00:06:16.540
Это задание похоже на то, когда нам
нужно было узнать, поставлена ли галочка

00:06:16.540 --> 00:06:19.560
или нет, чтобы обновить описание заказа.

00:06:19.560 --> 00:06:22.560
Мы еще не изучали то, как читается
текст из поля EditText, поэтому

00:06:22.560 --> 00:06:23.970
поищем нужную информацию в Google.

00:06:23.970 --> 00:06:28.790
Я буду искать то, как получить
текст из поля EditText на Android.

00:06:29.190 --> 00:06:30.890
Первый результат поиска, похоже, подходит.

00:06:30.890 --> 00:06:32.720
Это вопрос о переполнении стека.

00:06:32.720 --> 00:06:35.880
Я могу прочитать вопрос, но
мне важнее ответ.

00:06:35.880 --> 00:06:40.050
Я быстро просмотрю страницу, чтобы
понять, поможет она мне или нет.

00:06:40.050 --> 00:06:43.510
У этого ответа есть зеленая галочка
и много голосов, поэтому

00:06:43.510 --> 00:06:45.610
я прочитаю его более внимательно.

00:06:45.610 --> 00:06:47.810
Я начинаю с этого отрезка кода.

00:06:47.810 --> 00:06:51.820
Кажется, этот код принадлежит
к классу Activity, потому что

00:06:51.820 --> 00:06:53.430
в нем используется метод FindViewById.

00:06:53.430 --> 00:06:57.970
Эта строка кода производит поиск
элемента View с этим ID в иерархии View.

00:06:57.970 --> 00:07:01.910
Когда этот элемент View найден,
он приводится к типу EditText,

00:07:01.910 --> 00:07:05.250
а затем помещается
в переменную, называемую text.

00:07:05.250 --> 00:07:09.100
Во второй строке происходит
объявление переменной value

00:07:09.100 --> 00:07:10.330
и помещение этого в нее.

00:07:10.330 --> 00:07:14.751
В этой части кода много скобок,
точек и слов, но можно догадаться,

00:07:14.751 --> 00:07:18.780
что она служит для
получения текста из этого поля EditText.

00:07:19.280 --> 00:07:23.260
Полученный текст сохранится
в переменной value.

00:07:23.260 --> 00:07:27.120
Скопируем и вставим этот код в наше
приложение и посмотрим, сработает ли он.

00:07:27.120 --> 00:07:31.480
В классе MainActivity я
вставлю код под методом submitOrder.

00:07:31.480 --> 00:07:34.400
Я выбрала этот метод, поскольку
именно здесь происходит нажатие

00:07:34.400 --> 00:07:37.170
кнопки заказа и именно отсюда
должно читаться поле ввода имени.

00:07:38.230 --> 00:07:41.260
Я вставлю код
из поста о переполнении стека

00:07:41.260 --> 00:07:42.320
в верхнюю часть метода.

00:07:43.110 --> 00:07:46.610
Сразу же появляется ошибка:
этот символ невозможно обработать.

00:07:46.610 --> 00:07:50.340
Нам нужно заменить его на
ID поля ввода имени.

00:07:50.340 --> 00:07:52.440
Возвратившись к layout.xml,

00:07:52.440 --> 00:07:56.588
мы видим, что для поля EditText
назначен ID name_field.

00:07:56.588 --> 00:08:01.410
Поэтому в файле Java я
заменю это на R.id.name_field.

00:08:01.410 --> 00:08:04.530
Ошибок больше нет, поэтому
я попытаюсь запустить приложение.

00:08:04.530 --> 00:08:07.400
Но как узнать, работает
ли этот код или нет?

00:08:07.400 --> 00:08:10.520
Я могла бы использовать журнал сообщений,

00:08:10.520 --> 00:08:14.300
чтобы проверить, что в значении
точно сохраняется имя из этого поля.

00:08:14.300 --> 00:08:16.760
Вот код для создания сообщения журнала.

00:08:16.760 --> 00:08:20.110
Я печатаю Name:,
а затем строку value [значение].

00:08:21.110 --> 00:08:23.650
Value — это неопределенное название
для этой переменной, поэтому

00:08:23.650 --> 00:08:25.260
я заменю его на name.

00:08:25.260 --> 00:08:28.460
Таким образом, название переменной
будет более описательным.

00:08:28.460 --> 00:08:31.005
Заодно я заменю
название переменной для EditText

00:08:31.005 --> 00:08:33.760
на nameField.

00:08:33.760 --> 00:08:37.070
Text можно перепутать
с другими значениями в нашем коде.

00:08:37.070 --> 00:08:40.299
Теперь запустим приложение
и проверим сообщение в журнале.

00:08:40.299 --> 00:08:41.340
Так.

00:08:41.340 --> 00:08:42.490
Если я заполню форму заказа

00:08:42.490 --> 00:08:45.690
и затем нажму на кнопку заказа,
я смогу проверить журнал сообщений.

00:08:46.810 --> 00:08:51.210
Я вижу новое сообщение для MainActivity
с текстом Name: Antigravity Anthony.

00:08:51.210 --> 00:08:52.680
Значит, все сработало.

00:08:52.680 --> 00:08:56.360
Этот код действительно вывел
имя из этого поля.

00:08:56.360 --> 00:08:59.620
Прекрасно. Теперь, когда имя пользователя

00:08:59.620 --> 00:09:04.060
сохранено в переменной и с помощью журнала
сообщений мы убеждены, что оно правильное,

00:09:04.060 --> 00:09:06.830
мы можем обновить описание
заказа, чтобы в нем отображалось это имя.

00:09:07.380 --> 00:09:10.280
Чтобы в описании заказа
отображалось правильное имя,

00:09:10.280 --> 00:09:13.860
нам нужно, чтобы оно значилось
как параметр ввода для этого метода.

00:09:13.860 --> 00:09:16.610
Это значит, что, когда мы вызываем
метод createOrdersummary,

00:09:16.610 --> 00:09:20.450
мы должны установить эту
переменную Name как параметр ввода.

00:09:20.450 --> 00:09:22.410
Давайте сначала это и сделаем.

00:09:22.410 --> 00:09:24.840
Если я добавлю Name
в качестве аргумента ввода,

00:09:24.840 --> 00:09:29.660
то появится ошибка, поскольку вызов метода
не совпадает с сигнатурой метода.

00:09:29.660 --> 00:09:31.950
Пройдя вниз по странице
к определению метода,

00:09:31.950 --> 00:09:35.670
я добавляю String name
в качестве параметра ввода.

00:09:35.670 --> 00:09:38.410
Я также обновлю информацию о коде.

00:09:38.410 --> 00:09:41.600
Теперь я могу использовать эту переменную
внутри метода createOrderSummary.

00:09:41.600 --> 00:09:46.630
Я сотру заданное имя
и привяжу сюда эту переменную Name.

00:09:47.930 --> 00:09:51.360
Резюмируем вышесказанное. Мы получаем
имя из поля name_field и затем

00:09:51.360 --> 00:09:55.590
направляем его как параметр ввода
в метод createOrderSummary.

00:09:55.590 --> 00:09:59.620
Внутри этого метода мы
присоединяем имя к описанию заказа.

00:09:59.620 --> 00:10:01.720
Запустим приложение и проверим наш код.

00:10:01.720 --> 00:10:05.200
Приложение запускается, и я могу
ввести имя, выбрать топинг,

00:10:05.200 --> 00:10:06.790
а затем выбрать количество.

00:10:06.790 --> 00:10:08.600
Затем я нажимаю на кнопку заказа.

00:10:08.600 --> 00:10:11.190
Теперь видно, что в описании заказа
содержится имя,

00:10:11.190 --> 00:10:12.190
которое я ввела ранее.

00:10:12.190 --> 00:10:13.458
Ура!

00:10:13.458 --> 00:10:17.140
Если я изменю имя и нажму на
кнопку заказа, описание снова обновится.

00:10:17.140 --> 00:10:18.200
Это здорово.

00:10:18.200 --> 00:10:22.440
Теперь, когда приложение полностью
работает, я удаляю журнальное сообщение.

00:10:22.440 --> 00:10:25.300
Можно запустить приложение снова, чтобы
убедиться, что все работает.

00:10:26.000 --> 00:10:28.640
Теперь вернемся к началу и
ответим на эти проверочные вопросы.

00:10:28.640 --> 00:10:31.700
Элемент View, который мы добавили
в приложение, называется EditText.

00:10:31.700 --> 00:10:35.260
Во втором вопросе спрашивается,
какой метод Java мы вызывали, чтобы

00:10:35.260 --> 00:10:37.010
получить текст из этого элемента View.

00:10:38.120 --> 00:10:40.510
Мы можем ответить на него,
возвратившись к нашему коду.

00:10:40.910 --> 00:10:42.885
Ищем иерархию элементов View для

00:10:42.885 --> 00:10:46.710
объекта EditText, который
представлял поле ввода имени.

00:10:46.710 --> 00:10:49.570
Мы поместили это в переменную nameField.

00:10:49.570 --> 00:10:52.310
На этот объект мы вызывали метод.

00:10:52.310 --> 00:10:56.310
Мы вызвали метод getText,
который не берет аргументов ввода

00:10:56.310 --> 00:10:58.500
и чье значение возврата — другой объект.

00:10:59.510 --> 00:11:01.460
Это приводит нас к третьему вопросу.

00:11:01.460 --> 00:11:04.790
Какой тип возвращаемых данных
у метода getText?

00:11:04.790 --> 00:11:06.330
Ответ — Editable.

00:11:06.330 --> 00:11:09.540
Я поняла это, посмотрев
справочную информацию об Android.

00:11:09.540 --> 00:11:14.320
На странице класса Edit Text
можно увидеть все общественные методы.

00:11:14.320 --> 00:11:17.970
GetText числится как метод,
возвращающий текст, который

00:11:17.970 --> 00:11:19.350
отображает TextView.

00:11:19.350 --> 00:11:21.460
Тип возвращаемых данных — Editable.

00:11:21.960 --> 00:11:27.280
Это возвращает объект Editable, и мы
можем вызывать на него другой метод,

00:11:27.280 --> 00:11:30.750
добавив точку и название метода.

00:11:30.750 --> 00:11:35.730
В данном случае мы вызываем
метод toString на объект Editable,

00:11:35.730 --> 00:11:38.790
и метод toString
возвращает строку, так что

00:11:38.790 --> 00:11:41.050
ее можно поместить в переменную Name.

00:11:42.080 --> 00:11:45.880
Это более сложная техника,
называемая цепным вызовом методов.

00:11:45.880 --> 00:11:49.560
Сначала мы вызываем один метод,
получаем значение возврата

00:11:49.560 --> 00:11:52.800
и затем вызываем другой метод,
и если он возвращает объект, то

00:11:52.800 --> 00:11:54.280
на него можно вызвать другой метод.

00:11:54.280 --> 00:11:57.690
Можно продолжать вызывать
методы один за другим.

00:11:57.690 --> 00:12:01.230
Мы вызываем методы по цепочке для того,
чтобы метод getText возвращал

00:12:01.230 --> 00:12:02.650
объект Editable.

00:12:02.650 --> 00:12:05.920
Объект Editable невозможно
поместить внутри переменной String,

00:12:05.920 --> 00:12:09.980
что показывает ошибка Android Studio,
говорящая о несовместимости типов.

00:12:09.980 --> 00:12:14.410
Поэтому, если мы добавим метод toString,
то значением возврата всего этого

00:12:14.410 --> 00:12:17.790
будет строка,
а ее можно поместить в переменную Name.

00:12:17.790 --> 00:12:20.550
Мы можем убедиться в этом,
проверив справочную информацию.

00:12:20.550 --> 00:12:23.160
Метод getText возвращает объект Editable.

00:12:23.160 --> 00:12:25.660
Я нажму сюда. В классе Editable

00:12:25.660 --> 00:12:27.880
мы должны найти метод toString.

00:12:27.880 --> 00:12:29.000
Переходим вниз по странице.

00:12:29.000 --> 00:12:32.530
В списке общественных методов
toString не перечислен.

00:12:32.830 --> 00:12:34.670
Но есть еще и унаследованные методы.

00:12:34.670 --> 00:12:38.520
Я открываю раскрывающееся меню
и вижу метод toString.

00:12:38.520 --> 00:12:40.930
Его возвращаемое значение — строка.

00:12:40.930 --> 00:12:44.850
Итак, закрепим пройденное.
Вызов этого метода возвращает

00:12:44.850 --> 00:12:48.000
объект Editable, затем мы вызываем
на него метод toString.

00:12:48.000 --> 00:12:50.670
Метод toString возвращает строку,
таким образом,

00:12:50.670 --> 00:12:53.680
весь этот код на правой стороне
возвращает строку.

00:12:53.680 --> 00:12:57.150
Ее можно поместить
в переменную string, называемую name.

00:12:58.270 --> 00:13:00.180
Уф, это было очень длинное задание.

00:13:01.330 --> 00:13:04.070
Теперь вы можете передохнуть,
а потом возвращаетесь, потому что

00:13:04.070 --> 00:13:06.200
нам нужно понять, как изменить цену
на основании того,

00:13:06.200 --> 00:13:07.620
что заказал пользователь.

00:13:07.620 --> 00:13:09.740
Мы сделаем это,
используя поток управления.

