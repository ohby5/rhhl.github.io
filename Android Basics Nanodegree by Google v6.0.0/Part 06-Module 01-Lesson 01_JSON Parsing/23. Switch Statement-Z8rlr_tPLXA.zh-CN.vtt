WEBVTT
Kind: captions
Language: zh-CN

00:00:00.400 --> 00:00:03.440
现在我们先暂时退出 Quake Report 应用来学习一个

00:00:03.440 --> 00:00:07.300
要在应用的后续编码测试中 用到的新控制流结构

00:00:07.300 --> 00:00:11.410
在第一节入门课程中 我们将 通过使用

00:00:11.410 --> 00:00:18.050
特殊 Java 关键字 if 和 else 学习 第一个控制结构 即 if/else 语句

00:00:18.050 --> 00:00:20.960
你可以创建不同 的执行路径

00:00:20.960 --> 00:00:24.080
现在 你不必逐个 执行每行代码

00:00:24.080 --> 00:00:28.240
你可以先执行 一个代码块

00:00:28.240 --> 00:00:33.050
然后在某个条件成立时 跳过另一个代码块

00:00:33.050 --> 00:00:36.800
现在我们来探讨一下 Java 中 称为 switch 语句的相关内容

00:00:36.800 --> 00:00:39.770
Switch 语句为执行 非布尔值条件的

00:00:39.770 --> 00:00:43.260
不同离散值提供了 一种独特逻辑

00:00:43.260 --> 00:00:46.680
下面是我们根据名为 numberOfStars 的变量

00:00:46.680 --> 00:00:51.180
执行不同代码路径 的代码示例

00:00:51.180 --> 00:00:53.680
该变量代表餐馆 收到的星数

00:00:54.880 --> 00:00:58.860
现在 在这些案例语句所 代表的每个代码路径中

00:00:58.860 --> 00:01:01.710
我们可以执行任何 我们想要的逻辑

00:01:01.710 --> 00:01:05.690
我们恰恰仅需要将评级 (rating) 字符串设置为不同的值

00:01:05.690 --> 00:01:09.650
使用 switch 语句便无需 编写许多 if 语句或

00:01:09.650 --> 00:01:11.430
嵌套 if 语句

00:01:11.430 --> 00:01:15.050
现在 你也可以使用 if else 语句 得到我们在上述 switch 语句中

00:01:15.050 --> 00:01:16.740
见证的相同逻辑

00:01:16.740 --> 00:01:20.640
但 if else 方法过于繁复 而且包含许多重复

00:01:20.640 --> 00:01:25.620
例如 我们需要不断编写或检查 numberOfStars 等于什么 而且

00:01:25.620 --> 00:01:27.910
每次都需要更改每个值

00:01:27.910 --> 00:01:31.720
如 检查 numberOfStars 是否等于 1

00:01:31.720 --> 00:01:36.080
检查 numberOfStars 是否等于 2、3 等等

00:01:37.470 --> 00:01:40.300
Switch 语句含有 关键字 switch

00:01:40.300 --> 00:01:44.280
后面带有我们要 在圆括号内估算的值

00:01:44.280 --> 00:01:47.720
现在 在这些大括号之间 我们要继续

00:01:47.720 --> 00:01:48.889
列出我们的案例

00:01:50.190 --> 00:01:53.700
每个案例包含一个关键词 case

00:01:53.700 --> 00:01:58.680
接着是预期值 后面是冒号 例如 当 numberOfStars

00:01:58.680 --> 00:02:04.420
变量等于 1 时 我们执行 此案例区块内的几行代码

00:02:04.420 --> 00:02:08.180
由于评级 (rating) 字符串设置为糟糕的餐馆 (bad restaurant) 因此这种情况才会发生

00:02:08.180 --> 00:02:10.570
我们继续逐行执行

00:02:10.570 --> 00:02:14.670
switch 语句中的代码 直至达到 break 语句

00:02:14.670 --> 00:02:17.460
接着就该执行整个 switch 语句本身了

00:02:17.460 --> 00:02:20.960
然后继续执行 后续代码

00:02:20.960 --> 00:02:21.750
例如 我们假设

00:02:21.750 --> 00:02:25.230
numberOfStars 变量 不等于 1

00:02:25.230 --> 00:02:28.930
然后 我们将跳过整个第一个 案例 转至下一个案例

00:02:28.930 --> 00:02:31.690
我们检查其中的 numberOfStars 变量是否等于 2

00:02:31.690 --> 00:02:33.210
如果等于

00:02:33.210 --> 00:02:38.640
就执行其中的代码 将评级 (rating) 字符串设置为一般餐馆 (okay restaurant)

00:02:38.640 --> 00:02:41.450
然后继续执行语句代码 直至达到 "break" 语句

00:02:41.450 --> 00:02:43.990
然后 我们退出 整个 switch 语句

00:02:43.990 --> 00:02:47.070
我们无需再继续检查 其他案例是否相符

00:02:47.070 --> 00:02:49.440
此时 如果 numberOfStars 变量不等于 1 或

00:02:49.440 --> 00:02:54.050
2 则我们将继续执行第三个案例 而且你已了解此处的情况

00:02:54.050 --> 00:02:57.330
现在 只要案例值还是整数 你就可设置所需数目的案例

00:02:57.330 --> 00:02:58.700
的案例

00:02:58.700 --> 00:03:02.330
因为 switch 语句中的 原始变量是整数

00:03:02.330 --> 00:03:06.160
如果你的 switch 语句之前测试 的是字符串变量的值

00:03:06.160 --> 00:03:08.340
那么案例值也 必须是字符串

00:03:08.340 --> 00:03:13.470
每个案例中的代码行数 可以是任意数

00:03:13.470 --> 00:03:17.720
你可以在某个案例中编写 0 行代码、20 行或更多行代码

00:03:17.720 --> 00:03:19.690
在这些代码中有一个特殊字 default

00:03:19.690 --> 00:03:23.670
表示 如果 numberOfStars 变量不等于其中任何案例值

00:03:23.670 --> 00:03:27.140
那么 switch 便会提供一个 可选的默认 (default) 案例

00:03:27.140 --> 00:03:30.280
此时我们将使用关键字 default 后面跟一个冒号

00:03:31.330 --> 00:03:34.450
在进入此案例时 评级, (rating) 字符串将会变为

00:03:34.450 --> 00:03:35.390
未提供评级 （no rating available）

00:03:35.390 --> 00:03:38.510
随后 我们便会中断 此 switch 语句

00:03:38.510 --> 00:03:41.560
总之 最好具有一个 默认 (default) 案例

00:03:41.560 --> 00:03:45.280
以防出现具有原始值但你 却未对其编写案例的情况

00:03:45.280 --> 00:03:48.930
至少 在你的代码中要有 合理的行为作为备份

00:03:48.930 --> 00:03:52.100
也许你也注意到了 switch 语句具有十分特别的格式

00:03:52.100 --> 00:03:55.960
并使用具有特殊含义的关键字 如 switch 和 case

00:03:55.960 --> 00:03:59.250
我们查看 Java 关键字列表 便可 验证此列表中出现的这些

00:03:59.250 --> 00:04:00.410
词

00:04:00.410 --> 00:04:03.070
例如 switch 是一个 Java 关键字

00:04:03.070 --> 00:04:06.820
我们还可以看到 case、 break 和 default

00:04:06.820 --> 00:04:08.940
因此 请确保正确使用 这些关键字 这样

00:04:08.940 --> 00:04:11.360
Java 才能正确 解释你的代码

00:04:11.360 --> 00:04:13.620
这里是另一个 switch 语句的示例

00:04:13.620 --> 00:04:16.230
其中我们使用名为 grade 的变量值

00:04:16.230 --> 00:04:21.399
现在 它是一个字符数据类型 表示它将储存 A

00:04:21.399 --> 00:04:22.100
B 和 C 这样的单一字符

00:04:22.100 --> 00:04:26.870
正如你所见 字符串消息 会随成绩 (grade) 值而变化

00:04:26.870 --> 00:04:32.210
例如 如果其值为 A 则字符串消息 等于出色的工作 （Superb work）

00:04:32.210 --> 00:04:35.570
如果得到的成绩 (grade) 为 B 则消息等于不错的工作 (Great job)

00:04:36.750 --> 00:04:39.260
此示例还有一点 非常有趣

00:04:39.260 --> 00:04:41.710
那便是你可以继续 循环其他案例

00:04:41.710 --> 00:04:45.000
这意味着 执行路径 不会因为你完成了

00:04:45.000 --> 00:04:47.750
一个案例就退出所遇到的 switch 语句

00:04:47.750 --> 00:04:51.040
若要退出 你需要明确 添加中断 (break)

00:04:51.040 --> 00:04:54.330
请注意 D 案例末尾 没有 break 语句

00:04:54.330 --> 00:04:58.230
当成绩 (grade) 为 D 时 编码会 继续循环 F 案例的条件编码

00:04:58.230 --> 00:05:02.810
对于 F 案例 消息字符串设置为 需要改进 (Needs improvement)

00:05:02.810 --> 00:05:05.620
至此 我们知道执行流 会继续循环

00:05:05.620 --> 00:05:09.170
每行代码 直至达到第一 个 break 语句为止

00:05:09.170 --> 00:05:10.530
随后退出循环

00:05:10.530 --> 00:05:14.000
总的来说 在没有 break 语句的案例中

00:05:14.000 --> 00:05:17.080
如 D 案例 实际上代码 会继续循环下去

00:05:17.080 --> 00:05:21.100
这意味着 此逻辑 其实是在 D 与

00:05:21.100 --> 00:05:25.720
F 案例之间公用的 当然直至我们达到此 break 语句为止 随后我们会退出循环

00:05:25.720 --> 00:05:29.410
现在 我们来测试一下你是否能够 理解以下代码中的 switch 语句

00:05:29.410 --> 00:05:30.470
当你走进一家餐馆时

00:05:30.470 --> 00:05:34.450
他们有时会问你具体要在 食物中加入多少辣料

00:05:34.450 --> 00:05:36.700
此时 需给出明确的辣味程度

00:05:36.700 --> 00:05:39.310
那么 如何使用 switch 语句来 相应地调整口味呢？

00:05:39.310 --> 00:05:43.560
我想让你利用此表 其中 每列都给出了明确的

00:05:43.560 --> 00:05:47.060
spiceLevel 希望你能将这些 值应用到 switch 语句

00:05:47.060 --> 00:05:50.860
然后 告诉我要将哪些值设置 为口味 (flavor) 字符串

00:05:50.860 --> 00:05:54.950
例如 如果 spiceLevel 为 0 我们可在这里的 switch

00:05:54.950 --> 00:05:58.200
看到 无法将任何一个 案例估算为真 (true)

00:05:58.200 --> 00:06:02.290
这样 我们的代码便会一直 循环下去直至 default 案例

00:06:02.290 --> 00:06:05.550
此时的口味 (flavor) 字符串便会 设置为不辣 (not spicy)

