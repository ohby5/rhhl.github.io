WEBVTT
Kind: captions
Language: zh-CN

00:00:00.776 --> 00:00:03.647
到目前为止 你对 JSON 解析的理解非常到位

00:00:03.647 --> 00:00:08.037
那么 让我们更仔细地看一看 一些真实的 USGS 数据 然后逐步

00:00:08.037 --> 00:00:11.705
构建可记录于你的快速 报告应用以在 JSON 中

00:00:11.705 --> 00:00:12.570
解析的任务

00:00:12.570 --> 00:00:17.362
在 USGS 文档的主要 PH 上 我想向下滚动至一个有关

00:00:17.362 --> 00:00:22.889
方法的部分 然后转至 名为 query 的特定的分部

00:00:22.889 --> 00:00:26.507
现在 在这个部分中 你有 几个 URL 查询示例

00:00:26.507 --> 00:00:29.389
你可创建这些它们以 从 API 重新获取数据

00:00:29.389 --> 00:00:34.097
我打算在第二行获取一个变量 以使其处于最新状态

00:00:34.097 --> 00:00:36.870
并且我会继续执行它

00:00:36.870 --> 00:00:41.539
那么 这是你在从 API 请求特定数据时将会返回的

00:00:41.539 --> 00:00:44.410
实际的原始文本响应 其采用 GeoJSON 格式

00:00:44.410 --> 00:00:46.435
那么现在 是时候深入了解该数据并

00:00:46.435 --> 00:00:49.601
检索我们所需的用于 应用的特定信息了

00:00:49.601 --> 00:00:53.858
现在 你可能已 注意到的一件事是

00:00:53.858 --> 00:00:56.537
出现了大量的文本

00:00:56.537 --> 00:00:59.540
没有任何换行符 其实际目的是要使

00:00:59.540 --> 00:01:02.780
响应变得更紧凑、更易于 通过 Internet 进行传输

00:01:02.780 --> 00:01:06.640
但是作为一个权衡 这将使我们人类 真的更难以读取

00:01:06.640 --> 00:01:10.754
所以幸运的是 我们可以使用 JSON 格式化工具来格式化 JSON

00:01:10.754 --> 00:01:14.120
这样一来 我们人类在自行 读取和排除故障时将变得更加轻松一点

00:01:14.120 --> 00:01:17.804
数据实际上将会是相同的 只是在显示给我们时

00:01:17.804 --> 00:01:21.499
换行符和空格会更多一些 并且我们可以在线搜索此类工具

00:01:21.499 --> 00:01:27.391
那么 如果你搜索 json 格式化程序 你将获得数个选项

00:01:27.391 --> 00:01:29.240
让我们看一看第一个选项 它看上去非常不错

00:01:30.260 --> 00:01:35.089
因此我会将我们从原始测试 查询重新获得的原始 JSON

00:01:35.089 --> 00:01:39.603
进行复制粘贴 并且我会将其置于 该 JSON 格式化工具中的此处

00:01:39.603 --> 00:01:42.069
然后我们将继续查找程序

00:01:42.069 --> 00:01:43.191
这看起来已经更好了

00:01:43.191 --> 00:01:45.522
那么 让我们使用全屏来深入了解一下

00:01:45.522 --> 00:01:46.937
非常棒

00:01:46.937 --> 00:01:48.656
现在 可读性真的有所提高

00:01:48.656 --> 00:01:52.852
现在我们有许多已格式化的 JSON 数据可供我们通读

00:01:52.852 --> 00:01:53.684
正如你可能注意到的那样

00:01:53.684 --> 00:01:56.192
有一个我们可能 非常熟悉的树结构

00:01:56.192 --> 00:02:01.008
你可能会在Windows Explore 或 Mac OS Finder 中看到的内容

00:02:01.008 --> 00:02:03.475
这样读起来容易多了

00:02:03.475 --> 00:02:09.020
请注意 你有这些减号和 加号按钮 你可使用它们来展开

00:02:09.020 --> 00:02:11.910
和折叠 JSON 响应的分部

00:02:11.910 --> 00:02:15.600
这样一来你便可以更轻松地 同时读取一个部分

00:02:15.600 --> 00:02:19.310
那么 当我路由 JSON 对象时 当我们被使用该工具在此处向下折叠时

00:02:20.340 --> 00:02:25.000
我们此时有一个名为 features 的键 其实际上映射到 JSON 数组

00:02:25.000 --> 00:02:28.480
此外 我们知道其位于 左右括号中

00:02:28.480 --> 00:02:32.347
结果是 此数组实际上 包含一个特征作为

00:02:32.347 --> 00:02:33.757
单一地震的含义

00:02:33.757 --> 00:02:37.890
因此 此数组中的每一个特征或者 此数组中的每一个元素实际上都映射到

00:02:37.890 --> 00:02:40.554
每个特定 地震的信息

00:02:40.554 --> 00:02:43.052
所以 如果你看一下 便会发现我们在此处折叠了一点

00:02:43.052 --> 00:02:46.548
如果你看一看此数组中的 第一个元素 便会发现我们已展开了

00:02:46.548 --> 00:02:49.608
我们看到其中包含一个 JSON 对象 该对象具有所有详细信息

00:02:49.608 --> 00:02:52.680
我们所需要的第一个 数组的全部元信息

00:02:52.680 --> 00:02:55.447
同样 如果我们展开 第二个元素

00:02:55.447 --> 00:02:57.475
我们可看到一组相似的数据

00:02:57.475 --> 00:03:00.789
因此 正如你在此处所看到的那样 你可同时浏览数组中的一个部分

00:03:00.789 --> 00:03:02.659
并且看一看每个地震特征

00:03:02.659 --> 00:03:05.509
从我们的数据请求 返回的特定信息

00:03:05.509 --> 00:03:06.090
这相当不错

00:03:06.090 --> 00:03:08.862
那么 让我们再 向下折叠一点

00:03:08.862 --> 00:03:12.612
现在回到我们 JSON 对象的根 我们有四个键

00:03:12.612 --> 00:03:18.350
我们有类型、元数据、 特征和这个名为 bbox 的项目

00:03:18.350 --> 00:03:21.454
现在我们真的只是对 features 键感兴趣 因为其中包含

00:03:21.454 --> 00:03:23.940
我们所需的用于我们的应用的 所有地震数据

00:03:23.940 --> 00:03:27.113
现在 你将注意到特征 数组到现在为止包含十个对象

00:03:27.113 --> 00:03:28.393
因为当我们实际上查询 API 时

00:03:28.393 --> 00:03:30.403
我们实际上 请求了十个结果

00:03:30.403 --> 00:03:34.910
现在 如果你看一看数组中的 第一个对象 我们可以看到

00:03:34.910 --> 00:03:38.306
如果我们向下折叠 其也会有四个键

00:03:38.306 --> 00:03:42.868
一个名为 type 一个名为 properties 一个名为 geometry

00:03:42.868 --> 00:03:44.425
最后一个为 ID

00:03:44.425 --> 00:03:45.219
所有这四个键

00:03:45.219 --> 00:03:48.412
都看起来像 properties 键 且具有我们所需的信息

00:03:48.412 --> 00:03:52.586
最后 我们可以看到 properties 键 映射到的数据或 JSON 对象

00:03:52.586 --> 00:03:55.760
如果我们在此处展开 其中将包含一系列键以及

00:03:55.760 --> 00:03:58.219
我们将需要的用于我们的应用的 相关数据

00:03:58.219 --> 00:04:01.444
此时我们获得了震级、 地点、时间和

00:04:01.444 --> 00:04:04.678
指向详细地震信息的 用户 URL

00:04:04.678 --> 00:04:08.486
在这下一个练习中 你将对 来自 USGS API 的 JSON

00:04:08.486 --> 00:04:11.080
响应中所提供的键值对 更加熟悉

00:04:11.080 --> 00:04:14.089
我们将为你提供 位于练习之下的注释中

00:04:14.089 --> 00:04:16.394
所链接的查询 URL

00:04:16.394 --> 00:04:19.826
首先 我想让你复制 我们为你提供的 URL

00:04:19.826 --> 00:04:24.060
并将其粘贴到 web 浏览器 然后你将重新获得一个 JSON 响应

00:04:24.060 --> 00:04:26.617
这将是许多一起进行测试的文本

00:04:26.617 --> 00:04:29.850
所以 继续进入 JSON 格式化程序 就像我们早期为你展示的那样

00:04:31.120 --> 00:04:35.150
然后 如果我们必须显示地震的 完整列表 我想让你在一张空白纸上

00:04:35.150 --> 00:04:39.030
画一个草图来描绘我们 查询报告应用的外观

00:04:40.150 --> 00:04:43.694
对于该列表上的第一个地震 我将查看 JSON 响应

00:04:43.694 --> 00:04:46.174
以在 futures 数组中 查找第一个地震

00:04:46.174 --> 00:04:49.353
现在 在该 JSON 对象内 我可以找到 magnitude 键

00:04:49.353 --> 00:04:51.803
在这种情况下 magnitude 为 7.2

00:04:51.803 --> 00:04:54.670
因此 我打算继续 将其写入我们的草图

00:04:56.530 --> 00:05:01.552
对该地震的位置 和日期执行相同过程

00:05:01.552 --> 00:05:04.747
你可能已注意到 时间 实际上是一个非常长的数字

00:05:04.747 --> 00:05:08.485
其以毫秒为单位 始于 1970 年 1 月 1 日

00:05:08.485 --> 00:05:09.855
这称为 Unix 时间

00:05:09.855 --> 00:05:13.350
因此 如果你想知道 其所对应的实际日期是什么

00:05:13.350 --> 00:05:16.965
你实际上可以在线找到一个工具 来将以毫秒为单位的时间转换为

00:05:16.965 --> 00:05:17.808
一个实际日期

00:05:17.808 --> 00:05:20.531
我会继续 将一个示例保留在注释中

00:05:20.531 --> 00:05:25.768
但是 对于此练习 对于该草图 你可保留以毫秒为单位的时间

00:05:25.768 --> 00:05:29.120
现在 你想要重复那些步骤 以完成写入有关将填写于

00:05:29.120 --> 00:05:31.390
列表之中的 地震的其余部分的信息

