WEBVTT
Kind: captions
Language: zh-CN

00:00:00.490 --> 00:00:03.401
好了 我们会快速地进行一下讲解 因为这是上一课的

00:00:03.401 --> 00:00:04.660
复习

00:00:04.660 --> 00:00:07.180
如果需要回顾一下 请使用下面的链接

00:00:07.180 --> 00:00:11.010
要实现理想中的屏幕样式 我们需要对列表进行修改

00:00:11.010 --> 00:00:13.920
使每个列表项 显示更多的信息

00:00:13.920 --> 00:00:17.210
现在 我们不使用框架提供的 简单列表项 XML 布局

00:00:17.210 --> 00:00:20.220
我们需要为一个列表项创建 自己的 XML 布局

00:00:20.220 --> 00:00:22.904
使其包含 三个 TextView

00:00:24.180 --> 00:00:25.724
为此

00:00:25.724 --> 00:00:30.146
我创建了一个新的布局文件 earthquake_list_item.xml

00:00:30.146 --> 00:00:34.440
如果我们转到 TextView 就能查看我们的 XML 布局

00:00:34.440 --> 00:00:36.078
在这个列表项文件中

00:00:36.078 --> 00:00:40.070
有一个水平的 LinearLayout 其中包含三个 TextView

00:00:40.070 --> 00:00:44.150
一个表示地震级数 一个表示位置 还有一个表示日期

00:00:45.610 --> 00:00:47.950
现在我们不用管 布局的外观

00:00:47.950 --> 00:00:52.880
我刚刚为所有子项设置了 布局宽度 0dp 和布局权重 1

00:00:52.880 --> 00:00:54.900
把所有的视图 平均分摊

00:00:54.900 --> 00:01:00.010
我还在列表项布局中添加了 16 dip 的填充

00:01:00.010 --> 00:01:01.930
使列表项不至于 高度太短

00:01:03.100 --> 00:01:07.540
如果我们现在切换到设计窗格 可以看到临时的占位符数据

00:01:07.540 --> 00:01:09.540
用以确保布局外观 与我们的初衷一样

00:01:10.560 --> 00:01:15.250
下一步 我们将 XML 工具命名空间 添加到根 LinearLayout 元素

00:01:15.250 --> 00:01:18.480
在声明 Android 命名空间的 行下面

00:01:18.480 --> 00:01:22.720
然后我们便可以在每个 TextView 中 使用 tools:text 属性

00:01:22.720 --> 00:01:24.920
并添加一些占位符文本

00:01:24.920 --> 00:01:28.400
属性的作用是添加文本 这些文本显示在

00:01:28.400 --> 00:01:31.010
Android Studio 预览窗格中 但实际运行应用时不会显示

00:01:32.100 --> 00:01:35.920
很好 现在我们的自定义 列表项布局完成了

00:01:35.920 --> 00:01:39.000
我们需要一个 Java 对象 来放置每个列表项中显示的

00:01:39.000 --> 00:01:41.350
所有地震信息

00:01:41.350 --> 00:01:44.830
现在我回到 Earthquake.java 文件 文件中定义了一个

00:01:44.830 --> 00:01:49.420
新的 earthquake 类 表示一次地震

00:01:49.420 --> 00:01:53.000
然后我们定义了 字符串类型的三个全局变量

00:01:53.000 --> 00:01:55.300
分别用于表示地震级数 位置

00:01:55.300 --> 00:01:59.090
和日期 因为每次地震 都有这三种属性

00:01:59.090 --> 00:02:00.390
然后在 earthquake 类的

00:02:00.390 --> 00:02:03.360
公共构造函数中 根据传递到构造函数中的值

00:02:03.360 --> 00:02:06.370
对三个成员变量 进行初始化

00:02:06.370 --> 00:02:09.970
由于这些全局变量是私有的 我们需要创建公共 getter 方法

00:02:09.970 --> 00:02:14.768
使其他类能够访问 该地震信息

00:02:14.768 --> 00:02:17.300
现在我们来看一下 EarthquakeActivity 类

00:02:17.300 --> 00:02:20.030
在这里我们可以通过 调用刚刚创建的构造函数

00:02:20.030 --> 00:02:22.189
创建新的地震对象

00:02:23.370 --> 00:02:25.040
请注意这一行

00:02:25.040 --> 00:02:27.233
我想要一个 包含实际地震对象的 ArrayList

00:02:27.233 --> 00:02:30.520
而不是创建一个 包含字符串的 ArrayList

00:02:30.520 --> 00:02:32.550
然后我创建了一个 新的地震对象

00:02:32.550 --> 00:02:35.420
并将其添加到列表中 每次添加一个

00:02:35.420 --> 00:02:37.920
针对每次地震 我编了一些

00:02:37.920 --> 00:02:40.210
级数和日期

00:02:40.210 --> 00:02:42.970
然后我们必须创建 自定义 EarthquakeAdapter

00:02:42.970 --> 00:02:46.000
用于显示地震列表

00:02:46.000 --> 00:02:50.175
现在我们将 EarthquakeAdapter 定义为 ArrayAdapter 父类的扩展

00:02:50.175 --> 00:02:52.880
并且覆盖 getView 方法

00:02:52.880 --> 00:02:56.040
使我们能控制 列表项视图的创建方式

00:02:56.040 --> 00:03:00.600
调用 getView 时 我们可以检查 是否可以使用回收视图

00:03:00.600 --> 00:03:03.180
如果不能 我们使用 earthquake_list_item XML 文件中定义的

00:03:03.180 --> 00:03:05.640
新列表项布局

00:03:05.640 --> 00:03:08.930
然后便可以使用 传入的位置参数

00:03:08.930 --> 00:03:12.280
从地震列表中 获取正确地震对象的引用

00:03:12.280 --> 00:03:15.940
然后我们可以开始将 地震对象中的数据绑定到

00:03:15.940 --> 00:03:17.750
列表项布局的视图

00:03:17.750 --> 00:03:21.140
我们根据视图 ID 在列表中找到每个 TextView

00:03:21.140 --> 00:03:22.990
并为其设置相应的数据

00:03:24.130 --> 00:03:27.110
列表项中给定位置 出现每次地震的正确数据之后

00:03:27.110 --> 00:03:30.310
我们可以将视图 返回给调用方

00:03:30.310 --> 00:03:34.510
这里的调用方是 ListView 它将会获取所有这些列表项

00:03:34.510 --> 00:03:35.414
并将它们显示在屏幕上

00:03:35.414 --> 00:03:38.690
有关 ListView 和适配器的 更详尽解释

00:03:38.690 --> 00:03:42.760
请参照最后一课 最后一课有一整节专门讲解这一主题

00:03:42.760 --> 00:03:44.790
下面是链接

00:03:44.790 --> 00:03:47.220
让我们回到 EarthquakeActivity

00:03:47.220 --> 00:03:51.029
我们可以通过 传入地震列表

00:03:51.029 --> 00:03:54.730
然后在 ListView 上设置适配器 来创建新的 earthquake 适配器

00:03:54.730 --> 00:03:57.644
现在让我们在设备上运行一下

00:03:57.644 --> 00:03:59.390
运行结果就是这样 十分不错

