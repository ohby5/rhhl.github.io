WEBVTT
Kind: captions
Language: pt-BR

00:00:00.567 --> 00:00:04.167
Vamos falar dos possíveis valores
que podem estar do lado direito

00:00:04.200 --> 00:00:05.968
dos nossos pares chave-valor.

00:00:06.000 --> 00:00:09.667
Já vimos que as chaves fazem
referência a dados permanentes,

00:00:09.701 --> 00:00:13.534
como números, booleans
e strings.

00:00:14.167 --> 00:00:15.868
Mas também podem
representar

00:00:15.901 --> 00:00:17.601
blocos de dados
mais complexos

00:00:17.634 --> 00:00:19.767
em formas de objetos
e arrays.

00:00:19.801 --> 00:00:20.934
É isso mesmo.

00:00:20.968 --> 00:00:23.400
Uma chave pode apontar
para outros objetos aninhados

00:00:23.434 --> 00:00:25.434
ou arrays de outros objetos.

00:00:25.467 --> 00:00:27.834
Vamos dar uma olhada
no exemplo de sapato de novo.

00:00:27.868 --> 00:00:29.834
Você pode achar que
a chave de estilo

00:00:29.868 --> 00:00:31.567
mapeia para um
objeto aninhado

00:00:31.601 --> 00:00:34.501
porque o conteúdo
está entre chaves.

00:00:34.534 --> 00:00:36.334
E você teria razão.

00:00:36.367 --> 00:00:39.801
O valor é um objeto JSON
aninhado.

00:00:39.834 --> 00:00:42.133
Como eu posso reverter?

00:00:42.167 --> 00:00:44.067
Se você olhar o conteúdo,

00:00:44.100 --> 00:00:47.567
notará que continua a mesma
estrutura de par chave-valor.

00:00:47.601 --> 00:00:50.234
Você pode ler
da mesma forma que antes.

00:00:50.267 --> 00:00:52.968
Desta vez, estamos
um nível mais profundo.

00:00:53.000 --> 00:00:55.501
Vamos olhar
as categorias-chave.

00:00:55.534 --> 00:00:56.934
Tem um valor que começa

00:00:56.968 --> 00:00:58.834
com um colchete virado
para a esquerda,

00:00:58.868 --> 00:01:03.334
o conteúdo e é fechado
com o colchete para a direita.

00:01:03.367 --> 00:01:06.067
O que você acha
que os colchetes representam?

00:01:06.701 --> 00:01:09.634
Este é o sintaxe
para um array.

00:01:09.667 --> 00:01:12.367
Arrays JSON podem conter
tipos primitivos de dados

00:01:12.400 --> 00:01:14.434
ou objetos JSON.

00:01:14.467 --> 00:01:16.868
Tal como arrays
que você já viu em Java,

00:01:16.901 --> 00:01:19.767
você pode navegar
o conteúdo de um array,

00:01:19.801 --> 00:01:21.567
usando índices.

00:01:22.100 --> 00:01:23.501
Na posição inicial,

00:01:23.534 --> 00:01:25.567
que é a "índice 0",

00:01:25.601 --> 00:01:28.100
temos o valor de string
de "boot",

00:01:28.868 --> 00:01:32.367
a posição seguinte
do índice ou "índice 1",

00:01:32.400 --> 00:01:34.701
temos "winklepicker".

00:01:35.567 --> 00:01:38.567
Então temos "cor",
que mapeia

00:01:38.601 --> 00:01:41.734
a string primitiva de "preto".

00:01:42.267 --> 00:01:45.968
Isso completa o nosso exemplo
da descrição do JSON de um sapato.

00:01:46.000 --> 00:01:48.267
Mas, como você pode imaginar,

00:01:48.300 --> 00:01:50.667
o aninhamento que vimos
no exemplo do sapato

00:01:50.701 --> 00:01:52.734
continua a se compor.

00:01:52.767 --> 00:01:56.901
Esse array pode conter
mais objetos e arrays dentro dele.

00:01:57.467 --> 00:02:01.901
E isso significa que o corpo de dados
pode ser muito grande mesmo.

00:02:01.934 --> 00:02:04.267
E isso é uma verdade.

00:02:04.300 --> 00:02:07.367
Mas o bacana é que,
apesar do tamanho em potencial,

00:02:07.400 --> 00:02:10.200
temos uma forma bem simples
de navegar por ele.

00:02:10.234 --> 00:02:14.701
Temos apenas que seguir
os pares chave-valor.

00:02:15.567 --> 00:02:17.234
Não sabe do que
estou falando?

00:02:17.267 --> 00:02:20.167
A seguir, vamos explorar
mais exemplos complexos

00:02:20.200 --> 00:02:21.968
e adquirir mais prática
para reverter

00:02:22.000 --> 00:02:24.067
um corpo de dados JSON
bem maior.

00:02:24.100 --> 00:02:25.701
Mais vamos praticar

00:02:25.734 --> 00:02:28.834
a identificação de componentes
JSON num quiz.

00:02:29.367 --> 00:02:30.634
No próximo quiz,

00:02:30.667 --> 00:02:33.868
você irá praticar diferenciar
um objeto JSON, array

00:02:33.901 --> 00:02:35.167
ou dados primitivos

00:02:35.200 --> 00:02:38.300
ao olhar uma resposta
JSON totalmente diferente.

00:02:38.334 --> 00:02:41.133
Este é um exemplo
da API do Twitter,

00:02:41.167 --> 00:02:43.434
onde você pode consultar
os tweets mais recentes

00:02:43.467 --> 00:02:44.801
que um usuário curtiu.

00:02:44.834 --> 00:02:47.634
Esta é a URL para
consultar os dados.

00:02:47.667 --> 00:02:50.334
E a resposta voltou
no formato JSON.

00:02:50.367 --> 00:02:52.534
Requer autenticação,
ou seja,

00:02:52.567 --> 00:02:54.868
é preciso dar
o nome do usuário e a senha

00:02:54.901 --> 00:02:56.367
para acessar os dados.

00:02:56.400 --> 00:02:58.968
Não dá para apenas
copiar a URL no browser

00:02:59.000 --> 00:03:01.767
e ver os resultados como fizemos
para os dados do terremotos.

00:03:01.801 --> 00:03:05.734
Sem entrar nos detalhes
da autenticação,

00:03:05.767 --> 00:03:08.868
a documentação nos dá
um exemplo de consulta

00:03:08.901 --> 00:03:10.767
e um exemplo de resposta.

00:03:10.801 --> 00:03:14.100
Esta resposta parece
com o JSON que vimos antes.

00:03:14.133 --> 00:03:16.701
Há pares chave-valor
e alguns dos valores

00:03:16.734 --> 00:03:19.300
são objetos JSO com chaves.

00:03:19.334 --> 00:03:23.300
E alguns deles estão
arrays JSON com colchetes.

00:03:23.334 --> 00:03:28.267
Outros valores que você vê aqui
são strings, booleans e números.

00:03:28.300 --> 00:03:30.934
Chris e eu fizemos
nossa própria consulta a esta API

00:03:30.968 --> 00:03:32.934
e recebemos esta resposta.

00:03:32.968 --> 00:03:34.267
Para o quiz,

00:03:34.300 --> 00:03:37.033
veja esta resposta
e responda as perguntas.

00:03:37.067 --> 00:03:39.467
Neste quiz perguntei
sobre algumas chaves

00:03:39.501 --> 00:03:43.300
na resposta JSON que recebemos
da API do Twitter.

00:03:43.334 --> 00:03:46.100
O link à minha resposta
e a documentação original

00:03:46.133 --> 00:03:47.767
está abaixo.

00:03:48.501 --> 00:03:52.934
Determine se a chave dada
mapeia a um valor que é:

00:03:52.968 --> 00:03:54.467
um objeto JSON,

00:03:54.501 --> 00:03:56.234
um array JSON

00:03:56.267 --> 00:03:57.801
ou um JSON primitivo.

