WEBVTT
Kind: captions
Language: zh-CN

00:00:00.230 --> 00:00:02.660
或许你可以采用之前的相同方法

00:00:02.660 --> 00:00:06.860
之前 我们有一个英语单词列表 我们希望按照特定的顺序

00:00:06.860 --> 00:00:11.802
从 one 存储到 ten 现在我们有了一个具有 10 个米沃克单词的列表

00:00:11.802 --> 00:00:15.990
或许你应该将它们也存储在 ArrayList 中

00:00:15.990 --> 00:00:17.850
似乎一切都可行

00:00:17.850 --> 00:00:21.140
现在只需确保 ArrayAdapter 构造函数

00:00:21.140 --> 00:00:24.150
允许我们传入两个列表

00:00:24.150 --> 00:00:28.320
一个英语单词列表 一个米沃克单词列表

00:00:28.320 --> 00:00:31.600
进入 NumbersActivity

00:00:31.600 --> 00:00:34.168
再来思考下我们的策略

00:00:34.168 --> 00:00:37.960
我们想将新的布局传入 ArrayAdapter

00:00:37.960 --> 00:00:43.260
我将 android.R.layout.simple_list_item_1

00:00:43.260 --> 00:00:47.600
替换为我们创建的布局 即 list_item 布局

00:00:48.870 --> 00:00:50.530
第三个输入参数是错误的

00:00:50.530 --> 00:00:54.340
我们要传入单词 但是 words 列表仅由英语单词构成

00:00:54.340 --> 00:00:56.960
我们还希望传入对应的米沃克单词

00:00:56.960 --> 00:00:59.800
以便每个列表项都显示这两种翻译

00:00:59.800 --> 00:01:01.440
我们回到 ArrayAdapter 文档

00:01:01.440 --> 00:01:04.550
转到 Public Constructors 部分

00:01:04.550 --> 00:01:07.915
我们看到这些是新建 ArrayAdapter 的各种方式

00:01:09.180 --> 00:01:13.720
我们使用的是倒数第二个构造函数 我们传入了 Context

00:01:13.720 --> 00:01:18.720
指的是 NumbersActivity 布局文件和对象列表

00:01:18.720 --> 00:01:21.730
但是这里好像没有另一种构造函数

00:01:21.730 --> 00:01:23.580
可以将两个列表做为输入参数

00:01:23.580 --> 00:01:25.620
这个只能传入一个列表

00:01:25.620 --> 00:01:27.320
这个也一样

00:01:27.320 --> 00:01:30.800
只能将一个列表作为最后的输入参数

00:01:32.530 --> 00:01:34.660
还记得我们之前提到的泛型吗？

00:01:34.660 --> 00:01:36.790
对象数据类型标为 T

00:01:36.790 --> 00:01:40.090
但是这只是个占位符

00:01:40.090 --> 00:01:41.970
你可以替换为任何其他对象数据类型

00:01:41.970 --> 00:01:45.520
目前我们将 T 替换成了字符串数据类型

00:01:45.520 --> 00:01:48.375
我们向 ArrayAdapter 传入了字符串数组列表

00:01:49.490 --> 00:01:54.010
上面这个构造函数需要对象数组

00:01:54.010 --> 00:01:58.230
这里的 T 是个占位符 可以替换为任何对象数据类型

00:01:58.230 --> 00:02:01.440
到目前为止都很不幸 找不到某个构造函数能让我们

00:02:01.440 --> 00:02:04.960
传入两个列表来创建 ArrayAdapter

00:02:04.960 --> 00:02:08.610
但是我们知道 ArrayAdapter 可以传入

00:02:08.610 --> 00:02:10.400
任何对象类型的列表

00:02:10.400 --> 00:02:13.140
要不我们不传入字符串列表

00:02:13.140 --> 00:02:14.920
而是创建自己的对象类型

00:02:14.920 --> 00:02:16.290
例如 Word 对象 

00:02:17.300 --> 00:02:21.510
我们可以定义自己的 Word 类 并通过它创建 Word 对象

00:02:21.510 --> 00:02:24.570
然后可以创建整个 Word 对象列表

00:02:24.570 --> 00:02:26.385
在上一门课程中

00:02:26.385 --> 00:02:30.660
我们提到类的定义包含状态和方法

00:02:30.660 --> 00:02:32.142
在下面的测试题中

00:02:32.142 --> 00:02:35.230
请指出我们应该如何定义 Word 类

00:02:35.230 --> 00:02:37.650
它应该包含什么状态和方法？

00:02:37.650 --> 00:02:39.870
在讨论 Word 类之前

00:02:39.870 --> 00:02:44.280
我将介绍几个使用了自定义类的其他应用

00:02:44.280 --> 00:02:47.210
这是一个热门航班预订应用

00:02:47.210 --> 00:02:47.840
Kayak 的屏幕截图

00:02:49.080 --> 00:02:52.898
用户可以选择出发和抵达城市

00:02:52.898 --> 00:02:56.970
以及日期 然后应用列出可能的选项

00:02:56.970 --> 00:02:59.627
注意信息是按照列表视图显示的

00:02:59.627 --> 00:03:01.459
每个列表项都具有一趟航班

00:03:01.459 --> 00:03:05.425
信息始终按照相同的模式显示

00:03:05.425 --> 00:03:10.410
Kayak 可能创建了一个自定义 Flight 类

00:03:10.410 --> 00:03:15.130
每个列表项都显示了关于该类中的单个航班对象的信息

00:03:15.130 --> 00:03:18.400
用盒子来模拟的话

00:03:18.400 --> 00:03:22.320
每个 Flight 对象都是一个大盒子 里面具有状态

00:03:22.320 --> 00:03:26.500
这些状态由不同的字段组成

00:03:26.500 --> 00:03:30.261
例如航空公司 抵达时间 费用和飞行时长

00:03:31.340 --> 00:03:34.030
我们还可以向此类中添加方法

00:03:34.030 --> 00:03:37.000
应用的其他部分可以调用这些方法

00:03:37.000 --> 00:03:40.460
所有这些结合在一起叫做封装

00:03:40.460 --> 00:03:45.310
因为所有的逻辑都封装或整合到了这个类中

00:03:45.310 --> 00:03:49.580
这个旅行应用的其他部分可以知道存在 Flight 对象

00:03:49.580 --> 00:03:54.015
能够调用这些方法 例如取消该对象

00:03:54.015 --> 00:03:57.530
但是外面的调用函数不用关心

00:03:57.530 --> 00:04:01.180
这些方法如何工作的内部细节

00:04:01.180 --> 00:04:03.250
调用函数知道当该方法被调用后

00:04:03.250 --> 00:04:07.080
可以预料到构造函数会取消该航班

00:04:07.080 --> 00:04:10.980
它们不用太关心背后的实现情况

00:04:10.980 --> 00:04:14.930
这个概念就叫做抽象化关于类中发生的情况

00:04:14.930 --> 00:04:16.510
的详细信息

00:04:16.510 --> 00:04:18.100
我们再来看一个示例

00:04:19.110 --> 00:04:22.800
这是一款叫做 SoundCloud 的音乐应用

00:04:22.800 --> 00:04:25.490
允许用户将喜爱的音乐曲目保存到播放列表中

00:04:25.490 --> 00:04:28.060
曲目显示在列表中

00:04:28.060 --> 00:04:31.590
每个曲目都是一个列表项 显示了相同的信息

00:04:31.590 --> 00:04:36.170
例如专辑名称 专辑封面 歌曲名称 歌曲时长

00:04:36.170 --> 00:04:39.659
聆听次数 所有这些都始终按照相同的模式显示

00:04:41.220 --> 00:04:44.470
所有信息都可以作为字段

00:04:44.470 --> 00:04:46.910
存储在自定义 Song 类的状态中

00:04:47.910 --> 00:04:51.020
除了状态之外 我们还可以将方法

00:04:51.020 --> 00:04:52.710
封装到此类中

00:04:52.710 --> 00:04:57.960
这个 Song 对象可以具有不同的方法 例如 getSongTitle()

00:04:57.960 --> 00:04:59.370
或 getAlbumName()

00:04:59.370 --> 00:05:00.680
类似于 Flight 类

00:05:00.680 --> 00:05:03.860
这里我们抽象化了类的详情

00:05:03.860 --> 00:05:08.310
外部的调用函数不用知道这些详情 就可以使用这些方法

00:05:08.310 --> 00:05:13.140
可以从这些示例中看出 将信息封装或整合到

00:05:13.140 --> 00:05:16.770
你定义的类中存在一定的优势

00:05:16.770 --> 00:05:19.460
现在请你思考下我们面临的问题

00:05:20.590 --> 00:05:24.750
请你在列表中显示英语单词和米沃克单词

00:05:24.750 --> 00:05:25.940
如何表示该数据呢？

00:05:27.190 --> 00:05:30.510
这是个数据结构问题 因为你需要决定

00:05:30.510 --> 00:05:32.250
如何在应用中构造数据

00:05:32.250 --> 00:05:36.100
如果所有信息都在应用中存储为单个全局变量

00:05:36.100 --> 00:05:38.560
那么会很难管理

00:05:38.560 --> 00:05:42.660
我们希望整理下数据 更易于检索

00:05:42.660 --> 00:05:44.600
并显示到屏幕上

00:05:44.600 --> 00:05:49.070
你已经开始这么操作了 熟悉了数据结构

00:05:49.070 --> 00:05:52.645
例如 将英语单词列表放入数组中或数组列表中

00:05:52.645 --> 00:05:56.030
就是选择数据结构来按照顺序列表

00:05:56.030 --> 00:05:59.040
更好地整理信息的示例

00:06:00.988 --> 00:06:02.900
现在我们将更深一步操作

00:06:02.900 --> 00:06:04.758
创建自己的 Words 数据结构

00:06:04.758 --> 00:06:10.128
因为 Java 的内置解决方案无法满足我们的需求

00:06:10.128 --> 00:06:13.580
所以我们提示你创建个 Word 类

00:06:13.580 --> 00:06:17.000
我们将请你来判断它的状态

00:06:17.000 --> 00:06:18.050
和方法应该是什么

