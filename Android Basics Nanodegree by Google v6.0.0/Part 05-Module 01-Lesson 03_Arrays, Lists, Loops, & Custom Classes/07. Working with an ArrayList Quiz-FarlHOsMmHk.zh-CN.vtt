WEBVTT
Kind: captions
Language: zh-CN

00:00:00.620 --> 00:00:05.020
在这个对比表格中 我们提到数组列表是类

00:00:05.020 --> 00:00:08.600
需要调用方法来访问和修改数组列表的元素

00:00:08.600 --> 00:00:11.490
现在我们来详细讨论下 ArrayList 类

00:00:11.490 --> 00:00:12.810
以及如何在代码中使用它

00:00:13.940 --> 00:00:17.660
我们先打开关于 ArrayList 的文档页面

00:00:17.660 --> 00:00:23.090
在顶部 写到 public class ArrayList extends AbstractList

00:00:23.090 --> 00:00:26.360
这个 extends 关键字表示我们免费从 AbstractList 类那

00:00:26.360 --> 00:00:28.760
继承了各种行为

00:00:28.760 --> 00:00:31.620
我们点开 AbstractList 类

00:00:31.620 --> 00:00:36.030
这页提到 AbstractList 类是个抽象类

00:00:36.030 --> 00:00:39.620
抽象类是部分实现的类 表示某些方法已经实现

00:00:39.620 --> 00:00:43.380
某些方法还是空的

00:00:43.380 --> 00:00:46.810
再仔细研究下类定义 我们发现它继承于另一个类

00:00:46.810 --> 00:00:49.480
这里写到 extends AbstractCollection

00:00:49.480 --> 00:00:51.380
现在我们将不详细介绍这里的内容

00:00:51.380 --> 00:00:54.140
我想指出的是 AbstractList 负责实现

00:00:54.140 --> 00:00:55.112
列表接口

00:00:55.112 --> 00:00:59.010
点击这个链接 打开列表接口

00:00:59.010 --> 00:01:02.840
通过这么逐步查看每个概念 希望你能明白

00:01:02.840 --> 00:01:07.870
最初的 ArrayList 实际上实现的是列表接口

00:01:07.870 --> 00:01:13.200
列表接口在 Java 中定义为关于列表的普通行为

00:01:13.200 --> 00:01:16.710
看看这段说明 文中提到列表是个元素集合

00:01:16.710 --> 00:01:18.094
并且元素保持一定的顺序

00:01:19.160 --> 00:01:20.750
每个元素都有索引

00:01:20.750 --> 00:01:22.750
你可以根据索引位置访问元素

00:01:24.090 --> 00:01:27.790
在上一节课中 我们讨论了接口 以及可以用来

00:01:27.790 --> 00:01:34.140
找到包含预期方法 输入 返回值和方法名称的 contract

00:01:34.140 --> 00:01:38.436
但是接口没有指定每个方法应该如何实现

00:01:38.436 --> 00:01:40.760
列表接口具有抽象方法

00:01:40.760 --> 00:01:46.520
例如 add() 方法 用来访问指定索引的元素的 get() 方法

00:01:46.520 --> 00:01:50.530
同时还具有 remove() 方法 以及好多其他方法

00:01:51.710 --> 00:01:54.655
因为数组列表会实现这个列表接口

00:01:54.655 --> 00:01:57.825
所以需要为这些方法提供实现

00:01:57.825 --> 00:01:59.375
很快你会发现

00:01:59.375 --> 00:02:03.425
你可以对 ArrayList 对象调用这些方法

00:02:03.425 --> 00:02:06.285
列表作为接口很有用是因为

00:02:06.285 --> 00:02:09.134
Java 中有很多其他类型的列表

00:02:09.134 --> 00:02:11.415
这门课程中我们不会介绍所有这些列表

00:02:11.415 --> 00:02:18.080
但是可以举些例子 例如链表 堆栈 向量等

00:02:18.080 --> 00:02:19.680
因此 在列表接口中存在预定义的 contract

00:02:19.680 --> 00:02:23.030
具有特定的目的

00:02:23.030 --> 00:02:26.210
为了涵盖我们刚刚讨论的内容 我们对该图表做出了更新

00:02:26.210 --> 00:02:32.190
其中包括 ArrayList 类 抽象类和列表接口

00:02:32.190 --> 00:02:34.330
列表在这里是个接口

00:02:34.330 --> 00:02:37.765
它的所有方法都没有实现

00:02:37.765 --> 00:02:43.490
AbstractList 是个抽象类 某些方法部分实现了

00:02:43.490 --> 00:02:46.840
ArrayList 是个具体类

00:02:46.840 --> 00:02:51.110
它具有状态和所有方法的实现 has state and implementation for
all of its methods.

00:02:51.110 --> 00:02:55.120
我们可以创建 ArrayList 的对象实例并用在我们的应用中

00:02:55.120 --> 00:02:58.070
但是 我们不能创建抽象类或接口的实例

00:02:58.070 --> 00:03:01.060
因为这些不是恰当完整的类

00:03:02.170 --> 00:03:05.390
在使用任何实现列表接口的类时

00:03:05.390 --> 00:03:09.040
例如 ArrayList 类 你将注意到方法签名

00:03:09.040 --> 00:03:11.640
向下滚动 看看其中一个方法

00:03:11.640 --> 00:03:15.203
例如 在 add() 方法中 你将看到对某个叫做 E 的内容的调用

00:03:15.203 --> 00:03:20.155
对 ArrayList add() 方法 文中提到输入参数应该是 E 类型的对象

00:03:20.155 --> 00:03:23.105
看看 get() 方法

00:03:23.105 --> 00:03:27.215
我们看到它会访问特定索引位置的列表元素

00:03:27.215 --> 00:03:30.515
并返回 E 型对象的值

00:03:30.515 --> 00:03:32.825
那么 E 是指什么呢？

00:03:32.825 --> 00:03:36.465
这就要提到泛型和 Java 中的泛型类型

00:03:37.620 --> 00:03:39.590
E 只是个占位符

00:03:39.590 --> 00:03:42.680
E 的正式说法是类型参数

00:03:42.680 --> 00:03:46.100
表示当我们实际地创建 ArrayList 的实例

00:03:46.100 --> 00:03:50.540
并对该对象调用这些方法 例如 add() 或 get()

00:03:50.540 --> 00:03:53.890
我们可以用特定的数据类型来替换 E

00:03:53.890 --> 00:03:56.030
比起用问号来代替 E

00:03:56.030 --> 00:03:59.060
这样可以为开发者提供更多的信息

00:03:59.060 --> 00:04:02.210
在这种情况下 E 是元素的简写

00:04:02.210 --> 00:04:04.030
元素又是怎么来的呢？

00:04:04.030 --> 00:04:06.980
集合的单个部分叫做元素

00:04:06.980 --> 00:04:09.566
因为这些方法（例如 get() 和 add()）

00:04:09.566 --> 00:04:12.320
处理的是数据集合中的元素

00:04:12.320 --> 00:04:13.988
所以是个合适的替代情形

00:04:13.988 --> 00:04:18.070
这个 E 可以被替换为任何非原始数据类型

00:04:18.070 --> 00:04:23.436
所以你可以写成 ArrayList()

00:04:23.436 --> 00:04:25.769
括号中包含特定类型 而不是仅写成 ArrayList E

00:04:25.769 --> 00:04:29.450
例如 你可以创建一个字符串数组列表

00:04:29.450 --> 00:04:32.550
表示在文档中所有 E 的地方

00:04:32.550 --> 00:04:36.070
对你来说 都需要替换为字符串对象数据类型

00:04:36.070 --> 00:04:39.060
如果对字符串数组列表调用 add()

00:04:39.060 --> 00:04:41.165
输入参数应该是字符串

00:04:41.165 --> 00:04:43.985
如果对字符串数组列表调用 get() 方法

00:04:43.985 --> 00:04:45.995
将返回字符串数据类型

00:04:45.995 --> 00:04:49.635
因此 ArrayList 类是个泛型类

00:04:49.635 --> 00:04:53.445
指定为 E 的地方可以替换为

00:04:53.445 --> 00:04:57.830
特定对象数据类型

00:04:57.830 --> 00:05:01.210
还有其他常见的类型参数 例如 T 和 V

00:05:01.210 --> 00:05:03.210
要了解详情 请阅读下面的内容

00:05:03.210 --> 00:05:06.970
我知道我们介绍了很多关于 ArrayList 是如何存在的

00:05:06.970 --> 00:05:08.770
及为何存在的理论知识

00:05:08.770 --> 00:05:10.900
现在介绍些相关的实用信息

00:05:11.930 --> 00:05:14.830
我们整合了一些常用的

00:05:14.830 --> 00:05:17.050
ArrayList 方法调用

00:05:17.050 --> 00:05:21.160
并给出了例子 将字符串作为参数化类型

00:05:21.160 --> 00:05:23.380
在示例中只要看到字符串的地方

00:05:23.380 --> 00:05:26.680
都可以替换为其他对象类型

00:05:26.680 --> 00:05:29.640
与创建数组的一个差别是

00:05:29.640 --> 00:05:33.350
当你创建新的数组列表时 不需要指定指向列表的链接

00:05:33.350 --> 00:05:36.830
要向数组列表中添加元素或从中删除元素

00:05:36.830 --> 00:05:38.380
我们可以分别使用 add() 和 remove() 方法

00:05:39.440 --> 00:05:43.180
注意下如何从数组列表中检索信息的区别

00:05:43.180 --> 00:05:46.770
数组列表不像在数组中那样使用 []

00:05:46.770 --> 00:05:51.040
而是使用 get() 方法 括号里放入感兴趣的索引

00:05:51.040 --> 00:05:54.109
注意 对于数组我们使用 array.length 来检索

00:05:54.109 --> 00:05:56.000
关于数组长度属性的信息

00:05:56.000 --> 00:05:59.510
但是 对于数组列表对象 我们需要使用 size() 方法

00:05:59.510 --> 00:06:03.940
注意没有输入参数 就使用空的 ()

00:06:03.940 --> 00:06:07.040
返回值将为列表中的元素数量

00:06:07.040 --> 00:06:11.290
在下个练习中 请阅读下每行注释

00:06:11.290 --> 00:06:14.460
并根据注释写出用来创建数组类别或

00:06:14.460 --> 00:06:16.500
修改数组列表的代码

00:06:17.630 --> 00:06:20.610
这个练习将帮助你更好地理解如何使用

00:06:20.610 --> 00:06:21.790
数组列表

00:06:21.790 --> 00:06:24.600
假设这几行代码用在餐厅应用中

00:06:24.600 --> 00:06:27.620
每个用户都可以创建一个想要品尝的餐厅列表

00:06:27.620 --> 00:06:30.070
请在每个注释下面写出正确的代码语句

00:06:31.260 --> 00:06:33.952
第一个注释要求创建新的数组列表对象

00:06:33.952 --> 00:06:34.880
称为 restaurantsToTry

00:06:34.880 --> 00:06:38.220
它将包含字符串列表

00:06:38.220 --> 00:06:41.280
第二个注释要求向你刚刚创建的数组列表

00:06:41.280 --> 00:06:42.740
添加一个餐厅 叫做

00:06:43.960 --> 00:06:46.660
第三个注释要求向数组列表添加另一个餐厅

00:06:46.660 --> 00:06:48.850
叫做 BBQ Time

00:06:48.850 --> 00:06:52.400
第四个注释是用户尝试了 Morning Cafe 餐厅

00:06:52.400 --> 00:06:55.570
现在请你从该数组列表中删除该餐厅

00:06:55.570 --> 00:06:59.000
第五个注释是获取该数组列表的长度

00:06:59.000 --> 00:07:02.670
然后存储为整型变量 称为 numbersOfRestaurants

00:07:02.670 --> 00:07:04.010
现在请试试吧

00:07:04.010 --> 00:07:05.520
稍后再见

