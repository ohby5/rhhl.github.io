WEBVTT
Kind: captions
Language: zh-CN

00:00:00.260 --> 00:00:03.280
我们明白了创建的应用一定要

00:00:03.280 --> 00:00:06.040
合理使用设备的内存资源

00:00:06.040 --> 00:00:09.390
现在我们来讨论一种节约资源的方式 即通过实施有效的内存策略

00:00:09.390 --> 00:00:14.755
来显示一长串的数据列表 很多应用都需要显示很长的数据列表

00:00:14.755 --> 00:00:17.455
该策略就叫做视图回收

00:00:17.455 --> 00:00:21.675
表示重复使用在屏幕上不再可见的视图

00:00:21.675 --> 00:00:26.265
顺便提下 我说的视图是指单行的整个布局

00:00:26.265 --> 00:00:29.035
单行的布局可能是由 ViewGroup 创建的

00:00:29.035 --> 00:00:30.445
例如 LinearLayout 或

00:00:30.445 --> 00:00:33.640
RelativeLayout 其中会包含多个视图

00:00:33.640 --> 00:00:37.070
但是 ViewGroup 本身也是视图

00:00:37.070 --> 00:00:41.330
你可能会听到我们将单行布局称为视图

00:00:41.330 --> 00:00:43.660
米沃克语言非常的庞大

00:00:43.660 --> 00:00:46.590
创建该应用的其中一种方式是

00:00:46.590 --> 00:00:50.600
创建成千上万个列表项 并将它们添加到垂直 LinearLayout 中

00:00:50.600 --> 00:00:52.530
但是 如果有这么多的单词的话

00:00:52.530 --> 00:00:55.380
可能滚动查看整个列表会很慢

00:00:55.380 --> 00:00:58.090
设备可能会崩溃 因为无法保存

00:00:58.090 --> 00:00:59.200
所有这些列表项

00:00:59.200 --> 00:01:02.160
注意 内存是有限的资源

00:01:02.160 --> 00:01:03.250
Android 系统和

00:01:03.250 --> 00:01:06.560
其他应用也需要一些内存来运行

00:01:06.560 --> 00:01:08.580
我们可以采用一种更加高效的方式

00:01:08.580 --> 00:01:13.210
我们可以使用 ListView 和 ArrayAdapter 根据需要在屏幕上显示的内容

00:01:13.210 --> 00:01:17.770
创建足够的视图 即列表项行

00:01:17.770 --> 00:01:19.950
这意味着 如果我们向上滚动

00:01:19.950 --> 00:01:23.250
我们就不需要再看到屏幕底部的视图

00:01:23.250 --> 00:01:26.440
我们来重点研究下 ListView 和 ArrayAdapter 结构

00:01:26.440 --> 00:01:29.250
进一步来说 我们可以使用回收视图

00:01:29.250 --> 00:01:32.270
如果某个视图在屏幕上不再可见时

00:01:32.270 --> 00:01:34.960
我们可以通过更改相关数据重复使用该视图

00:01:34.960 --> 00:01:39.210
即更改视图中的数据 例如 TextView 中的文本

00:01:39.210 --> 00:01:41.400
或 ImageView 中的图片

00:01:41.400 --> 00:01:45.350
我们不用浪费时间从头创建整个视图

00:01:45.350 --> 00:01:47.440
我们将这些多余的视图

00:01:47.440 --> 00:01:51.130
放入 Scrap Pile 中并等着回收利用

00:01:51.130 --> 00:01:55.150
有时候你可能会听到 Scrap View 这一说法

00:01:55.150 --> 00:01:58.760
我们保留了 Scrap Pile 即一堆当前没有显示在

00:01:58.760 --> 00:02:02.770
屏幕上的视图 等着稍后重复使用

00:02:02.770 --> 00:02:03.970
即回收

00:02:03.970 --> 00:02:07.480
再详细讲解下回收的流程

00:02:07.480 --> 00:02:10.550
例如 用户正在滚动查看屏幕

00:02:10.550 --> 00:02:14.140
他们想要转到列表的顶部 看看最新的推文

00:02:14.140 --> 00:02:15.638
或新闻报道

00:02:15.638 --> 00:02:20.150
ListView 意识到需要快速创建更多的列表项行

00:02:20.150 --> 00:02:23.680
当用户滚动的时候 似乎列表项

00:02:23.680 --> 00:02:25.050
一直都存在

00:02:25.050 --> 00:02:27.425
它可以从 Scrap Pile 中选择一个视图

00:02:27.425 --> 00:02:30.070
(如果存在的话) 重复使用

00:02:30.070 --> 00:02:31.530
而不用从头创建一个

00:02:31.530 --> 00:02:32.370
总结下

00:02:32.370 --> 00:02:36.680
我们通过重复使用 Scrap Pile 中的视图创建了更多的视图行

00:02:36.680 --> 00:02:40.530
然后就只需更改视图中的数据

00:02:40.530 --> 00:02:43.288
以便为相关列表项显示正确的信息

00:02:43.288 --> 00:02:47.380
ListView 同时还很智能地知道

00:02:47.380 --> 00:02:50.520
位于屏幕底部的视图已经被滚动出屏幕

00:02:50.520 --> 00:02:53.190
这些视图对用户来说已经不可见

00:02:53.190 --> 00:02:54.990
可以直接添加到 Scrap Pile 中

00:02:54.990 --> 00:02:57.580
当用户再往上滚动时

00:02:57.580 --> 00:03:00.680
我们就可以使用之前位于屏幕底部的列表项行

00:03:01.970 --> 00:03:04.970
现在则位于屏幕顶部了

00:03:04.970 --> 00:03:09.750
所有这些的目标是尽量创建很少的列表项

00:03:09.750 --> 00:03:14.960
因为从 XML 向 Java 对象隐形膨胀视图的代价很大

00:03:14.960 --> 00:03:19.250
为了向你证明下视图回收可以尽量减少内存占用量

00:03:19.250 --> 00:03:21.370
我准备了两个版本的应用

00:03:21.370 --> 00:03:23.370
一个是当前状态的应用

00:03:23.370 --> 00:03:27.500
使用垂直 LinearLayout 每个列表项有一个 TextView

00:03:27.500 --> 00:03:31.270
第二个版本的应用使用的是 ListView 和 ArrayAdapter

00:03:32.310 --> 00:03:35.190
Android studio 中提供了内存监视器工具

00:03:35.190 --> 00:03:38.330
可以帮助你查看你的应用使用的内存资源量

00:03:38.330 --> 00:03:41.960
专业开发者会使用该工具来确定

00:03:41.960 --> 00:03:45.260
应用可以如何尽量减少资源占用量

00:03:45.260 --> 00:03:48.260
当列表项的数量增加时 使用 LinearLayout 和

00:03:48.260 --> 00:03:50.880
ListView ArrayAdopter 时的内存占用量之间的区别

00:03:50.880 --> 00:03:53.550
就愈加明显

00:03:53.550 --> 00:03:55.820
我来演示下这两个示例

00:03:55.820 --> 00:03:59.180
每个都显示 1,000 个单词

00:03:59.180 --> 00:04:02.215
现在我在 Android Studio 中查看的是

00:04:02.215 --> 00:04:03.685
LinearLayout 版的应用

00:04:03.685 --> 00:04:08.505
注意到 NumbersActivity 显示了 1,000 个单词

00:04:08.505 --> 00:04:11.345
我们在设备上运行该应用 看看效果如何

00:04:11.345 --> 00:04:16.115
点按 NumbersActivity 显示了长长的单词列表

00:04:16.115 --> 00:04:18.204
将设备连接到计算机后

00:04:18.204 --> 00:04:21.745
就可以运行内存监视器 看看该应用占用的内存

00:04:21.745 --> 00:04:27.340
在运行前 我需要转到这里“工具 (Tools)”&gt;“Android”

00:04:27.340 --> 00:04:29.650
“启用 ADB 集成 (Enable ADB integration)”

00:04:29.650 --> 00:04:32.690
ADB 表示的是 Android Debug Bridge

00:04:32.690 --> 00:04:35.360
即在设备和 Android Studio 之间建立连接

00:04:36.850 --> 00:04:40.830
启用 ADB 后 转到这里的运行时窗口中的 Android Monitor

00:04:42.000 --> 00:04:44.700
点击打开 往上拉一拉窗口

00:04:44.700 --> 00:04:46.169
然后点击这里的“内存 (Memory)”标签页

00:04:47.740 --> 00:04:51.960
通过此窗口 我可以查看我的应用的内存使用情况

00:04:51.960 --> 00:04:55.336
我将在设备上运行该应用

00:04:55.336 --> 00:04:57.264
在连接设备后

00:04:57.264 --> 00:04:58.796
我们看到内存监视器正在运行

00:04:58.796 --> 00:05:02.895
我们可以看到显示类别列表

00:05:02.895 --> 00:05:03.816
所占用的内存

00:05:03.816 --> 00:05:06.385
我调出设备屏幕现在的状况

00:05:06.385 --> 00:05:08.700
看看监视器会发生的情况

00:05:08.700 --> 00:05:10.805
点按 NumbersActivity

00:05:15.005 --> 00:05:17.070
哇 看到这里的上升情况了吗

00:05:17.070 --> 00:05:20.049
从大概 2M 跳到了大概 14M

00:05:21.100 --> 00:05:25.300
那么这个内存占用量的陡然上升

00:05:25.300 --> 00:05:26.550
是好事还是坏事呢？

00:05:27.730 --> 00:05:31.050
最佳判断方式是在同一设备上运行

00:05:31.050 --> 00:05:32.580
代码的另一个版本

00:05:32.580 --> 00:05:35.340
我们将在同一设备上运行

00:05:35.340 --> 00:05:37.480
因为这样的话 资源量是相同的

00:05:37.480 --> 00:05:41.602
为此 我将跳到新版本的代码

00:05:41.602 --> 00:05:46.444
即使用 ListView 和 ArrayAdapter 来显示相同的 1,000 个单词

00:05:46.444 --> 00:05:50.414
现在我看的是 ListView 和 ArrayAdapter 版本的代码

00:05:50.414 --> 00:05:53.485
显示的是相同的 1,000 个单词列表

00:05:53.485 --> 00:05:56.204
我们来看看当我们在设备上运行该代码时

00:05:56.204 --> 00:05:56.739
会发生什么情况

00:05:57.830 --> 00:05:59.920
类别屏幕保持不变

00:05:59.920 --> 00:06:02.380
当我们点按 NumbersActivity 时

00:06:02.380 --> 00:06:06.650
注意到 1,000 个单词列表出现了 但是存在分割线

00:06:06.650 --> 00:06:10.110
稍后我们将讲解为何会出现这种情况 是如何出现的

00:06:10.110 --> 00:06:11.325
现在回到 Android Studio

00:06:11.325 --> 00:06:14.405
和之前一样启动内存监视器

00:06:14.405 --> 00:06:19.130
转到下面的 Android Monitor 向上拉动窗口 然后转到“内存 (Memory)”标签页

00:06:19.130 --> 00:06:23.540
当我的设备连接好后 内存监视器就会运行

00:06:23.540 --> 00:06:25.570
因为已经启用了 ADB

00:06:25.570 --> 00:06:28.115
当我进入类别屏幕时

00:06:28.115 --> 00:06:30.535
分配的内存保持不变

00:06:30.535 --> 00:06:33.239
注意下当我点按 NumbersActivity 时会发生的情况

00:06:36.740 --> 00:06:38.565
注意到这里有个小小的上升

00:06:38.565 --> 00:06:42.880
数字从约 12.71 变成了约 12.84

00:06:42.880 --> 00:06:47.149
当从类别屏幕进入 NumbersActivity 时

00:06:47.149 --> 00:06:51.310
内存占用量仅仅上升了 0.1M

00:06:51.310 --> 00:06:54.520
与之前使用 LinearLayout 版本的代码相比

00:06:54.520 --> 00:06:58.840
这次显示数字列表所需的内存小了很多

00:06:58.840 --> 00:07:02.900
因为我们使用了很少的内存 所有这个使用 ListView

00:07:02.900 --> 00:07:06.890
和 ArrayAdapter 版本的代码在更低端的设备上运行的将更流畅

00:07:07.900 --> 00:07:11.330
我们再仔细看看这里的内存监视器

00:07:11.330 --> 00:07:13.530
实际上显示了两项内容

00:07:13.530 --> 00:07:16.300
深蓝色部分显示的是分配的内存

00:07:16.300 --> 00:07:19.080
即我们的设备在任何时候消耗的内存

00:07:20.430 --> 00:07:23.420
这里的浅蓝色部分显示的是闲置内存

00:07:23.420 --> 00:07:26.040
即设备上的可用内存

00:07:26.040 --> 00:07:29.210
虽然你可能想要使用设备上所有的闲置内存

00:07:29.210 --> 00:07:30.910
使你的应用看起来更酷炫

00:07:30.910 --> 00:07:34.390
但是你的应用不是设备上唯一安装的应用

00:07:34.390 --> 00:07:38.450
一定要尽量为其他应用留下足够的内存

00:07:38.450 --> 00:07:41.390
这是针对两个版本的应用

00:07:41.390 --> 00:07:43.210
获取的内存监视器屏幕截图

00:07:43.210 --> 00:07:48.010
左边的是第一个版本的应用 使用的是 LinearLayout

00:07:48.010 --> 00:07:51.881
右边的是第二个版本的应用 使用的是 ListView 和

00:07:51.881 --> 00:07:53.120
ArrayAdapter

00:07:53.120 --> 00:07:56.800
注意 深蓝色部分显示的是分配的内存

00:07:56.800 --> 00:07:58.700
浅蓝色部分显示的是闲置内存

00:07:59.810 --> 00:08:04.180
在两种情况下 当用户点击 Numbers 类别转到数字单词列表时

00:08:04.180 --> 00:08:07.500
分配的内存就会出现上升

00:08:08.590 --> 00:08:11.760
我们放大下 LinearLayout 版本的应用

00:08:11.760 --> 00:08:16.910
我们看到上升量是从约 11M 跳到了约 14M

00:08:16.910 --> 00:08:21.025
即显示 1,000 个单词的列表大概占用了

00:08:21.025 --> 00:08:21.870
3M 内存

00:08:23.070 --> 00:08:26.450
将这个与使用 ListView 和 ArrayAdapter 时的相比

00:08:26.450 --> 00:08:31.400
后者显示整个 1,000 个单词仅仅使用了 0.5M 的内存

00:08:32.520 --> 00:08:34.174
在看了这两个示例后

00:08:34.174 --> 00:08:36.799
请点击下面的链接

00:08:36.799 --> 00:08:38.659
详细了解如何使用内存监视器工具

00:08:38.659 --> 00:08:40.900
及其他方式来改善应用的性能

