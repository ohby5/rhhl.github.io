WEBVTT
Kind: captions
Language: zh-CN

00:00:00.740 --> 00:00:01.839
现在我们已经写了很多代码

00:00:01.839 --> 00:00:06.000
你肯定非常希望单词列表能出现在屏幕上

00:00:06.000 --> 00:00:08.580
我们可以通过手动方式来实现

00:00:08.580 --> 00:00:11.430
我们多次提到过 你在应用的 XML 中写的任何内容

00:00:11.430 --> 00:00:15.225
都可以通过 Java 代码实现

00:00:15.225 --> 00:00:19.415
我可以为此列表中的每个元素创建一个 TextView 对象

00:00:19.415 --> 00:00:22.225
然后添加为当前布局的子视图

00:00:22.225 --> 00:00:23.155
我们来试试该方法

00:00:24.385 --> 00:00:26.895
首先我需要查看下布局

00:00:26.895 --> 00:00:28.903
对 NumbersActivity

00:00:28.903 --> 00:00:33.570
我们看到布局定义在了 activity_numbers.xml 文件中

00:00:35.080 --> 00:00:36.684
打开该文件

00:00:36.684 --> 00:00:40.060
将这个 RelativeLayout 更改为 LinearLayout

00:00:40.060 --> 00:00:44.633
这样我向其中添加的每个子视图都会一个接一个地

00:00:44.633 --> 00:00:45.942
排成一列

00:00:45.942 --> 00:00:49.327
此外 我将 orientation 属性设为 vertical

00:00:49.327 --> 00:00:52.825
我将在 Java 代码中手动添加子视图

00:00:52.825 --> 00:00:56.013
因此 我应该为该 LinearLayout 分配一个视图 ID

00:00:56.013 --> 00:00:58.590
以便稍后在 Java 代码中引用它

00:01:00.250 --> 00:01:02.020
我将该 ID 称为 rootView

00:01:03.100 --> 00:01:04.485
现在回到 NumbersActivity

00:01:06.538 --> 00:01:10.770
我将在 onCreate 方法的末尾添加几行代码

00:01:10.770 --> 00:01:12.320
以便显示单词列表

00:01:12.320 --> 00:01:15.810
我将在创建 ArrayList 之后执行这一操作

00:01:15.810 --> 00:01:19.400
可以删了这些日志消息

00:01:19.400 --> 00:01:22.700
因为我已经知道我的列表创建得正确无误

00:01:22.700 --> 00:01:25.680
关了左侧的项目面板

00:01:25.680 --> 00:01:26.850
这样可以更清晰地看到代码

00:01:27.850 --> 00:01:30.650
在 Java 代码中 首先我需要

00:01:30.650 --> 00:01:34.670
找到称为 rootView 的 LinearLayout 并存储在变量中

00:01:35.810 --> 00:01:40.370
然后可以开始创建 TextView 并添加到此 LinearLayout 中

00:01:40.370 --> 00:01:45.010
为此 我一开始需要使用 findViewById 方法

00:01:45.010 --> 00:01:47.285
找到 ID 为 rootView 的视图

00:01:48.550 --> 00:01:50.190
这样会返回一个视图

00:01:51.430 --> 00:01:55.420
但是我需要将其具体地设为 LinearLayout 数据类型

00:01:55.420 --> 00:01:57.999
这样就可以向其添加子视图

00:01:59.080 --> 00:02:03.290
现在我将该视图存储到 rootView 变量中 以便稍后使用它

00:02:04.410 --> 00:02:06.404
记得末尾加个分号

00:02:08.014 --> 00:02:08.850
不错

00:02:08.850 --> 00:02:13.364
这行代码可以帮助我找到叫做 rootView 的 LinearLayout

00:02:13.364 --> 00:02:16.380
我会将其存储到这个叫做 rootView 的变量中

00:02:16.380 --> 00:02:17.217
接着

00:02:17.217 --> 00:02:20.230
我需要创建 TextView 并将它们添加到刚刚创建的这个 LinearLayout 中

00:02:21.720 --> 00:02:23.650
开始创建 TextView 对象

00:02:24.858 --> 00:02:26.930
我将使用这个构造函数

00:02:26.930 --> 00:02:28.770
只需要 context 作为输入参数

00:02:29.850 --> 00:02:33.170
要判断该使用哪个构造函数

00:02:33.170 --> 00:02:35.170
我们始终可以查看相关文档

00:02:35.170 --> 00:02:37.720
这是关于 TextView 类的文档

00:02:37.720 --> 00:02:40.320
向下滚动到关于公共构造函数的部分

00:02:41.670 --> 00:02:44.822
从这里可以看出 我们可以使用这几种

00:02:44.822 --> 00:02:45.405
构造函数

00:02:45.405 --> 00:02:49.224
每个都具有不同数量的输入参数

00:02:49.224 --> 00:02:51.963
我将使用第一个

00:02:51.963 --> 00:02:54.880
只有一个输入参数 即 context

00:02:54.880 --> 00:02:57.010
每次在 Java 代码中创建视图

00:02:57.010 --> 00:03:00.770
都需要传入 context 以便该视图知道主题背景和

00:03:00.770 --> 00:03:04.130
关于所在应用的其他信息

00:03:04.130 --> 00:03:06.710
它可以给出周围所发生的上下文

00:03:08.140 --> 00:03:13.974
这里 我们将“this”传入为该构造函数的输入参数

00:03:13.974 --> 00:03:17.210
因为这是个 NumbersActivity 类

00:03:17.210 --> 00:03:19.130
this 也将为 context

00:03:20.820 --> 00:03:24.660
这行代码将可以帮助我创建 TextView 对象

00:03:24.660 --> 00:03:29.640
该对象会存储在叫做 wordView 的变量中 数据类型是 TextView

00:03:30.780 --> 00:03:33.550
为了更改在屏幕上显示的文本

00:03:33.550 --> 00:03:37.320
我对 wordView 对象调用 setText 方法

00:03:37.320 --> 00:03:40.820
并传入一个输入参数 即要显示的文本

00:03:40.820 --> 00:03:43.390
在这里 我希望 TextView 显示单词列表中第 0 个索引处

00:03:43.390 --> 00:03:46.190
存储的字符串

00:03:47.480 --> 00:03:51.050
这样应该帮助我们映射到单词 one

00:03:51.050 --> 00:03:54.122
现在我们已经具有了 wordView 对象 其中具有正确的文本

00:03:54.122 --> 00:03:59.020
我将该视图添加为父视图 rootView 的子视图

00:04:00.210 --> 00:04:02.460
这是我们的子视图 wordView

00:04:02.460 --> 00:04:06.840
这是我们的父视图 rootView

00:04:06.840 --> 00:04:10.241
我将使用 .addView 方法将子视图 wordView

00:04:10.241 --> 00:04:14.970
添加到父视图 rootView 中

00:04:17.130 --> 00:04:20.420
我们运行下应用中的这段代码 看看会发生什么

00:04:20.420 --> 00:04:24.850
当我们进入 NumbersActivity 不错

00:04:24.850 --> 00:04:26.620
我们看到单词 one

00:04:26.620 --> 00:04:30.560
它来自于单词数组列表的第 0 个元素

00:04:30.560 --> 00:04:35.020
这里我们采取的操作是根据数组列表中的第一个元素

00:04:35.020 --> 00:04:38.330
用 Java 代码动态地创建了一个 TextView

00:04:38.330 --> 00:04:38.920
此时

00:04:38.920 --> 00:04:41.920
你可能开始思考所有的可能情况了

00:04:41.920 --> 00:04:46.360
为何不对列表中的所有其他元素都重复写出相同的代码？

00:04:46.360 --> 00:04:48.300
那么就可以在屏幕上显示一个单词列表了

00:04:50.240 --> 00:04:52.678
我们试试 再写几个视图

00:04:52.678 --> 00:04:55.040
复制这几行代码

00:04:55.040 --> 00:04:58.300
这些代码帮助我们创建了单词 one 的 TextView

00:04:58.300 --> 00:05:02.315
粘贴到下面 然后修改下 使其帮助我们为单词

00:05:02.315 --> 00:05:03.340
创建一个 TextView

00:05:03.340 --> 00:05:05.600
看起来这里报错了

00:05:05.600 --> 00:05:09.670
系统提示变量 wordView 已经在此作用域中定义了

00:05:09.670 --> 00:05:13.490
意味着在同一作用域内只能定义一次

00:05:13.490 --> 00:05:14.560
具有相同名称的本地变量

00:05:15.600 --> 00:05:19.220
这里作用域指代的是该方法

00:05:19.220 --> 00:05:22.580
为此 我将取一个不同的名称 称之为 wordView2

00:05:23.590 --> 00:05:26.680
然后对下面的代码做出相应的更改

00:05:26.680 --> 00:05:30.385
现在我们写了一段代码来创建另一个 TextView

00:05:30.385 --> 00:05:35.015
叫做 wordView2, 并将该 TextView 添加到父视图 rootView 中

00:05:36.420 --> 00:05:37.230
等等

00:05:37.230 --> 00:05:42.380
我希望第二个 TextView 显示位于第一个索引处的下一个单词

00:05:42.380 --> 00:05:46.405
因此我将 words.get(0) 更改为

00:05:46.405 --> 00:05:51.565
words.get(1) 获取列表中索引 1 处的字符串

00:05:52.725 --> 00:05:54.882
复制粘贴这段代码

00:05:54.882 --> 00:05:57.830
并进行一些修改 以便显示列表中的第三个单词

00:05:59.230 --> 00:06:01.735
我们试着运行下代码 看看发生的情况

00:06:01.735 --> 00:06:06.305
在设备上运行应用 点按 Numbers 不错

00:06:06.305 --> 00:06:10.110
在 NumbersActivity 中 我们输出了 one two three

00:06:10.110 --> 00:06:13.270
即数组列表中的前三个元素

00:06:14.410 --> 00:06:18.010
我们可以继续这么复杂粘贴

00:06:18.010 --> 00:06:22.938
并对 TextView 和索引做出修改

00:06:22.938 --> 00:06:25.410
但是过程会很枯燥

00:06:25.410 --> 00:06:28.150
同时还要调整这些 TextView 的样式 使其看起来更美观

00:06:28.150 --> 00:06:30.405
目前只是纯文本

00:06:30.405 --> 00:06:33.690
我们本可以在 XML 操作

00:06:33.690 --> 00:06:36.970
不断复制和粘贴 XML 元素

00:06:36.970 --> 00:06:38.970
但是等等

00:06:38.970 --> 00:06:41.850
在编写该 Java 代码时 我们发现了一个规律

00:06:43.020 --> 00:06:47.150
注意到每个 TextView 的代码块都非常相似

00:06:48.400 --> 00:06:52.034
主要区别是索引位置

00:06:52.034 --> 00:06:53.025
改变了

00:06:53.025 --> 00:06:58.002
可以看出 索引从 0

00:06:58.002 --> 00:07:00.800
增加到 1 2 等等

00:07:00.800 --> 00:07:03.030
我根据所发现的规律重写了该代码

00:07:04.060 --> 00:07:07.696
如果替换掉用来跟踪当前索引位置的整型变量

00:07:07.696 --> 00:07:10.790
每次都加 1 会怎样呢？

00:07:11.910 --> 00:07:15.940
这些代码块看起来越来越相似

00:07:15.940 --> 00:07:20.970
它们都调用 words.get 然后将索引传入为输入参数

00:07:20.970 --> 00:07:24.510
只是增加了代码来使索引值加 1

00:07:24.510 --> 00:07:27.390
现在我将介绍个非常酷的全新编程概念

00:07:27.390 --> 00:07:28.690
叫做循环

00:07:28.690 --> 00:07:31.950
一旦你学会循环后 请你修正下该代码

00:07:31.950 --> 00:07:35.730
这样就不用复制粘贴这段代码十次

00:07:35.730 --> 00:07:39.260
才能将所有单词都显示到屏幕上

