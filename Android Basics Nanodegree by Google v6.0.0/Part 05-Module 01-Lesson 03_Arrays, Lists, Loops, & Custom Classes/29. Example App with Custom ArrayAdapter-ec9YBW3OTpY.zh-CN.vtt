WEBVTT
Kind: captions
Language: zh-CN

00:00:00.122 --> 00:00:04.170
我知道该测试题的步骤很多 需要消化很多内容

00:00:04.170 --> 00:00:07.340
我们先来看看 Android Flavor 应用

00:00:07.340 --> 00:00:10.350
先来理解它的仓库

00:00:10.350 --> 00:00:13.310
因为在一个项目中有很多个部分

00:00:13.310 --> 00:00:16.700
你始终可以下载该项目的 ZIP 文件

00:00:16.700 --> 00:00:21.360
在 Android Studio 中导入该应用 这样会更容易浏览所有这些文件

00:00:21.360 --> 00:00:22.860
滚动到底部

00:00:22.860 --> 00:00:26.630
看到 Readme 文件 该文件解释了应用的作用

00:00:26.630 --> 00:00:29.330
这个示例使用了 ListView 和一个自定义 ArrayAdapter

00:00:29.330 --> 00:00:33.970
叫做 FlavorAdapter 来显示自定义列表项视图

00:00:33.970 --> 00:00:38.780
其中包含图片和两个 TextView

00:00:38.780 --> 00:00:42.930
所有这些信息都用来显示 Android Flavor 名称和

00:00:42.930 --> 00:00:44.300
版本名称

00:00:44.300 --> 00:00:45.900
这个列表项布局模式和

00:00:45.900 --> 00:00:49.360
自定义适配器与我们在 Miwok 应用中所需的非常相似

00:00:49.360 --> 00:00:53.910
注意 应用中的注释只要指的是适配器视图

00:00:53.910 --> 00:00:57.100
都表示的是视图 例如 ListView 或 GridView

00:00:57.100 --> 00:00:59.230
这些都是常见的适配器视图

00:00:59.230 --> 00:01:01.780
再次回到 Android Studio

00:01:01.780 --> 00:01:04.720
我下载了该项目的 zip 版本

00:01:04.720 --> 00:01:07.650
在 Android Studio 中打开详细了解下

00:01:07.650 --> 00:01:11.340
要看看该项目的工作原理 我们先研究下 Java 文件

00:01:12.580 --> 00:01:15.840
打开 Java 文件 我们看到这里有三个 Java 文件

00:01:15.840 --> 00:01:18.720
第一个文件是 MainActivity

00:01:18.720 --> 00:01:22.043
通过名称猜测应该是应用的主屏幕

00:01:22.043 --> 00:01:27.472
当我们首次打开应用时 onCreate() 方法会创建 MainActivity

00:01:27.472 --> 00:01:32.736
然后我们将 ContentView 设为 activity_mainlayout

00:01:32.736 --> 00:01:37.600
接着 我们看到有一个 ArrayList 叫做 AndroidFlavors

00:01:37.600 --> 00:01:41.440
包含 AndroidFlavor 类型的对象

00:01:41.440 --> 00:01:44.160
AndroidFlavor 听起来不像标准类

00:01:44.160 --> 00:01:46.420
很有可能是个自定义类

00:01:46.420 --> 00:01:50.670
要弄明白这一点 我们将通过 Android 中的声明函数来做出判断

00:01:50.670 --> 00:01:54.750
为此 我将右击该类的名称

00:01:54.750 --> 00:01:58.570
选择“转到 (Go To)”然后选择“声明 (Declaration)”

00:01:58.570 --> 00:02:02.428
系统使我们跳转到了 AndroidFlavor 类

00:02:02.428 --> 00:02:06.530
AndroidFlavor.java 是我们创建的自定义类

00:02:08.080 --> 00:02:11.356
从这里可以看出 该类的对象具有三个属性

00:02:11.356 --> 00:02:16.880
版本名称 版本号和图片资源 ID

00:02:16.880 --> 00:02:20.845
这些属性的值都在构造函数中赋值

00:02:20.845 --> 00:02:26.250
构造函数在这里 此类也包含了一些 getter 方法

00:02:26.250 --> 00:02:28.750
我们的操作流程是创建了一个数组

00:02:28.750 --> 00:02:31.580
其中包含了这些 AndroidFlavor 对象

00:02:31.580 --> 00:02:34.770
这里是单个 AndroidFlavor 对象的示例

00:02:34.770 --> 00:02:38.150
了解了这个盒子和里面的状态之后

00:02:38.150 --> 00:02:43.220
我们将每个对象都放入 AndroidFlavors 数组

00:02:43.220 --> 00:02:47.460
很多 AndroidFlavor 对象存储在了 AndroidFlavors 数组中

00:02:47.460 --> 00:02:48.900
我们回到 MainActivity

00:02:50.820 --> 00:02:54.360
我们看到这里创建了数组列表

00:02:54.360 --> 00:02:57.840
接着是 ArrayAdapter 调用

00:02:58.880 --> 00:03:02.190
我们在这行里实例化了自定义适配器

00:03:02.190 --> 00:03:04.510
并存储在变量 flavorAdapter 中

00:03:05.980 --> 00:03:10.026
要创建此 AndroidFlavorAdapter

00:03:10.026 --> 00:03:14.410
我们调用构造函数并传入两个输入参数

00:03:15.850 --> 00:03:20.500
这个应该指的是 Context 第二个 androidFlavors

00:03:20.500 --> 00:03:24.480
看起来似乎我们是在传入 AndroidFlavors 数组 我们来详细了解下

00:03:24.480 --> 00:03:29.490
这个适配器是如何定义的 方法是找到 AndroidFlavorAdapters 定义的位置

00:03:29.490 --> 00:03:33.620
右击“Go To” ”Declaration”

00:03:33.620 --> 00:03:36.540
这是该 AndroidFlavorAdapter Java 文件

00:03:36.540 --> 00:03:39.440
在顶部可以看到 AndroidFlavorAdapter 扩展自

00:03:39.440 --> 00:03:42.880
ArrayAdapter 表示它继承于 ArrayAdapter

00:03:44.130 --> 00:03:50.280
所以 ArrayAdapter 是超级类 AndroidFlavorAdapter 是子类

00:03:50.280 --> 00:03:55.260
除了继承自 ArrayAdapter

00:03:55.260 --> 00:03:59.960
我们还自定义了我们的适配器类 使数据来源为 AndroidFlavor 对象列表

00:04:01.910 --> 00:04:03.280
我们来看看其构造函数

00:04:04.470 --> 00:04:08.650
注意这里 我们调用了超级类构造函数

00:04:08.650 --> 00:04:11.230
所以我们调用了 ArrayAdapters 构造函数

00:04:11.230 --> 00:04:13.190
并传入三个输入参数

00:04:13.190 --> 00:04:16.704
记得之前我们讨论过接口

00:04:16.704 --> 00:04:20.480
因为 AndroidFlavorAdapter 继承自 ArrayAdapter

00:04:20.480 --> 00:04:23.270
所以我们可以使用 ArrayAdapter 的构造函数

00:04:23.270 --> 00:04:27.039
这样就可以自动获得初始化 ArrayAdapter 状态的逻辑

00:04:27.039 --> 00:04:29.640
不用自己去写这些逻辑

00:04:29.640 --> 00:04:33.710
我们可以阅读下 ArrayAdapter 文档

00:04:33.710 --> 00:04:35.260
详细了解下其构造函数

00:04:36.530 --> 00:04:40.760
回到 ArrayAdapter 开发者文档

00:04:40.760 --> 00:04:43.410
向下滚动到 Public Constructors 部分

00:04:44.600 --> 00:04:48.720
在所有这些公共构造函数中 我们的 AndroidFlavorAdapter

00:04:48.720 --> 00:04:52.480
使用的是倒数第二个

00:04:52.480 --> 00:04:56.306
当我们调用超级类的构造函数

00:04:56.306 --> 00:05:01.440
也就是 ArrayAdapter 构造函数时 我们需要传入三个输入参数

00:05:01.440 --> 00:05:05.920
即 Context 列表项布局资源 ID 和

00:05:05.920 --> 00:05:08.760
AndroidFlavor 对象列表

00:05:08.760 --> 00:05:13.130
复制这段代码并粘贴到这里

00:05:13.130 --> 00:05:16.930
以便稍后在我们的代码中参考下

00:05:18.750 --> 00:05:21.440
现在回到 Android Studio 查看下

00:05:21.440 --> 00:05:25.230
AndroidFlavorAdapter 的代码 这是 ArrayAdapter 的构造函数代码

00:05:25.230 --> 00:05:28.600
ArrayAdapter 在这里是超级类

00:05:28.600 --> 00:05:33.110
这里 我们传入 0 作为布局资源 ID

00:05:33.110 --> 00:05:37.150
因为我们不需要依赖超级类 ArrayAdapter 来为我们

00:05:37.150 --> 00:05:39.960
隐形膨胀或创建一个列表项视图

00:05:39.960 --> 00:05:43.630
我们的 getView() 方法将手动

00:05:43.630 --> 00:05:46.920
通过布局资源 ID 隐形膨胀布局

00:05:46.920 --> 00:05:48.290
再往下滚动一点点

00:05:49.750 --> 00:05:52.190
就能看到我刚刚说的内容

00:05:52.190 --> 00:05:57.310
在这里是 getView() 方法 我们重写了超级类的 getView() 方法

00:05:57.310 --> 00:06:02.360
并添加了我们自己针对具体使用情况的逻辑

00:06:03.750 --> 00:06:08.220
上面的注释提到我们的 getView 为某种 AdapterView

00:06:08.220 --> 00:06:09.499
提供了列表项视图

00:06:10.640 --> 00:06:14.410
正如之前提到的 AdapterView 可以是 ListView

00:06:14.410 --> 00:06:17.220
或 GridView 或其他类型的 AdapterView

00:06:18.350 --> 00:06:21.820
getView() 方法应该具有三个输入参数

00:06:21.820 --> 00:06:24.750
第一个是 position 即该布局应该展示的

00:06:24.750 --> 00:06:28.470
数据在列表中的位置

00:06:28.470 --> 00:06:33.620
convertView 即需要填充的回收视图 以及父 ViewGroup

00:06:33.620 --> 00:06:38.450
列表项将作为子视图添加到这个父 ViewGroup

00:06:38.450 --> 00:06:42.800
GetView() 方法中的第一步是 getItem() 方法

00:06:42.800 --> 00:06:46.980
后者是在超级类 ArrayAdapter 中定义的

00:06:46.980 --> 00:06:51.631
该方法会返回列表中给定索引位置的项目

00:06:51.631 --> 00:06:56.130
注意 该方法的返回值是数据类型为

00:06:56.130 --> 00:06:57.287
AndroidFlavor 的对象

00:06:57.287 --> 00:07:00.779
这是因为 在类声明中

00:07:00.779 --> 00:07:06.520
我们指定了该 ArrayAdapter 将传入 AndroidFlavor 对象列表

00:07:06.520 --> 00:07:08.766
当 ListView 调用 getView() 方法

00:07:08.766 --> 00:07:11.210
来获取列表中不同位置的列表项

00:07:11.210 --> 00:07:14.550
适配器将获得 androidFlavor 对象列表中

00:07:14.550 --> 00:07:16.878
不同位置的列表项

00:07:16.878 --> 00:07:20.560
这个 androidFlavor 对象包含将填充列表项的信息

00:07:20.560 --> 00:07:22.720
并且将立即从该列表项中读取数据

00:07:23.730 --> 00:07:28.140
getView() 方法的第二个输入参数是 convertView

00:07:29.230 --> 00:07:33.710
之前我们提到 是我们可以重复使用的现有视图

00:07:33.710 --> 00:07:36.310
但是有时候 该视图将等于 null

00:07:37.310 --> 00:07:39.240
意味着没有可以重复使用的视图

00:07:40.340 --> 00:07:44.800
视图为 null 很常见 当你第一次打开 Activity

00:07:44.800 --> 00:07:47.590
第一次创建列表项来填充到屏幕上就会这样

00:07:48.610 --> 00:07:50.090
屏幕上填满列表项后

00:07:50.090 --> 00:07:53.510
就有可能存在我们可以重复使用的有效视图

00:07:53.510 --> 00:07:54.400
对我们来说

00:07:54.400 --> 00:07:59.060
因为我们知道我们将使用列表项 我将 convertView

00:07:59.060 --> 00:08:01.960
分配为 listItemView 指定我们要处理的是什么类型的视图

00:08:02.960 --> 00:08:05.490
首先 我们使用 if 语句检查是否有可以重复使用的

00:08:05.490 --> 00:08:06.310
现有视图

00:08:07.390 --> 00:08:09.050
如果 listItemView 为 null

00:08:09.050 --> 00:08:13.800
那么我们就执行 if 语句里的这行代码

00:08:13.800 --> 00:08:17.810
这样会从 list_item.xml 布局文件隐形膨胀新的列表项视图

00:08:17.810 --> 00:08:22.030
如果你有疑问的话 解释下 我们使用 LayoutInflater

00:08:22.030 --> 00:08:25.190
将 XML 布局文件变成实际的视图对象

00:08:25.190 --> 00:08:29.270
我们手动隐形膨胀视图 所以我们不需要在构造函数中

00:08:29.270 --> 00:08:32.789
向超级类传入布局资源 ID

00:08:32.789 --> 00:08:35.440
因为这里我们传入了 0

00:08:35.440 --> 00:08:38.150
一旦知道 listItemView 是有效的

00:08:38.150 --> 00:08:41.840
不是 null 我们就可以根据 AndroidFlavor 对象

00:08:41.840 --> 00:08:45.480
开始更新列表项中的 TextView 和 ImageView

00:08:45.480 --> 00:08:49.380
注意 我们使用 findViewById 调用来查找在 ID list_item_icon

00:08:49.380 --> 00:08:56.580
或 list_item_name 或 list_item_number 中的视图

00:08:56.580 --> 00:09:01.530
一旦我们找到 ImageView 和 TextView 我们就可以调用

00:09:01.530 --> 00:09:07.112
setImageResource 或 setText 等方法 并传入 AndroidFlavor 对象的值

00:09:07.112 --> 00:09:11.984
以便更改要在这些视图中显示的数据

00:09:11.984 --> 00:09:15.534
总结下 我们可以从 currentAndroidFlavor 对象中

00:09:15.534 --> 00:09:19.368
获取不同的状态 例如版本名称

00:09:19.368 --> 00:09:22.074
版本号和图片资源 ID

00:09:22.074 --> 00:09:26.776
知道特定 AndroidFlavor 对象的这些信息后

00:09:26.776 --> 00:09:29.828
我们就可以将 ImageView 或 TextView

00:09:29.828 --> 00:09:34.720
设为我们从 AndroidFlavor 对象中获取的信息

00:09:34.720 --> 00:09:37.190
最终 我们返回列表项视图

00:09:37.190 --> 00:09:40.250
即包含当前 currentAndroidFlavor 对象的最新信息的

00:09:40.250 --> 00:09:41.870
列表项视图

00:09:43.070 --> 00:09:46.760
这个 ListItemView 将作为子项添加到 AdapterView 中

00:09:46.760 --> 00:09:52.520
这样 我们就大致介绍完了 AndroidFlavorAdapter

00:09:52.520 --> 00:09:59.310
为何是个自定义适配器 传入了 AndroidFlavor 对象列表

00:09:59.310 --> 00:10:01.900
当出现 ListItemView 请求时

00:10:01.900 --> 00:10:07.450
AndroidFlavorAdapter 将找到正确位置的 Android 视图

00:10:07.450 --> 00:10:10.590
然后创建或重复使用列表项布局

00:10:10.590 --> 00:10:14.540
系统将根据 AndroidFlavor 对象中的信息更新这些视图

00:10:14.540 --> 00:10:18.450
然后将 listItemView 返回给 listView

00:10:18.450 --> 00:10:19.460
回到 MainActivity

00:10:19.460 --> 00:10:23.899
最后两行代码用来实现 listView 和

00:10:23.899 --> 00:10:25.370
arrayAdapter

00:10:25.370 --> 00:10:28.110
我们在修改 Miwok 应用的时候见过

00:10:28.110 --> 00:10:30.520
这里我们引用了 listView

00:10:30.520 --> 00:10:32.025
称为引用 listView

00:10:33.500 --> 00:10:37.163
最后 将 flavorAdapter 附到 listView 上

00:10:37.163 --> 00:10:38.900
以便向其中填充数据

00:10:38.900 --> 00:10:41.760
我们刚刚分步讲解了一个非常复杂的结构

00:10:41.760 --> 00:10:42.840
我们再来总结下

00:10:43.990 --> 00:10:47.540
首先 我们创建了一种方式来存储自定义对象

00:10:48.580 --> 00:10:52.550
这里 我们使用 androidFlavors 数组

00:10:52.550 --> 00:10:55.630
其中包含 AndroidFlavor 对象

00:10:55.630 --> 00:11:00.740
接着 我们创建了一个自定义适配器 继承自 ArrayAdapter

00:11:00.740 --> 00:11:03.000
并将自定义对象作为输入参数

00:11:03.000 --> 00:11:03.600
对我们来说

00:11:03.600 --> 00:11:07.610
我们创建了 AndroidFlavorAdapter 继承自 ArrayAdapter

00:11:09.280 --> 00:11:12.660
并将自定义对象 AndroidFlavor 作为输入参数

00:11:12.660 --> 00:11:15.650
最后一步 我们修改了自定义适配器中的 getView() 方法

00:11:15.650 --> 00:11:19.110
以便为 ListView 提供列表项视图

00:11:20.220 --> 00:11:23.790
我们修改了 getView() 方法 以便从 ArrayAdapter 中

00:11:23.790 --> 00:11:25.500
获取相应位置的 AndroidFlavor 对象 ArrayAdapter

00:11:25.500 --> 00:11:30.020
然后使用该信息来填充

00:11:30.020 --> 00:11:33.990
回收的视图或新创建的视图

00:11:33.990 --> 00:11:37.600
强烈建议你自己再过一遍该项目

00:11:37.600 --> 00:11:40.770
看看你能否将所有部分结合到一起

00:11:40.770 --> 00:11:42.350
所有部分均有详细记录

00:11:42.350 --> 00:11:45.520
如果遇到不懂的地方 可以参阅上面的步骤

00:11:45.520 --> 00:11:48.790
可以画个图表来表示各部分的关系

00:11:48.790 --> 00:11:51.870
对于在 Android 中显示列表来说 理解自定义 ArrayAdapter 模式

00:11:51.870 --> 00:11:54.170
是个非常重要的概念

