WEBVTT
Kind: captions
Language: zh-CN

00:00:00.660 --> 00:00:03.650
我们的任务是判断出这四个选项中

00:00:03.650 --> 00:00:05.500
哪个可以创建一个像这个图表中展示的数组

00:00:06.560 --> 00:00:09.730
快速扫了一眼 发现变量名称是 soccerTeam and

00:00:09.730 --> 00:00:11.910
其中有 11 个元素

00:00:11.910 --> 00:00:14.100
各个索引处都有元素

00:00:14.100 --> 00:00:16.460
最好写下索引号

00:00:16.460 --> 00:00:18.310
这样更容易记住

00:00:18.310 --> 00:00:22.640
注意 我们从索引 0 开始 一直到索引 10

00:00:22.640 --> 00:00:28.230
意味着索引 0 处是整数 5 索引 1 处是整数 10

00:00:28.230 --> 00:00:33.340
值 23 位于索引 4 处 值 1 位于索引 10 处

00:00:34.380 --> 00:00:36.660
我们再来看看代码选项

00:00:36.660 --> 00:00:41.070
第一个选项创建了一个整型数组 长度为 11

00:00:41.070 --> 00:00:43.190
变量名称是 soccerTeam

00:00:43.190 --> 00:00:45.038
到目前为止看起来都是正确的

00:00:45.038 --> 00:00:48.460
然后我们在索引 0 处初始化为值 5

00:00:48.460 --> 00:00:52.260
等等 我们刚刚提到值 5 应该位于索引 0 处

00:00:52.260 --> 00:00:53.748
所以这行是错误的

00:00:53.748 --> 00:00:57.590
下一行 我们将值 10

00:00:57.590 --> 00:00:58.300
分配到了索引 2 处

00:00:58.300 --> 00:01:00.510
再回来看看该图表

00:01:00.510 --> 00:01:02.720
我们发现它应该存储在索引 1 处

00:01:02.720 --> 00:01:05.880
这段代码演示了初学者会犯的常见错误

00:01:05.880 --> 00:01:09.520
刚开始使用数组时 很容易就认为索引是从 1 开始的

00:01:09.520 --> 00:01:13.700
结束处是数组长度 在此示例中即 11

00:01:13.700 --> 00:01:18.960
但是实际上 对于长度为 11 的数组来说

00:01:18.960 --> 00:01:21.020
索引是从 0 一直到 10

00:01:21.020 --> 00:01:23.550
这意味着选项 1 不正确

00:01:23.550 --> 00:01:24.430
我们再看看选项 2

00:01:24.430 --> 00:01:28.440
我们一开始创建了一个长度为 11 的整型数组

00:01:28.440 --> 00:01:33.120
到目前为止正确 但是变量名称仅仅是 team

00:01:33.120 --> 00:01:35.490
我们希望变量名称是 soccerTeam

00:01:35.490 --> 00:01:36.780
所以这个选项已经不正确了

00:01:37.800 --> 00:01:39.660
后面的代码也是不正确的

00:01:39.660 --> 00:01:42.530
因为我们只是检索这些索引处的值

00:01:42.530 --> 00:01:44.960
而不是向这些位置分配值

00:01:44.960 --> 00:01:47.100
所以选项 2 也是不正确的

00:01:47.100 --> 00:01:49.338
现在来看看选项 3

00:01:49.338 --> 00:01:51.973
我们创建了一个长度为 11 的整型数组

00:01:51.973 --> 00:01:56.070
变量的名称叫做 soccerTeam 所以到目前为止看起来正确

00:01:56.070 --> 00:02:00.410
我们将索引 0 初始化为值 5

00:02:00.410 --> 00:02:04.870
第 10 个索引赋为值 4 错了 是值 1

00:02:04.870 --> 00:02:06.970
第 4 个索引赋为值 23

00:02:06.970 --> 00:02:10.960
第 1 个索引赋为值 10

00:02:10.960 --> 00:02:12.840
嘿 这正是我们需要的

00:02:12.840 --> 00:02:15.360
与测试题图片中的图表相符

00:02:15.360 --> 00:02:19.190
你可能有疑问 代码是按照随机顺序赋的值

00:02:19.190 --> 00:02:23.390
我们分配了第一个元素的值 然后是最后一个元素的值

00:02:23.390 --> 00:02:26.630
然后是一些中间元素 这些语句的顺序是怎样的并没有关系

00:02:26.630 --> 00:02:30.410
因为这些代码行相互之间是独立的

00:02:30.410 --> 00:02:34.045
在代码段结束时 如果你想再次为第 0 个索引赋值

00:02:34.045 --> 00:02:35.172
完全可以的

00:02:35.172 --> 00:02:39.980
数组将根据对该位置的最新更新做出更新

00:02:39.980 --> 00:02:42.670
太棒了 选项 3 是正确答案

00:02:42.670 --> 00:02:44.530
如果你没有答对 也不用担心

00:02:44.530 --> 00:02:46.830
这是你第一次学习数组

00:02:46.830 --> 00:02:49.620
以后将有更多的练习机会

00:02:49.620 --> 00:02:53.280
如果你想看看选项 4 的话 我们一起来研究下

00:02:53.280 --> 00:02:56.935
在选项 4 中 我们创建了一个整型数组

00:02:56.935 --> 00:03:01.928
但是我们将 int 首字母大写了 因为整型数据类型是原始类型

00:03:01.928 --> 00:03:05.160
所以 int 中的 i 应该是小写的

00:03:05.160 --> 00:03:06.260
所以这里已经存在问题了

00:03:07.310 --> 00:03:11.070
还有另一个问题是数据类型和数组括号之间

00:03:11.070 --> 00:03:12.670
有个空格

00:03:12.670 --> 00:03:15.587
这样的话 Java 会报错 因为不是有效的数组

00:03:15.587 --> 00:03:16.860
声明

00:03:16.860 --> 00:03:20.380
选项 4 后面的代码也不正确

00:03:20.380 --> 00:03:23.950
我们向这些索引位置设置了字符串值

00:03:23.950 --> 00:03:27.220
可以通过双引号判断出这些是字符串

00:03:27.220 --> 00:03:30.330
但问题是 我们打算创建的是整型数组

00:03:30.330 --> 00:03:33.667
所以不能在该数组的元素中存储字符串

00:03:33.667 --> 00:03:35.680
因此选项 4 不正确

